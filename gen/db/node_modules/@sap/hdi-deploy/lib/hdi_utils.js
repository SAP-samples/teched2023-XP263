'use strict';

const logger = require('./logger.js');
const utils = require('./utils');
const fs = require('./fileWorker');
const { SchemaPrivilege } = require('@sap/hdi');
const micromatch = require('micromatch');

/**
 * Filter out client only files in the deploy set and/or transform them accordingly.
 *
 * @param {Array} files List of files to deploy.
 * @returns {Array} The filtered files.
 */
function handle_client_files (files) {
  // Filter out grantor files and turn into a set to allow blindly adding config files without risking duplicates.
  const cleaned = new Set();
  files.forEach((file) => {
    if (!utils.isDeployableFile(file)) {
      // Do nothing.
      logger.log('Filtered undeployable file', file);
    } else if (utils.isSynonymTemplateFile(file)) {
      // Ensure that for each template file the corresponding config will be deployed.
      cleaned.add(utils.rename_synonymtemplate_to_config(file));
      logger.log('Filtered .hdbsynonymtempate file', file);
    } else {
      cleaned.add(file);
    }
  });

  return Array.from(cleaned);
}

/**
 * Filter undeploy with undeploy.json.
 *
 * @param {Array} undeployFiles Files scheduled for undeploy
 * @param {Object} options Options
 * @returns {Array} Undeploy files.
 */
function filterUndeploy (undeployFiles, options) {
  const filename = options.undeployFilename;
  let paths = [];

  if (fs.existsSync(filename)) {
    logger.log('Undeploy allowlist file "undeploy.json" found; deleted files will be filtered by the allowlist');
    try {
      paths = fs.readJSONFile(filename);
    } catch (e) {
      logger.error(`Could not read the "undeploy.json": ${e.message ? e.message : e}`);
      logger.error('Proceeding with an empty allowlist and no files will be scheduled for undeploy.');
      return [];
    }
    logger.log(`${undeployFiles.length} deleted files are scheduled for undeploy before filtering it by undeploy allowlist`);
    logger.log('deleted files before filtering it by the undeploy allowlist:', JSON.stringify(undeployFiles, null, 2));
    return micromatch(undeployFiles, paths, { dot: true});

  } else {
    logger.log('Undeploy allowlist file "undeploy.json" not found; an empty allowlist is used and no files will be scheduled for undeploy');
    return [];
  }
}

/**
 * Filter DeployFiles based on options
 *
 * @param {Array} deployFiles Files scheduled for undeploy
 * @param {Object} options Options
 * @returns {Object} deploy files , deployfiles count.
 */
function filteredDeployFiles (deployFiles, content, options) {
  // filter current deployFiles and undeployFiltes via the working set
  if (options.workingSet.valid) {
    deployFiles = deployFiles.filter(function (file) {
      return options.workingSet.matchesPath(file);
    });
  }
  if (options.treatUnmodifiedAsModified) {
    logger.log(`${deployFiles.length} modified, unmodified, or added files are scheduled for deploy`);
  } else {
    logger.log(`${deployFiles.length} modified or added files are scheduled for deploy based on delta detection`);
  }

  const explicitDeployFiles = new Set();
  let optionsDeployCount = 0;

  /*
   * add explicit deploy set, but filter it via the working set
   * Since deploy files will be filtered in "Handle client files", already substract files we know will be removed.
   */
  options.deploy.forEachFile(function (p) {
    if (options.workingSet.matchesPath(p)) {
      explicitDeployFiles.add(p);
      if (utils.isGrantorFile(p)) {
        optionsDeployCount--;
      }
    }
  });

  // add files defined by file pattern
  if (options.deploy) {
    options.deploy.filter_by_regex(content.deployFiles.map((item) => item[0])).forEach((file) => explicitDeployFiles.add(file));
  }

  explicitDeployFiles.forEach((file) => {
    if (!options.excludeFilter.matchesPath(file)) {
      deployFiles.push(file);
      optionsDeployCount++;
    }
  });
  return {deployFiles, optionsDeployCount};
}

/**
 * Filter UndeployFiles based on options
 *
 * @param {Array} undeployFiles Files scheduled for undeploy
 * @param {Object} options Options
 * @returns {Object} Undeploy files , undeploy files count.
 */
function filteredUndeployFiles (undeployFiles, options) {
  // filter the undeploy set by the include-filter,EW because deleted files are not considered during the file walk
  if (options.includeFilter.valid) {
    undeployFiles = undeployFiles.filter(function (file) {
      return options.includeFilter.matchesPath(file);
    });
  }


  undeployFiles = undeployFiles.filter(function (file) {
    return options.workingSet.matchesPath(file);
  });

  logger.log(`${undeployFiles.length} deleted files are scheduled for undeploy based on delta detection (filtered by undeploy allowlist)`);

  const explicitUndeployFiles = new Set();
  // add explicit undeploy set, but filter it via the working set
  options.undeploy.forEachFile(function (p) {
    if (options.workingSet.matchesPath(p)) {
      explicitUndeployFiles.add(p);
    }
  });

  let optionsUndeployCount = 0;

  explicitUndeployFiles.forEach((file) => {
    if (!options.excludeFilter.matchesPath(file)) {
      undeployFiles.push(file);
      optionsUndeployCount++;
    }
  });

  return {undeployFiles, optionsUndeployCount};
}

/**
 * Prepare the sync.
 *
 * @param {any} result Result of a listDeployed call.
 * @param {Content} content Content object
 * @returns {Object} addedLocalFiles and deletedLocalFiles, unmodifiedModifiedLocalFiles files.
 */
function prepareSync (result, content) {
  let deployedFilesSystemFiles = [];
  const deletedLocalFiles = [];
  const unmodifiedModifiedLocalFiles =[];
  const addedLocalFiles = [];
  const deployFiles = content.deployFiles.map((fileOrFolder) => {
    return fileOrFolder[0];
  });

  deployedFilesSystemFiles = result.map(function (item) {
    return item.path;
  });

  deployedFilesSystemFiles.forEach((file) => {
    //check if it is not folder as deployedFilesSystemFiles includes folders as well eg: src/ , cfg/
    if (!file.endsWith('/')) {
      if (deployFiles.includes(file)) {
        unmodifiedModifiedLocalFiles.push(file);
      } else {
        deletedLocalFiles.push(file);
      }
    }
  });

  deployFiles.forEach((file) => {
    if (!deployedFilesSystemFiles.includes(file)) {
      addedLocalFiles.push(file);
    }
  });

  return {
    addedLocalFiles,
    deletedLocalFiles,
    unmodifiedModifiedLocalFiles
  };
}


/**
 * Prepare the optimise make.
 *
 * @param {Array} addedFiles added files
 * @param {Array} deletedFiles deleted files
 * @param {Array} modifiedFiles modified files
 * @param {Array} unmodifiedFiles unmodified files
 * @param {Object} options Options
 * @param {Content} content Content object
 * @returns {Object} Deploy and Undeploy files.
 */
function prepareOptimiseMake (addedFiles, deletedFiles, modifiedFiles, unmodifiedFiles, options, content) {
  let deployFiles;
  let undeployFiles;

  deployFiles = addedFiles.concat(modifiedFiles).filter((item) => !options.excludeFilter.matchesPath(item));


  if (options.treatUnmodifiedAsModified) {
    // schedule all locally collected files for deploy; this maps to Added, Modified, or Unmodified
    deployFiles = deployFiles.concat(unmodifiedFiles).filter((item) => !options.excludeFilter.matchesPath(item));
  }
  undeployFiles = deletedFiles.filter((item) => !options.excludeFilter.matchesPath(item));

  logger.log('added files:', JSON.stringify(addedFiles, null, 2));
  logger.log('modified files:', JSON.stringify(modifiedFiles, null, 2));
  if (options.treatUnmodifiedAsModified) {

    logger.log('treated as modified files:', JSON.stringify(unmodifiedFiles, null, 2));
  }

  // filter the undeploy set based on the undeploy.json file
  if (undeployFiles.length && !options.autoUndeploy) {
    undeployFiles = filterUndeploy(undeployFiles, options);
  }
  logger.log('deleted files:', JSON.stringify(undeployFiles, null, 2));

  const deployFilesAndDeployCount = filteredDeployFiles(deployFiles, content, options);
  const undeployFilesAndUndeployCount = filteredUndeployFiles(undeployFiles, options);

  deployFiles = handle_client_files(deployFilesAndDeployCount.deployFiles);
  undeployFiles = undeployFilesAndUndeployCount.undeployFiles;
  // undeployFiles = handle_client_files(undeployFiles);

  logger.log(`${deployFilesAndDeployCount.optionsDeployCount} files are scheduled for deploy based on explicit specification`);
  logger.log(`${undeployFilesAndUndeployCount.optionsUndeployCount} files are scheduled for undeploy based on explicit specification`);
  return {
    deployFiles,
    undeployFiles
  };
}

function prepareMake (result, options, content) {
  let deployFiles;
  let undeployFiles;
  const addedFiles = [];
  const modifiedFiles = [];
  let unmodifiedFiles;

  deployFiles = result.filter(function (item) {
    if (item.status === 'A' && !options.excludeFilter.matchesPath(item.path)) {
      addedFiles.push(item.path);
      return true;
    } else if (item.status === 'M' && !options.excludeFilter.matchesPath(item.path)) {
      modifiedFiles.push(item.path);
      return true;
    }
  }).map(function (item) {
    return item.path;
  });


  if (options.treatUnmodifiedAsModified) {
    // schedule all locally collected files for deploy; this maps to Added, Modified, or Unmodified
    deployFiles = content.deployFiles.map(function (item) {
      return item[0];
    })
      .filter((item) => !options.excludeFilter.matchesPath(item));

    unmodifiedFiles = deployFiles.filter(function (item) {
      return (modifiedFiles.indexOf(item) === -1) && (addedFiles.indexOf(item) === -1);
    });

  }
  undeployFiles = result.filter(function (item) {
    return item.status === 'D';
  })
    .map(function (item) {
      return item.path;
    })
    .filter((item) => !options.excludeFilter.matchesPath(item));

  logger.trace('status result:', result);
  logger.log('added files:', JSON.stringify(addedFiles, null, 2));
  logger.log('modified files:', JSON.stringify(modifiedFiles, null, 2));
  if (options.treatUnmodifiedAsModified) {

    logger.log('treated as modified files:', JSON.stringify(unmodifiedFiles, null, 2));
  }

  // filter the undeploy set based on the undeploy.json file
  if (undeployFiles.length && !options.autoUndeploy) {
    undeployFiles = filterUndeploy(undeployFiles, options);
  }
  logger.log('deleted files:', JSON.stringify(undeployFiles, null, 2));

  const deployFilesAndDeployCount = filteredDeployFiles(deployFiles, content, options);
  const undeployFilesAndUndeployCount = filteredUndeployFiles(undeployFiles, options);


  deployFiles = handle_client_files(deployFilesAndDeployCount.deployFiles);
  undeployFiles = undeployFilesAndUndeployCount.undeployFiles;
  // undeployFiles = handle_client_files(undeployFiles);

  logger.log(`${deployFilesAndDeployCount.optionsDeployCount} files are scheduled for deploy based on explicit specification`);
  logger.log(`${undeployFilesAndUndeployCount.optionsUndeployCount} files are scheduled for undeploy based on explicit specification`);

  return {
    deployFiles,
    undeployFiles
  };
}

function getDefaultPermissionSet (containerAccessRoleName, options) {
  const permissions =   [
    ['CREATE TEMPORARY TABLE', '', containerAccessRoleName],
    ['DELETE', '', containerAccessRoleName],
    ['EXECUTE', '', containerAccessRoleName],
    ['INSERT', '', containerAccessRoleName],
    ['SELECT', '', containerAccessRoleName],
  ];

  if (!options.isHanaCloud) {
    permissions.push(['SELECT CDS METADATA', '', containerAccessRoleName]);
  }
  permissions.push(['UPDATE', '', containerAccessRoleName]);

  return permissions.map((permission) => new SchemaPrivilege(permission[0], permission[1], permission[2]));
}

module.exports = {prepareSync, prepareOptimiseMake, prepareMake, getDefaultPermissionSet};
