'use strict';
const Container = require('../Container');
const util = require('util');

/**
 * Provides access to the API of a given HDI container
 * Minimum required HANA server version: 1.00.120
 */
class ContainerPromises {
  /**
   * Constructs an access object for a given container and opens a connection to the database
   * Requires SELECT privilege on _SYS_DI.TT_*
   * @constructor
   * @param {string} containerName the name of the container
   * @param {Object} credentials an object containing the necessary information to connect to a HANA database
   * @param {string} credentials.host hostname for the connection
   * @param {number} credentials.port port for the connection
   * @param {string} credentials.user username for the connection
   * @param {string} credentials.password password of the user
   * @param {string[]} credentials.ca Certificates to use for the connection. Optional.
   * @param {string} paramSchema a schema that will be used to create temp tables to supply arguments to procedure calls
   * @param {boolean} usehdb usehdb flag to use hdb or hana-client while connecting to database
   */
  constructor(containerName, credentials, paramSchema, usehdb) {
    this._container = new Container(containerName, credentials, paramSchema, usehdb);
  }
  /**
   * Acquires a lock on the container's lock table.
   * NOTE: Acquiring the lock is not strictly required for a client, so other clients might ignore it.
   * Requires EXECUTE privilege on LOCK
   * Minimum required HANA server version: 2.00.010
   * @param {number} timeout lock wait timeout in milliseconds
   * @param {Parameter[]} params parameters controlling the current procedure call
   * @returns {Promise} ResultTuple
   * @async
   */
  lock(timeout, params) {
    return util.promisify(this._container.lock).bind(this._container)(timeout, params);
  }
  /**
   * Connect to the HANA DB with the credentials passed to the constructor.
   * Requires SELECT privilege on _SYS_DI.TT_*
   * @returns {Promise} String Success message.
   * @async
   */
  connect() {
    return util.promisify(this._container.connect).bind(this._container)();
  }

  /**
   * Disconnect from the HANA DB
   * @returns {Promise} String Success message.
   */
   disconnect() {
    return new Promise((resolve, reject) => {
      try {
        let msg = this._container.disconnect();
        resolve(msg);
      } catch (error) {
        reject(error);
      }
    });
  }

  /* eslint-enable no-shadow */
  /**
   * Returns the default privileges required for working with a container
   * Requires SELECT privilege on _SYS_DI.T_DEFAULT_CONTAINER_USER_PRIVILEGES
   * Minimum required HANA server version: 2.00.010
   * @param {string} principalSchema schema of the target user/role (empty for global principals)
   * @param {string} principalName name of the target user/role
   * @returns {Promise} list of APIPrivilege
   * @async
   */
  getDefaultContainerUserPrivileges(principalSchema, principalName) {
    return util.promisify(this._container.getDefaultContainerUserPrivileges).bind(this._container)(principalSchema, principalName);
  }

  /**
   * Returns the default privileges required for role administration of a container
   * Requires SELECT privilege on _SYS_DI.T_DEFAULT_CONTAINER_ROLE_ADMIN_PRIVILEGES
   * Requires DI.API version greater or equal 15 (OP) or greater or equal 1001 (CE)
   * @param {string} principalSchema schema of the target user/role (empty for global principals)
   * @param {string} principalName name of the target user/role
   * @returns {Promise} list of APIPrivilege
   * @async
   */
   getDefaultContainerRoleAdminPrivileges(principalSchema, principalName) {
    return util.promisify(this._container.getDefaultContainerRoleAdminPrivileges).bind(this._container)(principalSchema, principalName);
  }


  /**
   * Returns the default common privileges required for working with HDI
   * Requires SELECT privilege on _SYS_DI.T_DEFAULT_COMMON_PRIVILEGES
   * @param {string} principalSchema schema of the target user/role (empty for global principals)
   * @param {string} principalName name of the target user/role
   * @returns {Promise} list of APIPrivilege
   * @async
   */
  getDefaultCommonPrivileges(principalSchema, principalName) {
    return util.promisify(this._container.getDefaultCommonPrivileges).bind(this._container)(principalSchema, principalName);
  }
  
      
  /**
   * Returns the default privileges required for administration of a container
   * Requires SELECT privilege on _SYS_DI.T_DEFAULT_CONTAINER_ADMIN_PRIVILEGES
   * Minimum required HANA server version: 2.00.010
   * @param {string} principalSchema schema of the target user/role (empty for global principals)
   * @param {string} principalName name of the target user/role
   * @returns {Promise} list of APIPrivilege
   * @async
   */
  getDefaultContainerAdminPrivileges(principalSchema, principalName) {
    return util.promisify(this._container.getDefaultContainerAdminPrivileges).bind(this._container)(principalSchema, principalName);
  }

  /**
   * Requires SELECT privilege on _SYS_DI.T_DEFAULT_LIBRARIES
   * @returns {Promise} list of LibraryConfiguration
   * @async
   */
  getDefaultLibraries() {
    return util.promisify(this._container.getDefaultLibraries).bind(this._container)();
  }

  /**
   * Exports container for copy into a specified table within a specified schema.
   * NOTE: The table must be created before calling this function. Furthermore, the [containerName]#DI user must be granted SELECT and INSTERT privileges on the specified table.
   * Requires EXECUTE privilege on EXPORT_CONTAINER_FOR_COPY
   * Minimum required HANA server version: 2.00.010
   * @param {string} tableName table name for the exported files to be placed in
   * @param {string} tableSchema schema of the specified table
   * @param {Parameter[]} params parameters controlling the current procedure call
   * @returns {Promise} ResultTuple
   * @async
   */
  exportContainerForCopy(tableName, tableSchema, params) {
    return util.promisify(this._container.exportContainerForCopy).bind(this._container)(tableName, tableSchema, params);
  }

  /**
   * Imports container for copy into a specifies table within a specified schema.
   * NOTE: The table must be created before calling this function. Furthermore, the [containerName]#DI user must be granted SELECT privileges on the specified table.
   * Requires EXECUTE privilege on IMPORT_CONTAINER_FOR_COPY
   * Minimum required HANA server version: 2.00.010
   * @param {string} tableName table name for the exported files to be placed in
   * @param {string} tableSchema schema of the specified table
   * @param {Parameter[]} params parameters controlling the current procedure call
   * @returns {Promise} ResultTuple
   * @async
   */
   importContainerForCopy(tableName, tableSchema, params) {
    return util.promisify(this._container.importContainerForCopy).bind(this._container)(tableName, tableSchema, params);
  }

  /**
   * Configures a container with the given configuration parameters and the given parameters.
   * Requires EXECUTE privilege on CONFIGURE_CONTAINER_PARAMETERS
   * @param {Parameter[]} configParams parameters to configure the container
   * @param {Parameter[]} params parameters controlling the current procedure call
   * @returns {Promise} ResultTuple
   * @async
   */
  configureContainerParameters(configParams, params) {
    return util.promisify(this._container.configureContainerParameters).bind(this._container)(configParams, params);
  }

  /**
   * (Re)configures the set of plugin libraries which are installed in the given container.
   * Requires EXECUTE privilege on CONFIGURE_LIBRARIES
   * @param {LibraryConfiguration[]} libs configuration for the libraries
   * @param {Parameter[]} params parameters controlling the current procedure call
   *               - UNDEPLOY: true, false (default)
   * @returns {Promise} ResultTuple
   * @async
   */
  configureLibraries(libs, params) {
    return util.promisify(this._container.configureLibraries).bind(this._container)(libs, params);
  }

  /**
   * List the set of plugin libraries which are installed in the given container.
   * Requires EXECUTE privilege on LIST_CONFIGURED_LIBRARIES
   * @param {Parameter[]} params parameters controlling the current procedure call
   * @returns {Promise} LibraryInformationResultTuple
   * @async
   */
  listConfiguredLibraries(params) {
    return util.promisify(this._container.listConfiguredLibraries).bind(this._container)(params);
  }

  /**
   * Shows the status of the given files/folders in the container's file systems.
   * Requires EXECUTE privilege on STATUS
   * @param {Path[]} filesFolders list of files/folders to check for their status
   * @param {Parameter[]} params parameters controlling the current procedure call
   * @returns {Promise} StatusResultTuple
   * @async
   */
  status(filesFolders, params) {
    return util.promisify(this._container.status).bind(this._container)(filesFolders, params);
  }

  /**
   * Reads the given files/folders from the container's work file system.
   * Requires EXECUTE privilege on READ
   * @param {Path[]} filesFolders list of file/folders to read
   * @param {Parameter[]} params parameters controlling the current procedure call.
   *                  -RECURSIVE: true, false (default)
   *                  -IGNORE_FILES: true, false (default)
   *                  -IGNORE_FOLDERS: true, false (default)
   * @returns {Promise} MetadataContentResultTuple
   * @async
   */
  read(filesFolders, params) {
    return util.promisify(this._container.read).bind(this._container)(filesFolders, params);
  }

  /**
   * Reads the given files/folders from the container's deployed file system.
   * Requires EXECUTE privilege on READ_DEPLOYED
   * @param {Path[]} filesFolders list of file/folders to read
   * @param {Parameter[]} params parameters controlling the current procedure call
   *               - RECURSIVE: true, false (default)
   *               - IGNORE_FILES: true, false (default)
   *               - IGNORE_FOLDERS: true, false (default)
   * @returns {Promise} MetadataContentResultTuple
   * @async
   */
  readDeployed(filesFolders, params) {
    return util.promisify(this._container.readDeployed).bind(this._container)(filesFolders, params);
  }

  /**
   * Reads the metadata for the given files/folders from the container's work file system.
   * Requires EXECUTE privilege on LIST
   * @param {Path[]} filesFolders list of file/folders to read
   * @param {Parameter[]} params parameters controlling the current procedure call
   *               - RECURSIVE: true, false (default)
   *               - IGNORE_FILES: true, false (default)
   *               - IGNORE_FOLDERS: true, false (default)
   * @returns {Promise} MetadataResultTuple
   * @async
   */
  list(filesFolders, params) {
    return util.promisify(this._container.list).bind(this._container)(filesFolders, params);
  }

  /**
   * Reads the metadata for the given files/folders from the container's deployed file system.
   * Requires EXECUTE privilege on LIST_DEPLOYED
   * @param {Path[]} filesFolders list of file/folders to read
   * @param {Parameter[]} params parameters controlling the current procedure call
   *               - RECURSIVE: true, false (default)
   *               - IGNORE_FILES: true, false (default)
   *               - IGNORE_FOLDERS: true, false (default)
   * @returns {Promise} MetadataResultTuple
   * @async
   */
  listDeployed(filesFolders, params) {
    return util.promisify(this._container.listDeployed).bind(this._container)(filesFolders, params);
  }

  /**
   * Writes/creates the given files/folders to/in the container's work file system.
   * Requires EXECUTE privilege on WRITE
   * @param {PathWithContent[]} filesFolders list of file/folders to write, including content (NULL for folders)
   * @param {Parameter[]} params parameters controlling the current procedure call
   * @returns {Promise} ResultTuple
   * @async
   */
  write(filesFolders, params) {
    return util.promisify(this._container.write).bind(this._container)(filesFolders, params);
  }

  /**
   * Deletes the given files/folders from/in the container's work file system.
   * Requires EXECUTE privilege on DELETE
   * @param {Path[]} filesFolders list of files/folders to delete
   * @param {Parameter[]} params parameters controlling the current procedure call
   *               - RECURSIVE: true, false (default)
   * @returns {Promise} ResultTuple
   * @async
   */
  delete(filesFolders, params) {
    return util.promisify(this._container.delete).bind(this._container)(filesFolders, params);
  }

  /**
   * Triggers a make with the given set of files.
   * Requires EXECUTE privilege on MAKE
   * @param {File[]} deployFiles list of files to deploy
   * @param {File[]} undeployFiles list of files to undeploy
   * @param {PathParameter[]} pathParameters parameters controlling the current procedure call, specific for each single file
   * @param {Parameter[]} params parameters controlling the current procedure call
   * @returns {Promise} ResultTuple
   * @async
   */
  make(deployFiles, undeployFiles, pathParameters, params) {
    return util.promisify(this._container.make).bind(this._container)(deployFiles, undeployFiles, pathParameters, params);
  }

  /**
   * Triggers a make with the given set of files in asynchronous mode.
   * The call returns with a REQUEST_ID while the make continuous to run in the background.
   * The status of the make can be checked via M_JOBS and M_MESSAGES.
   * Requires EXECUTE privilege on MAKE_ASYNC
   * @param {File[]} deployFiles list of files to deploy
   * @param {File[]} undeployFiles list of files to undeploy
   * @param {PathParameter[]} pathParameters file-level parameters
   * @param {Parameter[]} params parameters controlling the current procedure call
   * @returns {Promise} ResultTuple
   * @async
   */
  makeAsync(deployFiles, undeployFiles, pathParameters, params) {
    return util.promisify(this._container.makeAsync).bind(this._container)(deployFiles, undeployFiles, pathParameters, params);
  }

  /**
   * Tries to cancel the asynchronous request with the given request id.
   * Requires EXECUTE privilege on CANCEL
   * @param {number} requestId request id of the request to cancel
   * @param {Parameter[]} params parameters controlling the current procedure call
   * @returns {Promise} ResultTuple
   * @async
   */
  cancel(requestId, params) {
    return util.promisify(this._container.cancel).bind(this._container)(requestId, params);
  }

  /**
   * Calculates groups of objects which can be passed to a make call independently.
   * Requires EXECUTE privilege on MAKE
   * Minimum required HANA server version: 2.00.000
   * @param {File[]} deployFiles list of files to deploy
   * @param {File[]} undeployFiles list of files to undeploy
   * @param {PathParameter[]} pathParameters parameters controlling the current procedure call, specific for each single file
   * @param {Parameter[]} params parameters controlling the current procedure call
   * @returns {Promise} MakeGroupResultTuple
   * @async
   */
  getMakeGroups(deployFiles, undeployFiles, pathParameters, params) {
    return util.promisify(this._container.getMakeGroups).bind(this._container)(deployFiles, undeployFiles, pathParameters, params);
  }

  /**
   * Retrieves dependency data.
   * The kind of data retrieved depends on the optional parameter "variant" (passed via PARAMETERS).
   * Requires EXECUTE privilege on GET_DEPENDENCIES
   * Minimum required HANA server version: 2.00.000
   * @param {HDIObject[]} objects list of objects for which dependency data should be retrieved
   * @param {Parameter[]} params parameters controlling the current procedure call
   * @returns {Promise} DependencyTuple
   * @async
   */
  getDependencies(objects, params) {
    return util.promisify(this._container.getDependencies).bind(this._container)(objects, params);
  }

  /**
   * Close the lock_connection to unlock.
   * @returns {Promise}
   */
  unlock() {
    return util.promisify(this._container.unlock).bind(this._container)();
  }
  
  /**
   * Grants the given privileges on the container's API objects to the given users.
   * Requires EXECUTE privilege on GRANT_CONTAINER_API_PRIVILEGES
   * @param {APIPrivilege[]} privileges list of APIPrivilege describing what and to whom to grant
   * @param {Parameter[]} params parameters controlling the current procedure call
   * @returns {Promise} ResultTuple
   * @async
   */
  grantContainerApiPrivileges(privileges, params) {
    return util.promisify(this._container.grantContainerApiPrivileges).bind(this._container)(privileges, params);
  }

  /**
   * Grants the given privileges on the container's API objects to the given users with grant option.
   * Requires EXECUTE privilege on GRANT_CONTAINER_API_PRIVILEGES_WITH_GRANT_OPTION
   * @param {APIPrivilege[]} privileges list of APIPrivilege describing what and to whom to grant
   * @param {Parameter[]} params parameters controlling the current procedure call
   * @returns {Promise} ResultTuple
   * @async
   */
  grantContainerApiPrivilegesWithGrantOption(privileges, params) {
    return util.promisify(this._container.grantContainerApiPrivilegesWithGrantOption).bind(this._container)(privileges, params);
  }

  /**
   * Revokes the given privileges on the container's API objects from the given users.
   * Requires EXECUTE privilege on REVOKE_CONTAINER_API_PRIVILEGES
   * @param {APIPrivilege[]} privileges list of APIPrivilege
   * @param {Parameter[]} params parameters controlling the current procedure call
   * @returns {Promise} ResultTuple
   * @async
   */
  revokeContainerApiPrivileges(privileges, params) {
    return util.promisify(this._container.revokeContainerApiPrivileges).bind(this._container)(privileges, params);
  }

  /**
   * Grants the given privileges on the container's target schema to the given users.
   * Requires EXECUTE privilege on GRANT_CONTAINER_SCHEMA_PRIVILEGES
   * @param {SchemaPrivilege[]} privileges list of SchemaPrivilege describing what and to whom to grant
   * @param {Parameter[]} params parameters controlling the current procedure call
   * @returns {Promise} ResultTuple
   * @async
   */
  grantContainerSchemaPrivileges(privileges, params) {
    return util.promisify(this._container.grantContainerSchemaPrivileges).bind(this._container)(privileges, params);
  }

  /**
   * Revokes the given privileges on the container's target schema from the given users.
   * Requires EXECUTE privilege on REVOKE_CONTAINER_SCHEMA_PRIVILEGES
   * @param {SchemaPrivilege[]} privileges list of SchemaPrivilege
   * @param {Parameter[]} params parameters controlling the current procedure call
   * @returns {Promise} ResultTuple
   * @async
   */
  revokeContainerSchemaPrivileges(privileges, params) {
    return util.promisify(this._container.revokeContainerSchemaPrivileges).bind(this._container)(privileges, params);
  }

  /**
   * Grants the given roles which are deployed inside the container to the given users.
   * Requires EXECUTE privilege on GRANT_CONTAINER_SCHEMA_ROLES
   * @param {SchemaRole[]} roles list of SchemaRole
   * @param {Parameter[]} params parameters controlling the current procedure call
   * @returns {Promise} ResultTuple
   * @async
   */
  grantContainerSchemaRoles(roles, params) {
    return util.promisify(this._container.grantContainerSchemaRoles).bind(this._container)(roles, params);
  }

  /**
   * Revokes the given roles which are deployed inside the container from the given users.
   * Requires EXECUTE privilege on REVOKE_CONTAINER_SCHEMA_ROLES
   * @param {SchemaRole[]} roles list of SchemaRole
   * @param {Parameter[]} params parameters controlling the current procedure call
   * @returns {Promise} ResultTuple
   * @async
   */
  revokeContainerSchemaRoles(roles, params) {
    return util.promisify(this._container.revokeContainerSchemaRoles).bind(this._container)(roles, params);
  }
}
module.exports = ContainerPromises;
