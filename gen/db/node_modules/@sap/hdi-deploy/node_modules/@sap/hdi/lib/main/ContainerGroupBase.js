'use strict';
const HDIBase = require('./HDIBase');
const CONSTANTS = require('../util/Constants');
const LibraryInformationResultTuple = require('../result/LibraryInformationResultTuple');
const typeCheck = require('../util/typeCheck');
const async = require('async');
const series_callback = require('../util/callback.js');
const wrap = require('../util/wrap.js');

const APIPrivilege = require('../parameter/APIPrivilege');
const LibraryConfiguration = require('../parameter/LibraryConfiguration');
const Parameter = require('../parameter/Parameter');
const SchemaPrivilege = require('../parameter/SchemaPrivilege');
const SchemaRole = require('../parameter/SchemaRole');


/**
 * Callback that takes errors as the first parameter and a APIPrivilege[] as the second parameter.
 * @callback APIPrivilegesCB
 * @param {Error} e Errors that ocurred. Is null if no errors occured.
 * @param {APIPrivilege[]} result The result. Is null if errors occured.
 */


/**
 * Base class for the {@link HDI} class and the {@link ContainerGroup} class.
 * @extends HDIBase
 */
class ContainerGroupBase extends HDIBase {
  /**
   * @param {Object} credentials an object containing the necessary information to connect to a HANA database
   * @param {string} credentials.host hostname for the connection
   * @param {number} credentials.port port for the connection
   * @param {string} credentials.user username for the connection
   * @param {string} credentials.password password of the user
   * @param {string[]} credentials.ca Certificates to use for the connection. Optional.
   * @param {string} paramSchema a schema that will be used to create temp tables to supply arguments to procedure calls
   * @param {string} apiSchema a schema that will be used for the api calls
   * @param {boolean} usehdb usehdb flag to use hdb or hana-client while connecting to database
   */
  constructor(credentials, paramSchema, apiSchema, usehdb) {
    super(credentials, paramSchema, apiSchema, usehdb);
  }

  /**
   * Creates a container with the given name.
   * Requires EXECUTE privilege on CREATE_CONTAINER
   * @param {string} name the container name
   * @param {Parameter[]} params parameters controlling the current procedure call
   * @param {ResultTupleCB} [cb] - The callback handling the result. If not supplied, a function taking a callback as the first parameter will be returned.
   * @returns {Function | undefined} If no callback was supplied, returns a function taking a callback as the first parameter. Otherwise returns undefined.
   * @async
   */
  createContainer(name, params, cb) {
    /**
     * Function wrapped for async
     * @param {Function} callback Callback Function
     * @returns {undefined}
     */
    const fn = (callback) => {
      try {
        typeCheck(params, 'params', Parameter, cb);
      } catch (error) {
        return callback(error);
      }

      const command = 'CREATE_CONTAINER';
      const sql = `call ${this.apiSchema}.${command}('${name}', ${this.paramSchema}.${CONSTANTS.PARAMETERS_TABLE}, ?, ?, ?)`;
      async.series([
        this.fillHelperTable(CONSTANTS.PARAMETERS_TABLE, params),
        this.executeCall(sql)
      ], series_callback(callback));
    };
    if (cb){
      return fn(cb);
    } else {
      return wrap(fn);
    }
  }

  /**
   * Drops the container with the given name, incl. all corresponding technical users, schemata, tables, etc.
   * Requires EXECUTE privilege on DROP_CONTAINER
   * @param {string} name the container name
   * @param {Parameter[]} params parameters controlling the current procedure call. Supported key-value combinations: IGNORE_WORK: true, false (default), IGNORE_DEPLOYED: true, false (default)
   * @param {ResultTupleCB} [cb] - The callback handling the result. If not supplied, a function taking a callback as the first parameter will be returned.
   * @returns {Function | undefined} If no callback was supplied, returns a function taking a callback as the first parameter. Otherwise returns undefined.
   * @async
   */
  dropContainer(name, params, cb) {
    /**
     * Function wrapped for async
     * @param {Function} callback Callback Function
     * @returns {undefined}
     */
    const fn = (callback) => {
      try {
        typeCheck(params, 'params', Parameter);
      } catch (error) {
        return callback(error);
      }

      const command = 'DROP_CONTAINER';
      const sql = `call ${this.apiSchema}.${command}('${name}', ${this.paramSchema}.${CONSTANTS.PARAMETERS_TABLE}, ?, ?, ?)`;
      async.series([
        this.fillHelperTable(CONSTANTS.PARAMETERS_TABLE, params),
        this.executeCall(sql)
      ], series_callback(callback));
    };
    if (cb){
      return fn(cb);
    } else {
      return wrap(fn);
    }
  }

  /**
   * Configures a container with the given configuration parameters and the given parameters.
   * Requires EXECUTE privilege on CONFIGURE_CONTAINER_PARAMETERS
   * @param {string} container The container name.
   * @param { Parameter[]} configParams parameters to configure the container
   * @param {Parameter[]} params parameters controlling the current procedure call
   * @param {ResultTupleCB} [cb] - The callback handling the result. If not supplied, a function taking a callback as the first parameter will be returned.
   * @returns {Function | undefined} If no callback was supplied, returns a function taking a callback as the first parameter. Otherwise returns undefined.
   * @async
   */
  configureContainerParameters(container, configParams, params, cb) {
    /**
     * Function wrapped for async
     * @param {Function} callback Callback Function
     * @returns {undefined}
     */
    const fn = (callback) => {
      try {
        typeCheck(configParams, 'configParams', Parameter);
        typeCheck(params, 'params', Parameter);
      } catch (error) {
        return callback(error);
      }

      const command = 'CONFIGURE_CONTAINER_PARAMETERS';
      const sql = `call ${this.apiSchema}.${command}('${container}', ${this.paramSchema}.${CONSTANTS.CONFIG_PARAMETERS_TABLE}, ${this.paramSchema}.${CONSTANTS.PARAMETERS_TABLE}, ?, ?, ?)`;
      async.series([
        this.fillHelperTable(CONSTANTS.CONFIG_PARAMETERS_TABLE, configParams),
        this.fillHelperTable(CONSTANTS.PARAMETERS_TABLE, params),
        this.executeCall(sql)
      ], series_callback(callback));
    };
    if (cb){
      return fn(cb);
    } else {
      return wrap(fn);
    }
  }

  /**
   * (Re)configures the set of plugin libraries which are installed in the given container.
   * Requires EXECUTE privilege on CONFIGURE_LIBRARIES
   * @param {string} container the affected container
   * @param {LibraryConfiguration[]} libs Configuration for libraries
   * @param {Parameter[]} params parameters controlling the current procedure call. Supported key-value combinations: UNDEPLOY: true, false (default)
   * @param {ResultTupleCB} [cb] - The callback handling the result. If not supplied, a function taking a callback as the first parameter will be returned.
   * @returns {Function | undefined} If no callback was supplied, returns a function taking a callback as the first parameter. Otherwise returns undefined.
   * @async
   */
  configureLibraries(container, libs, params, cb) {
    /**
     * Function wrapped for async
     * @param {Function} callback Callback Function
     * @returns {undefined}
     */
    const fn = (callback) => {
      try {
        typeCheck(libs, 'libs', LibraryConfiguration);
        typeCheck(params, 'params', Parameter);
      } catch (error) {
        return callback(error);
      }

      const command = 'CONFIGURE_LIBRARIES';
      const sql = `call ${this.apiSchema}.${command}('${container}', ${this.paramSchema}.${CONSTANTS.LIBRARY_CONFIG_TABLE}, ${this.paramSchema}.${CONSTANTS.PARAMETERS_TABLE}, ?, ?, ?)`;
      async.series([
        this.fillHelperTable(CONSTANTS.LIBRARY_CONFIG_TABLE, libs),
        this.fillHelperTable(CONSTANTS.PARAMETERS_TABLE, params),
        this.executeCall(sql)
      ], series_callback(callback));
    };
    if (cb){
      return fn(cb);
    } else {
      return wrap(fn);
    }
  }

  /**
   * List the set of plugin libraries which are installed in the given container.
   * Requires EXECUTE privilege on LIST_CONFIGURED_LIBRARIES
   * @param {string} container the affected container.
   * @param {Parameter[]} params parameters controlling the current procedure call
   * @param {ResultTupleCB} [cb] - The callback handling the result. If not supplied, a function taking a callback as the first parameter will be returned.
   * @returns {Function | undefined} If no callback was supplied, returns a function taking a callback as the first parameter. Otherwise returns undefined.
   * @async
   */
  listConfiguredLibraries(container, params, cb) {
    /**
     * Function wrapped for async
     * @param {Function} callback Callback Function
     * @returns {undefined}
     */
    const fn = (callback) => {
      try {
        typeCheck(params, 'params', Parameter);
      } catch (error) {
        return callback(error);
      }

      const command = 'LIST_CONFIGURED_LIBRARIES';
      const sql = `call ${this.apiSchema}.${command}('${container}', ${this.paramSchema}.${CONSTANTS.PARAMETERS_TABLE}, ?, ?, ?, ?)`;
      const result = new LibraryInformationResultTuple();
      async.series([
        this.fillHelperTable(CONSTANTS.PARAMETERS_TABLE, params),
        this.executeCall(sql, result)
      ], series_callback(callback));
    };
    if (cb){
      return fn(cb);
    } else {
      return wrap(fn);
    }
  }

  /**
   * Tries to cancel the asynchronous request with the given request id.
   * Requires EXECUTE privilege on CANCEL
   * @param {string} container the affected container.
   * @param {number} requestId request id of the request to cancel
   * @param {Parameter[]} params parameters controlling the current procedure call
   * @param {ResultTupleCB} [cb] - The callback handling the result. If not supplied, a function taking a callback as the first parameter will be returned.
   * @returns {Function | undefined} If no callback was supplied, returns a function taking a callback as the first parameter. Otherwise returns undefined.
   * @async
   */
  cancel(container, requestId, params, cb) {
    /**
     * Function wrapped for async
     * @param {Function} callback Callback Function
     * @returns {undefined}
     */
    const fn = (callback) => {
      try {
        typeCheck(params, 'params', Parameter);
      } catch (error) {
        return callback(error);
      }

      const command = 'CANCEL';
      const sql = `call ${this.apiSchema}.${command}('${container}', ${requestId}, ${this.paramSchema}.${CONSTANTS.PARAMETERS_TABLE}, ?, ?, ?)`;
      async.series([
        this.fillHelperTable(CONSTANTS.PARAMETERS_TABLE, params),
        this.executeCall(sql)
      ], series_callback(callback));
    };
    if (cb){
      return fn(cb);
    } else {
      return wrap(fn);
    }
  }

  /**
   * Exports the container with the given container-id, incl. all corresponding schemata, tables, etc.
   * NOTE: The table must be created before calling this function. Furthermore, the [containerName]#DI user must be granted SELECT and INSERT privileges on the specified table.
   * Requires EXECUTE privilege on EXPORT_CONTAINER_FOR_COPY
   * @param {string} container container name for the exported files to be placed in
   * @param {string} tableName table name for the exported files to be placed in
   * @param {string} tableSchema schema of the specified table
   * @param {Parameter[]} params parameters controlling the current procedure call
   * @param {ResultTupleCB} [cb] - The callback handling the result. If not supplied, a function taking a callback as the first parameter will be returned.
   * @returns {Function | undefined} If no callback was supplied, returns a function taking a callback as the first parameter. Otherwise returns undefined.
   * @async
   */

  exportContainerForCopy(container, tableName, tableSchema, params, cb) {
    /**
     * Function wrapped for async
     * @param {Function} callback Callback Function
     * @returns {undefined}
     */
    const fn = (callback) => {
      try {
        typeCheck(params, 'params', Parameter);
      } catch (error) {
        return callback(error);
      }
      const command = 'EXPORT_CONTAINER_FOR_COPY';
      const sql = `call ${this.apiSchema}.${command} ('${container}','${tableSchema}', '${tableName}', ${this.paramSchema}.${CONSTANTS.PARAMETERS_TABLE}, ?, ?, ?);`;
      async.series([
        this.fillHelperTable(CONSTANTS.PARAMETERS_TABLE, params),
        this.executeCall(sql)
      ], series_callback(callback));
    };
    if (cb){
      return fn(cb);
    } else {
      return wrap(fn);
    }
  }

  /**
   * Imports the container with the given container-id, incl. all corresponding schemata, tables, etc.
   * NOTE: The table must be created before calling this function. Furthermore, the [containerName]#DI user must be granted SELECT privileges on the specified table.
   * Requires EXECUTE privilege on IMPORT_CONTAINER_FOR_COPY
   * @param {string} container container name for the exported files to be placed in
   * @param {string} tableName table name for the exported files to be placed in
   * @param {string} tableSchema schema of the specified table
   * @param {Parameter[]} params parameters controlling the current procedure call
   * @param {ResultTupleCB} [cb] - The callback handling the result. If not supplied, a function taking a callback as the first parameter will be returned.  
   * @returns {Function | undefined} If no callback was supplied, returns a function taking a callback as the first parameter. Otherwise returns undefined.
   * @async
   */
  importContainerForCopy(container, tableName, tableSchema, params, cb) {
    /**
     * Function wrapped for async
     * @param {Function} callback Callback Function
     * @returns {undefined}
     */
    const fn = (callback) => {
      try {
        typeCheck(params, 'params', Parameter);
      } catch (error) {
        return callback(error);
      }
      const command = 'IMPORT_CONTAINER_FOR_COPY';
      const sql = `call ${this.apiSchema}.${command} ('${container}','${tableSchema}', '${tableName}', ${this.paramSchema}.${CONSTANTS.PARAMETERS_TABLE}, ?, ?, ?);`;
      async.series([
        this.fillHelperTable(CONSTANTS.PARAMETERS_TABLE, params),
        this.executeCall(sql)
      ], series_callback(callback));
    };
    if (cb){
      return fn(cb);
    } else {
      return wrap(fn);
    }
  }
  /**
   * Grants the given privilege on the container's API objects to the given users.
   * Requires EXECUTE privilege on GRANT_CONTAINER_API_PRIVILEGES
   * @param {string} container the affected container.
   * @param {APIPrivilege[]} privileges list of APIPrivilege describing what and to whom to grant
   * @param {Parameter[]} params parameters controlling the current procedure call
   * @param {ResultTupleCB} [cb] - The callback handling the result. If not supplied, a function taking a callback as the first parameter will be returned.
   * @returns {Function | undefined} If no callback was supplied, returns a function taking a callback as the first parameter. Otherwise returns undefined.
   * @async
   */
  grantContainerApiPrivileges(container, privileges, params, cb) {
    /**
     * Function wrapped for async
     * @param {Function} callback Callback Function
     * @returns {undefined}
     */
    const fn = (callback) => {
      try {
        typeCheck(privileges, 'privileges', APIPrivilege);
        typeCheck(params, 'params', Parameter);
      } catch (error) {
        return callback(error);
      }
      const command = 'GRANT_CONTAINER_API_PRIVILEGES';
      const sql = `call ${this.apiSchema}.${command}('${container}', ${this.paramSchema}.${CONSTANTS.API_PRIVILEGES_TABLE}, ${this.paramSchema}.${CONSTANTS.PARAMETERS_TABLE}, ?, ?, ?)`;
      async.series([
        this.fillHelperTable(CONSTANTS.API_PRIVILEGES_TABLE, privileges),
        this.fillHelperTable(CONSTANTS.PARAMETERS_TABLE, params),
        this.executeCall(sql)
      ], series_callback(callback));
    };
    if (cb){
      return fn(cb);
    } else {
      return wrap(fn);
    }
  }

  /**
   * Grants the given privileges on the container's API objects to the given users with grant option.
   * Requires EXECUTE privilege on GRANT_CONTAINER_API_PRIVILEGES_WITH_GRANT_OPTION
   * @param {string} container the affected container.
   * @param {APIPrivilege[]} privileges list of APIPrivilege describing what and to whom to grant
   * @param {Parameter[]} params parameters controlling the current procedure call
   * @param {ResultTupleCB} [cb] - The callback handling the result. If not supplied, a function taking a callback as the first parameter will be returned.
   * @returns {Function | undefined} If no callback was supplied, returns a function taking a callback as the first parameter. Otherwise returns undefined.
   * @async
   */
  grantContainerApiPrivilegesWithGrantOption(container, privileges, params, cb) {
    /**
     * Function wrapped for async
     * @param {Function} callback Callback Function
     * @returns {undefined}
     */
    const fn = (callback) => {
      try {
        typeCheck(privileges, 'privileges', APIPrivilege);
        typeCheck(params, 'params', Parameter);
      } catch (error) {
        return callback(error);
      }

      const command = 'GRANT_CONTAINER_API_PRIVILEGES_WITH_GRANT_OPTION';
      const sql = `call ${this.apiSchema}.${command}('${container}', ${this.paramSchema}.${CONSTANTS.API_PRIVILEGES_TABLE}, ${this.paramSchema}.${CONSTANTS.PARAMETERS_TABLE}, ?, ?, ?)`;
      async.series([
        this.fillHelperTable(CONSTANTS.API_PRIVILEGES_TABLE, privileges),
        this.fillHelperTable(CONSTANTS.PARAMETERS_TABLE, params),
        this.executeCall(sql)
      ], series_callback(callback));
    };
    if (cb){
      return fn(cb);
    } else {
      return wrap(fn);
    }
  }

  /**
   * Revokes the given privileges on the container's API objects from the given users.
   * Requires EXECUTE privilege on REVOKE_CONTAINER_API_PRIVILEGES
   * @param {string} container the affected container.
   * @param {APIPrivilege[]} privileges list of APIPrivilege
   * @param {Parameter[]} params parameters controlling the current procedure call
   * @param {ResultTupleCB} [cb] - The callback handling the result. If not supplied, a function taking a callback as the first parameter will be returned.
   * @returns {Function | undefined} If no callback was supplied, returns a function taking a callback as the first parameter. Otherwise returns undefined.
   * @async
   */
  revokeContainerApiPrivileges(container, privileges, params, cb) {
    /**
     * Function wrapped for async
     * @param {Function} callback Callback Function
     * @returns {undefined}
     */
    const fn = (callback) => {
      try {
        typeCheck(privileges, 'privileges', APIPrivilege);
        typeCheck(params, 'params', Parameter);
      } catch (error) {
        return callback(error);
      }

      const command = 'REVOKE_CONTAINER_API_PRIVILEGES';
      const sql = `call ${this.apiSchema}.${command}('${container}', ${this.paramSchema}.${CONSTANTS.API_PRIVILEGES_TABLE}, ${this.paramSchema}.${CONSTANTS.PARAMETERS_TABLE}, ?, ?, ?)`;
      async.series([
        this.fillHelperTable(CONSTANTS.API_PRIVILEGES_TABLE, privileges),
        this.fillHelperTable(CONSTANTS.PARAMETERS_TABLE, params),
        this.executeCall(sql)
      ], series_callback(callback));
    };
    if (cb){
      return fn(cb);
    } else {
      return wrap(fn);
    }
  }

  /**
   * Grants the given privileges on the container's target schema to the given users.
   * Requires EXECUTE privilege on GRANT_CONTAINER_SCHEMA_PRIVILEGES
   * @param {string} container the affected container.
   * @param {SchemaPrivilege[]} privileges list of SchemaPrivilege describing what and to whom to grant
   * @param {Parameter[]} params parameters controlling the current procedure call
   * @param {ResultTupleCB} [cb] - The callback handling the result. If not supplied, a function taking a callback as the first parameter will be returned.
   * @returns {Function | undefined} If no callback was supplied, returns a function taking a callback as the first parameter. Otherwise returns undefined.
   * @async
   */
  grantContainerSchemaPrivileges(container, privileges, params, cb) {
    /**
     * Function wrapped for async
     * @param {Function} callback Callback Function
     * @returns {undefined}
     */
    const fn = (callback) => {
      try {
        typeCheck(privileges, 'privileges', SchemaPrivilege);
        typeCheck(params, 'params', Parameter);
      } catch (error) {
        return callback(error);
      }

      const command = 'GRANT_CONTAINER_SCHEMA_PRIVILEGES';
      const sql = `call ${this.apiSchema}.${command}('${container}', ${this.paramSchema}.${CONSTANTS.SCHEMA_PRIVILEGES_TABLE}, ${this.paramSchema}.${CONSTANTS.PARAMETERS_TABLE}, ?, ?, ?)`;
      async.series([
        this.fillHelperTable(CONSTANTS.SCHEMA_PRIVILEGES_TABLE, privileges),
        this.fillHelperTable(CONSTANTS.PARAMETERS_TABLE, params),
        this.executeCall(sql)
      ], series_callback(callback));
    };
    if (cb){
      return fn(cb);
    } else {
      return wrap(fn);
    }
  }

  /**
   * Revokes the given privileges on the container's target schema from the given users.
   * Requires EXECUTE privilege on REVOKE_CONTAINER_SCHEMA_PRIVILEGES
   * @param {string} container the affected container.
   * @param {SchemaPrivilege} privileges list of SchemaPrivilege
   * @param {Parameter[]} params parameters controlling the current procedure call
   * @param {ResultTupleCB} [cb] - The callback handling the result. If not supplied, a function taking a callback as the first parameter will be returned.
   * @returns {Function | undefined} If no callback was supplied, returns a function taking a callback as the first parameter. Otherwise returns undefined.
   * @async
   */
  revokeContainerSchemaPrivileges(container, privileges, params, cb) {
    /**
     * Function wrapped for async
     * @param {Function} callback Callback Function
     * @returns {undefined}
     */
    const fn = (callback) => {
      try {
        typeCheck(privileges, 'privileges', SchemaPrivilege);
        typeCheck(params, 'params', Parameter);
      } catch (error) {
        return callback(error);
      }
      const command = 'REVOKE_CONTAINER_SCHEMA_PRIVILEGES';
      const sql = `call ${this.apiSchema}.${command}('${container}', ${this.paramSchema}.${CONSTANTS.SCHEMA_PRIVILEGES_TABLE}, ${this.paramSchema}.${CONSTANTS.PARAMETERS_TABLE}, ?, ?, ?)`;
      async.series([
        this.fillHelperTable(CONSTANTS.SCHEMA_PRIVILEGES_TABLE, privileges),
        this.fillHelperTable(CONSTANTS.PARAMETERS_TABLE, params),
        this.executeCall(sql)
      ], series_callback(callback));
    };
    if (cb){
      return fn(cb);
    } else {
      return wrap(fn);
    }
  }

  /**
   * Grants the given roles which are deployed inside the container to the given users.
   * Requires EXECUTE privilege on GRANT_CONTAINER_SCHEMA_ROLES
   * @param {string} container the affected container.
   * @param {SchemaRole[]} roles list of SchemaRole
   * @param {Parameter[]} params parameters controlling the current procedure call
   * @param {ResultTupleCB} [cb] - The callback handling the result. If not supplied, a function taking a callback as the first parameter will be returned.
   * @returns {Function | undefined} If no callback was supplied, returns a function taking a callback as the first parameter. Otherwise returns undefined.
   * @async
   */
  grantContainerSchemaRoles(container, roles, params, cb) {
    /**
     * Function wrapped for async
     * @param {Function} callback Callback Function
     * @returns {undefined}
     */
    const fn = (callback) => {
      try {
        typeCheck(roles, 'roles', SchemaRole);
        typeCheck(params, 'params', Parameter);
      } catch (error) {
        return callback(error);
      }
      const command = 'GRANT_CONTAINER_SCHEMA_ROLES';
      const sql = `call ${this.apiSchema}.${command}('${container}', ${this.paramSchema}.${CONSTANTS.SCHEMA_ROLES_TABLE}, ${this.paramSchema}.${CONSTANTS.PARAMETERS_TABLE}, ?, ?, ?)`;
      async.series([
        this.fillHelperTable(CONSTANTS.SCHEMA_ROLES_TABLE, roles),
        this.fillHelperTable(CONSTANTS.PARAMETERS_TABLE, params),
        this.executeCall(sql)
      ], series_callback(callback));
    };
    if (cb){
      return fn(cb);
    } else {
      return wrap(fn);
    }
  }

  /**
   * Revokes the given roles which are deployed inside the container from the given users.
   * Requires EXECUTE privilege on REVOKE_CONTAINER_SCHEMA_ROLES
   * @param {string} container the affected container.
   * @param {SchemaRole[]} roles list of SchemaRole
   * @param {Parameter[]} params parameters controlling the current procedure call
   * @param {ResultTupleCB} [cb] - The callback handling the result. If not supplied, a function taking a callback as the first parameter will be returned.
   * @returns {Function | undefined} If no callback was supplied, returns a function taking a callback as the first parameter. Otherwise returns undefined.
   * @async
   */
  revokeContainerSchemaRoles(container, roles, params, cb) {
    /**
     * Function wrapped for async
     * @param {Function} callback Callback Function
     * @returns {undefined}
     */
    const fn = (callback) => {
      try {
        typeCheck(roles, 'roles', SchemaRole);
        typeCheck(params, 'params', Parameter);
      } catch (error) {
        return callback(error);
      }
      const command = 'REVOKE_CONTAINER_SCHEMA_ROLES';
      const sql = `call ${this.apiSchema}.${command}('${container}', ${this.paramSchema}.${CONSTANTS.SCHEMA_ROLES_TABLE}, ${this.paramSchema}.${CONSTANTS.PARAMETERS_TABLE}, ?, ?, ?)`;
      async.series([
        this.fillHelperTable(CONSTANTS.SCHEMA_ROLES_TABLE, roles),
        this.fillHelperTable(CONSTANTS.PARAMETERS_TABLE, params),
        this.executeCall(sql)
      ], series_callback(callback));
    };
    if (cb){
      return fn(cb);
    } else {
      return wrap(fn);
    }
  }

  /**
   * Grants the given privilege on the container's metadata schemas to the given principal (user or role); for support use cases only.
   * Requires EXECUTE privilege on GRANT_CONTAINER_SUPPORT_PRIVILEGE
   * @param {string} container the affected container.   
   * @param {string} principal name of the target user/role
   * @param {string} privilege the schema privilege to grant
   * @param {Parameter[]} params parameters controlling the current procedure call
   * @param {ResultTupleCB} [cb] - The callback handling the result. If not supplied, a function taking a callback as the first parameter will be returned.
   * @returns {Function | undefined} If no callback was supplied, returns a function taking a callback as the first parameter. Otherwise returns undefined.
   * @async
   */
  grantContainerSupportPrivilege(container, privilege, principal, params, cb) {
    /**
     * Function wrapped for async
     * @param {Function} callback Callback Function
     * @returns {undefined}
     */
    const fn = (callback) => {
      try {
        typeCheck(params, 'params', Parameter);
      } catch (error) {
        return callback(error);
      }
      const command = 'GRANT_CONTAINER_SUPPORT_PRIVILEGE';
      const sql = `call ${this.apiSchema}.${command}('${container}','${privilege}','${principal}', ${this.paramSchema}.${CONSTANTS.PARAMETERS_TABLE}, ?, ?, ?)`;
      async.series([
        this.fillHelperTable(CONSTANTS.PARAMETERS_TABLE, params),
        this.executeCall(sql)
      ], series_callback(callback));
    };
    if (cb){
      return fn(cb);
    } else {
      return wrap(fn);
    }
  }


  /**
   * Revokes the given privilege on the container's metadata schemas to the given principal (user or role); for support use cases only.
   * Requires EXECUTE privilege on REVOKE_CONTAINER_SUPPORT_PRIVILEGE
   * @param {string} container the affected container.   
   * @param {string} principal name of the target user/role
   * @param {string} privilege the schema privilege to grant
   * @param {Parameter[]} params parameters controlling the current procedure call
   * @param {ResultTupleCB} [cb] - The callback handling the result. If not supplied, a function taking a callback as the first parameter will be returned.
   * @returns {Function | undefined} If no callback was supplied, returns a function taking a callback as the first parameter. Otherwise returns undefined.
   * @async
   */
  revokeContainerSupportPrivilege(container, privilege, principal, params, cb) {
    /**
     * Function wrapped for async
     * @param {Function} callback Callback Function
     * @returns {undefined}
     */
    const fn = (callback) => {
      try {
        typeCheck(params, 'params', Parameter);
      } catch (error) {
        return callback(error);
      }
      const command = 'REVOKE_CONTAINER_SUPPORT_PRIVILEGE';
      const sql = `call ${this.apiSchema}.${command}('${container}','${privilege}','${principal}', ${this.paramSchema}.${CONSTANTS.PARAMETERS_TABLE}, ?, ?, ?)`;
      async.series([
        this.fillHelperTable(CONSTANTS.PARAMETERS_TABLE, params),
        this.executeCall(sql)
      ], series_callback(callback));
    };
    if (cb){
      return fn(cb);
    } else {
      return wrap(fn);
    }
  }

  /**
   * Disables the specified container user after it has been enabled by a call to ENABLE_CONTAINER_USER.
   * Requires EXECUTE privilege on DISABLE_CONTAINER_USER   
   * @param {string} containerUser the affected container user.   
   * @param {Parameter[]} params parameters controlling the current procedure call
   * @returns {Function | undefined} If no callback was supplied, returns a function taking a callback as the first parameter. Otherwise returns undefined.
   * @async
   */
  disableContainerUser(containerUser, params, cb) {
     /**
     * Function wrapped for async
     * @param {Function} callback Callback Function
     * @returns {undefined}
     */
      const fn = (callback) => {
        try {
          typeCheck(params, 'params', Parameter);
        } catch (error) {
          return callback(error);
        }
        const command = 'DISABLE_CONTAINER_USER';
        const sql = `call ${this.apiSchema}.${command}('${containerUser}', ${this.paramSchema}.${CONSTANTS.PARAMETERS_TABLE}, ?, ?, ?)`;
        async.series([
          this.fillHelperTable(CONSTANTS.PARAMETERS_TABLE, params),
          this.executeCall(sql,null, this.password)
        ], series_callback(callback));
      };
      if (cb){
        return fn(cb);
      } else {
        return wrap(fn);
      }
    
  }

  /**
   * Enables the specified container user so it can be used for accessing a container for support purposes.
   * Requires EXECUTE privilege on ENABLE_CONTAINER_USER
   * @param {string} containerUser the affected container user.   
   * @param {Parameter[]} params parameters controlling the current procedure call
   * @returns {Function | undefined} If no callback was supplied, returns a function taking a callback as the first parameter. Otherwise returns undefined.
   * @async
   */
  enableContainerUser(containerUser, params, cb) {

     /**
     * Function wrapped for async
     * @param {Function} callback Callback Function
     * @returns {undefined}
     */
      
      const fn = (callback) => {
        try {
          typeCheck(params, 'params', Parameter);
        } catch (error) {
          return callback(error);
        }
        const command = 'ENABLE_CONTAINER_USER';
        const sql = `call ${this.apiSchema}.${command}('${containerUser}', ${this.paramSchema}.${CONSTANTS.PARAMETERS_TABLE}, ?, ?, ?, ?)`;
        async.series([
          this.fillHelperTable(CONSTANTS.PARAMETERS_TABLE, params),
          this.executeCall(sql,null, this.password)
        ], series_callback(callback));
      };
      if (cb){
        return fn(cb);
      } else {
        return wrap(fn);
      }
    
  }
  /**
   * Returns the default privileges required for administration of a container group
   * Requires SELECT privilege on _SYS_DI.T_DEFAULT_CONTAINER_GROUP_ADMIN_PRIVILEGES
   * Minimum required HANA server version: 2.00.010
   * @param {string} principalSchema schema of the target user/role (empty for global principals)
   * @param {string} principalName name of the target user/role
   * @param {APIPrivilegesCB} [cb] - The callback handling the result. If not supplied, a function taking a callback as the first parameter will be returned.
   * @returns {Function | undefined} If no callback was supplied, returns a function taking a callback as the first parameter. Otherwise returns undefined.
   * @async
   */
  getDefaultContainerGroupAdminPrivileges(principalSchema, principalName, cb) {
    /**
     * Function wrapped for async
     * @param {Function} callback Callback Function
     * @returns {undefined}
     */
    const fn = (callback) => {
      const sql = `select PRIVILEGE_NAME, OBJECT_NAME from ${CONSTANTS.GROUP_ADMIN_PRIVILEGES_TABLE}`;
      this.getAPIPrivileges(sql, principalSchema, principalName, callback);
    };

    if (cb){
      fn(cb);
    } else {
      return wrap(fn);
    }
  }
}
module.exports = ContainerGroupBase;
