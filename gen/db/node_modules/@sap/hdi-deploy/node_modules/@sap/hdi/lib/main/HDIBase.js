'use strict';
const CONSTANTS = require('../util/Constants');
const ResultTuple = require('../ResultTuple');
const APIPrivilege = require('../parameter/APIPrivilege');
const LibraryConfiguration = require('../parameter/LibraryConfiguration');
const async = require('async');
const series_callback = require('../util/callback.js');
const wrap = require('../util/wrap.js');
const getConnection = require('../util/connection');
const tls = require('tls');
const quote_sql_identifier = require('../util/schema_escaping');

/**
 * Callback that takes errors as the first parameter and a String as the second parameter.
 * @callback StringCB
 * @param {Error} e Errors that ocurred. Is null if no errors occured.
 * @param {String} result The result. Is null if errors occured.
 */

/**
 * Base class for {@link HDI}, {@link ContainerGroup} and {@link Container} class. {@link HDI} and {@link ContainerGroup} directly inherit from {@link ContainerGroupBase}, which extends HDIBase.
 */
class HDIBase {
  /**
   * @param {Object} credentials an object containing the necessary information to connect to a HANA database
   * @param {string} credentials.host hostname for the connection
   * @param {number} credentials.port port for the connection
   * @param {string} credentials.user username for the connection
   * @param {string} credentials.password password of the user
   * @param {string[]} credentials.ca Certificates to use for the connection. Optional.
   * @param {string} paramSchema a schema that will be used to create temp tables to supply arguments to procedure calls
   * @param {string} apiSchema a schema that will be used for the api calls
   * @param {boolean} usehdb usehdb flag to use hdb or hana-client while connecting to database
   */
  constructor(credentials, paramSchema, apiSchema, usehdb) {
    /**
     * API schema used by this object to make calls to the API.
     *
     * @name HDIBase#apiSchema
     */
    this.apiSchema = quote_sql_identifier(apiSchema);

    /**
     * password that need to bound while using API enable/ disable container User
     * 
     * @name HDIBase#password
     */
    this.password = credentials.password;

    /**
     * tranform xsa variable 'dbhosts' to client understandable variable 'hosts'
     */
    if (Array.isArray(credentials.dbhosts)) {
      credentials.hosts = credentials.dbhosts.map(entry => {
        if (entry.port) {
          entry.port = `${entry.port}`;
        }
  
        return entry;
      });
      delete credentials.dbhosts;
    } else {
      // hana-client@2.7.16 requires this to be a string.
      if (!usehdb) {
        credentials.port = `${credentials.port}`;
      }
    }
    
    /**
     * tranform xsa variable 'certificate' to client understandable variable 'ca'
     */
    if (credentials.certificate) {
      credentials.ca = Array.isArray(credentials.certificate) ? credentials.certificate : [credentials.certificate];
      delete credentials.certificate;
    }

    /**
     * tranform xsa variable 'validate_certificate' to client understandable variable 'sslValidateCertificate'
     */
    if (credentials.validate_certificate !== undefined && credentials.validate_certificate !== null) {
      credentials.sslValidateCertificate = credentials.validate_certificate;
      delete credentials.validate_certificate;
    }

    /**
     * tranform xsa variable 'client_key' to client understandable variable 'key'
     */
    if (credentials.client_key) {
      credentials.key = credentials.client_key;
      delete credentials.client_key;
    }

    /**
     * tranform xsa variable 'hostname_in_certificate' to client understandable variable 'hostname_in_certificate'
     */
    if (credentials.hostname_in_certificate) {
      credentials.sslHostNameInCertificate = credentials.hostname_in_certificate;
      delete credentials.hostname_in_certificate;
    }

    /**
     * tranform xsa variable 'client_cert' to client understandable variable 'cert'
     */
    if (credentials.client_cert) {
      credentials.cert = credentials.client_cert;
      delete credentials.client_cert;
    }

    /**
     * equate useTLS(hdb client) and encrypt(hana-client)
     */
    if(credentials.encrypt) {
      credentials.useTLS = credentials.encrypt;
    }

    /**
     * custom logic to validate the server's hostname against the certificate
     * @param {string} hostname hostname for the connection
     * @param {Object} cert certificate
     * @returns 
     */
    credentials.checkServerIdentity = (hostname, cert) => {
      if(credentials.sslValidateCertificate === false) {
        return undefined;
      }
      const host = credentials.sslHostNameInCertificate ? credentials.sslHostNameInCertificate : hostname;
      return tls.checkServerIdentity(host, cert);

    };

    /**
     * Connection to the HANA database.
     * @name HDIBase#connection
     */
    this.usehdb = usehdb;
    this.connection = getConnection(this.usehdb, credentials);

    /**
     * Connect to the HANA DB with the credentials passed to the constructor.
     * Requires SELECT privilege on _SYS_DI.TT_*
     * @param {StringCB} [cb] - The callback handling the result. If not supplied, a function taking a callback as the first parameter will be returned.
     * @returns {Function | undefined} If no callback was supplied, returns a function taking a callback as the first parameter. Otherwise returns undefined.
     * @async
     */
    this.connect = (cb) => {
      /**
       * Function wrapped for async
       * @param {Function} callback Callback Function
       * @returns {undefined}
       */
      const fn = (callback) => {
        if(this.usehdb) {
          this.connection.connect(((err) => {
            if (err){
              return callback(err);
            }
            return callback(null, 'OK: connected to DB.');
          }));

        } else {
          this.connection.connect(credentials, ((err) => {
            if (err){
              return callback(err);
            }
            return callback(null, 'OK: connected to DB.');
          }));
        }
      };

      if (cb){
        fn(cb);
      } else {
        return wrap(fn);
      }
    };
    /**
     * Set to keep track of the created helper tables.
     *  @name HDIBase#createdHelperTables
     */
    this.createdHelperTables = new Set();
    /**
     * Schema used to create the temp tables.
     * @name HDIBase#paramSchema
     */
    this.paramSchema = quote_sql_identifier(paramSchema);
  }

  /*
   *
   * connect(cb) {
   * this.connection.connect((err) => {
   * if (err) {
   * return cb(err);
   * }
   * cb(null, 'OK: connected to DB.');
   * });
   * }
   */

  /**
   * Disconnect from the HANA DB
   * @returns {String} Success message.
   */
  disconnect() {
    this.createdHelperTables.clear();
    this.connection.end();
    return 'Disconnected.';
  }

  /**
   * This functions fills the table tableName with the values specified in rows.
   * @param {string} tableName Table to insert the rows into.
   * @param {TableRow[]} rows array of objects of type TableRow or a class extending TableRow.
   * @param {Connection} connection Optional, db connection to use instead of the object local one.
   * @param {Set} createdHelperTables Optional, created helper tables to use instead of the local object one.
   * @param {boolean} usehdb usehdb flag to use hdb or hana-client while connecting to database
   * @returns {CallbackFunction} Returns a function taking a callback as a parameter.
   * @async
   */
  fillHelperTable(tableName, rows, connection = this.connection, createdHelperTables = this.createdHelperTables, usehdb = this.usehdb) {
    if (rows === null) {
      rows = [];
    }
    return function(callback){
      const tasks = [];
      if (createdHelperTables.has(tableName)) {
        tasks.push(this.executeDirect(`truncate table ${this.paramSchema}.${tableName}`, connection));
      } else {
        const helperTableType = CONSTANTS.HELPER_TABLE_TYPES.get(tableName);
        tasks.push(this.executeDirect(`create local temporary column table ${this.paramSchema}.${tableName} like ${CONSTANTS.SYS_DI_SCHEMA}.${helperTableType}`, connection));
        tasks.push((cb) => {
          createdHelperTables.add(tableName);
          cb();
        });
      }
      if (rows.length > 0){
        const firstRow = rows[0];
        const sql = `insert into ${this.paramSchema}.${tableName} (${firstRow.getFieldList()}) values (${firstRow.getPlaceholderList()})`;
        tasks.push(this.executeUpdate(sql, rows, connection, usehdb));
      } else {
        tasks.push((cb) => cb());
      }

      async.series(tasks, series_callback(callback));
    }.bind(this);
  }

  /**
   * Executes a sql command.
   * @param {string} sql SQL command to execute.
   * @param {Connection} connection Optional db connection. Default is local object connection.
   * @returns {CallbackFunction} Returns a function taking a callback as a parameter.
   * @async
   */
  executeDirect(sql, connection = this.connection) {
    return function(callback){
      connection.execute(sql, (err) => {
        if (err) {
          err.sql = sql;
          return callback(err);
        }
        return callback(null, `OK: _execute_direct: ${  sql}`);
      });
    };
  }

  /**
   * Runs the specified SQL command with the supplied parameters.
   * @param {string} sql SQL command to run.
   * @param {TableRow[]} params Array of objects of type TableRow or a class extending TableRow.
   * @param {Connection} connection Optional db connection. Default is local object connection.
   * @param {boolean} usehdb usehdb flag to use hdb or hana-client while connecting to database
   * @returns {CallbackFunction} Returns a function taking a callback as a parameter.
   * @async
   */
   executeUpdate(sql, params, connection = this.connection, usehdb = this.usehdb) {
      if(usehdb) {
        return function(callback){
          const tasks = [];
          tasks.push((cb) => connection.prepare(sql, cb));
          tasks.push((statement, cb) => {
            const parameters = [];
            params.forEach((param) => {
              param.flatten().forEach((array) => {
                parameters.push(array);
              });
            });
    
            async.eachLimit(parameters, 1, (param, innerCB) => {
              statement.exec(param, innerCB);
            }, cb);
          });
    
          async.waterfall(tasks, callback);
        };
      } else {
        return function(callback){
          const hana_util = require('@sap/hana-client/extension/Stream.js');
          const tasks = [];
          tasks.push((cb) => hana_util.createStatement(connection, sql, cb));
          tasks.push((statement, cb) => {
            const parameters = [];
            params.forEach((param) => {
              param.flatten().forEach((array) => {
                parameters.push(array);
              });
            });
    
            async.eachLimit(parameters, 1, (param, innerCB) => {
              statement.exec(param, innerCB);
            }, cb);
          });
    
          async.waterfall(tasks, callback);
        };
      }
    }

  /* eslint-disable no-shadow */
  /**
   * Calls a procedure (sql_stmt) with parameters (sql_params) and returns the result (result).
   * @param {string} sqlStmt SQL statement to run.
   * @param {ResultTuple} result An instance of type ResultTuple or a class extending ResultTuple. Contains the result of the procedure call.
   * @package {string} password password that need to be bound while enabling or disabling container user
   * @param {TableRow[]} sqlParams Parameters for the procedure call. Array of objects of type TableRow or a class extending TableRow.
   * @param {Connection} connection Optional db connection. Default is local object connection.
   * @param {boolean} usehdb usehdb flag to use hdb or hana-client while connecting to database
   * @returns {CallbackFunction} Returns a function taking a callback as a parameter.
   * @async
   */
  executeCall(sqlStmt, result = null, password = null, sqlParams = {}, connection = this.connection, usehdb = this.usehdb) {
    /**
     * Prepares an sql statement.
     * @param {Connection} connection Open connection to a HANA database.
     * @param {string} statement SQL statement to prepare.
     * @returns {CallbackFunction} Returns a function taking a callback as a parameter.
     * @private
     */
     function prepare(connection, statement, usehdb) {
        if(usehdb) {
          return function(callback){
            connection.prepare(statement, callback);
          };
        } else{
          return function(callback){
            const hana_util = require('@sap/hana-client/extension/Stream.js');
            hana_util.createProcStatement(connection, statement, callback);
          };
        }
      }

    /**
     * Fill a ResultSet object with the data from a statement call.
     * @param {*} parameters Parameters of the call.
     * @param {*} messages Messages of the call.
     * @param {*} results Results of the call.
     * @param {ResultTuple} result The result to fill.
     * @returns {ResultTuple} The result, filled with  return code, requestID, messages and results.
     * @private
     */
    function fillResult(parameters, messages, password, results, result){
      result.rc = parameters.RETURN_CODE;
      result.requestId = parameters.REQUEST_ID;
      result.messages = messages;
      if (password !== null) {
        result.password = password;
      }
      result.fillResultFromResultSet((typeof results !== 'undefined') ? results : []);
      return result;
    }

    /**
     * Executes a prepared statement.
     * @param {*} parameters Parameters for the sql statement.
     * @param {ResultTuple} result Instance of a ResultTuple or a subclass.
     * @returns {CallbackFunction} Returns a function taking a prepared statement and a callback as parameters.
     * @private
     */
    function execute(parameters, result, password) {
      return function(preparedStatement, callback){
        preparedStatement.exec(parameters, (err, parameters, messages, results) => {
          if (err) {
            err.sqlParams = sqlParams;
            return callback(err);
          } else {
            return callback(null, fillResult(parameters, messages, password, results, result));
          }
        });
      };
    }

    if (result === null) {
      result = new ResultTuple();
    }
    return function(callback){
      async.waterfall([
        prepare(connection, sqlStmt, usehdb),
        execute(sqlParams, result, password)
      ], callback);
    };
  }

 
  /* eslint-enable no-shadow */
  /**
   * Returns the default privileges required for working with a container
   * Requires SELECT privilege on _SYS_DI.T_DEFAULT_CONTAINER_USER_PRIVILEGES
   * Minimum required HANA server version: 2.00.010
   * @param {string} principalSchema schema of the target user/role (empty for global principals)
   * @param {string} principalName name of the target user/role
   * @param {APIPrivilegesCB} [cb] - The callback handling the result. If not supplied, a function taking a callback as the first parameter will be returned.
   * @returns {Function | undefined} If no callback was supplied, returns a function taking a callback as the first parameter. Otherwise returns undefined.
   * @async
   */
  getDefaultContainerUserPrivileges(principalSchema, principalName, cb) {
    const sql = `select PRIVILEGE_NAME, OBJECT_NAME from ${CONSTANTS.CONTAINER_USER_PRIVILEGES_TABLE}`;
    /**
     * Function wrapped for async
     * @param {Function} callback Callback Function
     * @returns {undefined}
     */
    const fn = (callback) => {
      this.getAPIPrivileges(sql, principalSchema, principalName, callback);
    };

    if (cb){
      fn(cb);
    } else {
      return wrap(fn);
    }
  }

  /**
   * Returns the default privileges required for role administration of a container
   * Requires SELECT privilege on _SYS_DI.T_DEFAULT_CONTAINER_ROLE_ADMIN_PRIVILEGES
   * Requires DI.API version greater or equal 15 (OP) or greater or equal 1001 (CE)
   * @param {string} principalSchema schema of the target user/role (empty for global principals)
   * @param {string} principalName name of the target user/role
   * @param {APIPrivilegesCB} [cb] - The callback handling the result. If not supplied, a function taking a callback as the first parameter will be returned.
   * @returns {Function | undefined} If no callback was supplied, returns a function taking a callback as the first parameter. Otherwise returns undefined.
   * @async
   */
  getDefaultContainerRoleAdminPrivileges(principalSchema, principalName, cb) {
    const sql = `select PRIVILEGE_NAME, OBJECT_NAME from ${CONSTANTS.DEFAULT_CONTAINER_ROLE_ADMIN_TABLE}`;
    /**
     * Function wrapped for async
     * @param {Function} callback Callback Function
     * @returns {undefined}
     */
    const fn = (callback) => {
      this.getAPIPrivileges(sql, principalSchema, principalName, callback);
    };

    if (cb){
      fn(cb);
    } else {
      return wrap(fn);
    }
  }

  /**
   * Returns the default common privileges required for working with HDI
   * Requires SELECT privilege on _SYS_DI.T_DEFAULT_COMMON_PRIVILEGES
   * @param {string} principalSchema schema of the target user/role (empty for global principals)
   * @param {string} principalName name of the target user/role
   * @param {APIPrivilegesCB} [cb] - The callback handling the result. If not supplied, a function taking a callback as the first parameter will be returned.
   * @returns {Function | undefined} If no callback was supplied, returns a function taking a callback as the first parameter. Otherwise returns undefined.
   * @async
   */
   getDefaultCommonPrivileges(principalSchema, principalName, cb) {
      const sql = `select PRIVILEGE_NAME, OBJECT_NAME from ${CONSTANTS.DI_DEFAULT_COMMON_PRIVILEGES}`;
      /**
       * Function wrapped for async
       * @param {Function} callback Callback Function
       * @returns {undefined}
       */
       const fn = (callback) => {
         this.getAPIPrivileges(sql, principalSchema, principalName, callback);
        };
        if (cb){
          fn(cb);
        } else {
          return wrap(fn);
        }
      }

  /**
   * Returns the default privileges required for administration of a container
   * Requires SELECT privilege on _SYS_DI.T_DEFAULT_CONTAINER_ADMIN_PRIVILEGES
   * Minimum required HANA server version: 2.00.010
   * @param {string} principalSchema schema of the target user/role (empty for global principals)
   * @param {string} principalName name of the target user/role
   * @param {APIPrivilegesCB} [cb] - The callback handling the result. If not supplied, a function taking a callback as the first parameter will be returned.
   * @returns {Function | undefined} If no callback was supplied, returns a function taking a callback as the first parameter. Otherwise returns undefined.
   * @async
   */
  getDefaultContainerAdminPrivileges(principalSchema, principalName, cb) {
    const sql = `select PRIVILEGE_NAME, OBJECT_NAME from ${CONSTANTS.CONTAINER_ADMIN_PRIVILEGES_TABLE}`;
    /**
     * Function wrapped for async
     * @param {Function} callback Callback Function
     * @returns {undefined}
     */
    const fn = (callback) => {
      this.getAPIPrivileges(sql, principalSchema, principalName, callback);
    };

    if (cb){
      fn(cb);
    } else {
      return wrap(fn);
    }
  }

  /**
   * Callback that takes errors as the first parameter and a MakeGroupResultTuple as the second parameter.
   * @callback LibraryConfigurationsCB
   * @param {Error} e Errors that ocurred. Is null if no errors occured.
   * @param {LibraryConfiguration[]} result The result. Is null if errors occured.
   */
  /**
   * Requires SELECT privilege on _SYS_DI.T_DEFAULT_LIBRARIES
   * @param {LibraryConfigurationsCB} cb List of LibraryConfigurations, which can be passed to configureLibrary calls
   * @returns {Function} Return with callback.
   * @async
   */
  getDefaultLibraries(cb) {
    const sql = `select ACTION, LIBRARY_NAME from ${CONSTANTS.DEFAULT_LIBRARIES_TABLE}`;
    /**
     * Function wrapped for async
     * @param {Function} callback Callback Function
     * @returns {undefined}
     */
    const fn = (callback) => {
      this._execute(sql)((error, rows) => {
        if (error){
          return callback(error);
        } else {
          return callback(null, rows.map((row) => new LibraryConfiguration(row.ACTION, row.LIBRARY_NAME)));
        }
      });
    };
    if (cb){
      fn(cb);
    } else {
      return wrap(fn);
    }
  }

  /**
   * Fetches API privileges for a given user/role.
   * @param {string} sql SQL statement to execute
   * @param {string} principalSchema Schema of the target user/role (empty for global principals)
   * @param {string} principalName name of the target user/role
   * @param {CallbackFunction} callback Callback
   * @returns {Function} Return with callback.
   * @memberof HDIBase
   * @private
   */
  getAPIPrivileges(sql, principalSchema, principalName, callback) {
    this._execute(sql)((error, rows) => {
      if (error){
        return callback(error);
      } else {
        return callback(null, rows.map((row) => new APIPrivilege(row.PRIVILEGE_NAME, row.OBJECT_NAME, principalSchema, principalName)));
      }
    });
  }

  /**
   * Executes an sql statement.
   * @param {string} sql Statement to execute.
   * @returns {CallbackFunction} Returns a function taking a callback as a parameter.
   * @memberof HDIBase
   * @private
   */
  _execute(sql) {
    return function(callback){
      this.connection.exec(sql, (err, rows) => {
        if (err) {
          err.sql = sql;
          return callback(err);
        }
        return callback(null, rows);
      });
    }.bind(this);
  }
}
module.exports = HDIBase;
