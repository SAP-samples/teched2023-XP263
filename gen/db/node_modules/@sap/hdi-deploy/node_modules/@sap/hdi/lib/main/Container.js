'use strict';
const HDIBase = require('./HDIBase');
const CONSTANTS = require('../util/Constants');
const DependencyResultTuple = require('../result/DependencyResultTuple');
const LibraryInformationResultTuple = require('../result/LibraryInformationResultTuple');
const MakeGroupResultTuple = require('../result/MakeGroupResultTuple');
const MetadataResultTuple = require('../result/MetadataResultTuple');
const MetadataContentResultTuple = require('../result/MetadataContentResultTuple');
const StatusResultTuple = require('../result/StatusResultTuple');

const APIPrivilege = require('../parameter/APIPrivilege');
const LibraryConfiguration = require('../parameter/LibraryConfiguration');
const Parameter = require('../parameter/Parameter');
const Path = require('../parameter/Path');
const PathWithContent = require('../parameter/PathWithContent');
const File = require('../parameter/File');
const HDIObject = require('../parameter/HDIObject');
const PathParameter = require('../parameter/PathParameter');
const SchemaPrivilege = require('../parameter/SchemaPrivilege');
const SchemaRole = require('../parameter/SchemaRole');

const typeCheck = require('../util/typeCheck');
const async = require('async');
const series_callback = require('../util/callback.js');
const wrap = require('../util/wrap.js');
const getConnection = require('../util/connection');


/**
 * Wraps the connection to HANA in a Promise.
 *
 * @param {HANA_Client} hc_connection Client
 * @param {Object} credentials Credentials
 * @returns {Promise} Promise
 */
 function connect(connection, credentials, usehdb){
  if(usehdb) {
    return function(callback){
      connection.connect(callback);
    };
  } else {
    return function(callback){
      connection.connect(credentials, callback);
    };
  }
}

/**
 * Callback that takes errors as the first parameter and a MakeGroupResultTuple as the second parameter.
 * @callback MakeGroupResultTupleCB
 * @param {Error} e Errors that ocurred. Is null if no errors occured.
 * @param {MakeGroupResultTuple} result The result. Is null if errors occured.
 */

/**
 * Callback that takes errors as the first parameter and a ResultTuple as the second parameter.
 * @callback ResultTupleCB
 * @param {Error} e Errors that ocurred. Is null if no errors occured.
 * @param {ResultTuple} result The result. Is null if errors occured.
 */

/**
 * Callback that takes errors as the first parameter and a LibraryInformationResultTuple as the second parameter.
 * @callback LibraryInformationResultTupleCB
 * @param {Error} e Errors that ocurred. Is null if no errors occured.
 * @param {LibraryInformationResultTuple} result The result. Is null if errors occured.
 */

/**
 * Callback that takes errors as the first parameter and a StatusResultTuple as the second parameter.
 * @callback StatusResultTupleCB
 * @param {Error} e Errors that ocurred. Is null if no errors occured.
 * @param {StatusResultTuple} result The result. Is null if errors occured.
 */

/**
 * Callback that takes errors as the first parameter and a MetadataContentResultTuple as the second parameter.
 * @callback MetadataContentResultTupleCB
 * @param {Error} e Errors that ocurred. Is null if no errors occured.
 * @param {MetadataContentResultTuple} result The result. Is null if errors occured.
 */

/**
 * Callback that takes errors as the first parameter and a MetadataResultTuple as the second parameter.
 * @callback MetadataResultTupleCB
 * @param {Error} e Errors that ocurred. Is null if no errors occured.
 * @param {MetadataResultTuple} result The result. Is null if errors occured.
 */

/**
 * Callback that takes errors as the first parameter and a DependencyResultTuple as the second parameter.
 * @callback DependencyResultTupleCB
 * @param {Error} e Errors that ocurred. Is null if no errors occured.
 * @param {DependencyResultTuple} result The result. Is null if errors occured.
 */


/**
 * Provides access to the API of a given HDI container
 * Minimum required HANA server version: 1.00.120
 * @extends HDIBase
 */
class Container extends HDIBase {
  /**
   * Constructs an access object for a given container and opens a connection to the database
   * Requires SELECT privilege on _SYS_DI.TT_*
   * @constructor
   * @param {string} containerName the name of the container
   * @param {Object} credentials an object containing the necessary information to connect to a HANA database
   * @param {string} credentials.host hostname for the connection
   * @param {number} credentials.port port for the connection
   * @param {string} credentials.user username for the connection
   * @param {string} credentials.password password of the user
   * @param {string[]} credentials.ca Certificates to use for the connection. Optional.
   * @param {string} paramSchema a schema that will be used to create temp tables to supply arguments to procedure calls
   * @param {boolean} usehdb usehdb flag to use hdb or hana-client while connecting to database
   */
   constructor(containerName, credentials, paramSchema, usehdb) {
    const apiSchema = `${containerName}#DI`;
    super(credentials, paramSchema, apiSchema, usehdb);
    this.usehdb = usehdb;
    this.lock_connection = getConnection(this.usehdb, credentials);

    /**
     * Acquires a lock on the container's lock table.
     * NOTE: Acquiring the lock is not strictly required for a client, so other clients might ignore it.
     * Requires EXECUTE privilege on LOCK
     * Minimum required HANA server version: 2.00.010
     * @param {number} timeout lock wait timeout in milliseconds
     * @param {Parameter[]} params parameters controlling the current procedure call
     * @param {ResultTupleCB} [cb] - The callback handling the result. If not supplied, a function taking a callback as the first parameter will be returned.
     * @returns {Function | undefined} If no callback was supplied, returns a function taking a callback as the first parameter. Otherwise returns undefined.
     * @async
     */
    this.lock = (timeout, params, cb) => {
      /**
       * Function wrapped for async
       * @param {Function} callback Callback Function
       * @returns {undefined}
       */
      const fn = (callback) => {
        try {
          typeCheck(params, 'params', Parameter);
        } catch (error) {
          return callback(error);
        }
        const command = 'LOCK';
        const sql = `call ${this.apiSchema}.${command}(${timeout}, ${this.paramSchema}.${CONSTANTS.PARAMETERS_TABLE}, ?, ?, ?)`;

        this.lock_connection.setAutoCommit(false);

        async.series([
          connect(this.lock_connection, credentials, this.usehdb),
          this.fillHelperTable(CONSTANTS.PARAMETERS_TABLE, params, this.lock_connection, new Set(), this.usehdb),
          this.executeCall(sql, null, null, {}, this.lock_connection, this.usehdb)
        ], (e, r) => {
          if (e){
            this.unlock(() => {});
          }
          series_callback(callback)(e, r);
        });
      };
      if (cb){
        return fn(cb);
      } else {
        return wrap(fn);
      }
    };
  }

  exportContainerForCopy(tableName, tableSchema, params, cb) {
    /**
     * Function wrapped for async
     * @param {Function} callback Callback Function
     * @returns {undefined}
     */
    const fn = (callback) => {
      try {
        typeCheck(params, 'params', Parameter);
      } catch (error) {
        return callback(error);
      }
      const command = 'EXPORT_CONTAINER_FOR_COPY';
      const sql = `call ${this.apiSchema}.${command} ('${tableSchema}', '${tableName}', ${this.paramSchema}.${CONSTANTS.PARAMETERS_TABLE}, ?, ?, ?);`;
      async.series([
        this.fillHelperTable(CONSTANTS.PARAMETERS_TABLE, params),
        this.executeCall(sql)
      ], series_callback(callback));
    };
    if (cb){
      return fn(cb);
    } else {
      return wrap(fn);
    }
  }

  importContainerForCopy(tableName, tableSchema, params, cb) {
    /**
     * Function wrapped for async
     * @param {Function} callback Callback Function
     * @returns {undefined}
     */
    const fn = (callback) => {
      try {
        typeCheck(params, 'params', Parameter);
      } catch (error) {
        return callback(error);
      }
      const command = 'IMPORT_CONTAINER_FOR_COPY';
      const sql = `call ${this.apiSchema}.${command} ('${tableSchema}', '${tableName}', ${this.paramSchema}.${CONSTANTS.PARAMETERS_TABLE}, ?, ?, ?);`;
      async.series([
        this.fillHelperTable(CONSTANTS.PARAMETERS_TABLE, params),
        this.executeCall(sql)
      ], series_callback(callback));
    };
    if (cb){
      return fn(cb);
    } else {
      return wrap(fn);
    }
  }

  /**
   * Configures a container with the given configuration parameters and the given parameters.
   * Requires EXECUTE privilege on CONFIGURE_CONTAINER_PARAMETERS
   * @param {Parameter[]} configParams parameters to configure the container
   * @param {Parameter[]} params parameters controlling the current procedure call
   * @param {ResultTupleCB} [cb] - The callback handling the result. If not supplied, a function taking a callback as the first parameter will be returned.
   * @returns {Function | undefined} If no callback was supplied, returns a function taking a callback as the first parameter. Otherwise returns undefined.
   * @async
   */
  configureContainerParameters(configParams, params, cb) {
    /**
     * Function wrapped for async
     * @param {Function} callback Callback Function
     * @returns {undefined}
     */
    const fn = (callback) => {
      try {
        typeCheck(configParams, 'configParams', Parameter);
        typeCheck(params, 'params', Parameter);
      } catch (error) {
        return callback(error);
      }

      const command = 'CONFIGURE_CONTAINER_PARAMETERS';
      const sql = `call ${this.apiSchema}.${command}(${this.paramSchema}.${CONSTANTS.CONFIG_PARAMETERS_TABLE}, ${this.paramSchema}.${CONSTANTS.PARAMETERS_TABLE}, ?, ?, ?)`;
      async.series([
        this.fillHelperTable(CONSTANTS.CONFIG_PARAMETERS_TABLE, configParams),
        this.fillHelperTable(CONSTANTS.PARAMETERS_TABLE, params),
        this.executeCall(sql)
      ], series_callback(callback));
    };
    if (cb){
      return fn(cb);
    } else {
      return wrap(fn);
    }
  }

  /**
   * (Re)configures the set of plugin libraries which are installed in the given container.
   * Requires EXECUTE privilege on CONFIGURE_LIBRARIES
   * @param {LibraryConfiguration[]} libs configuration for the libraries
   * @param {Parameter[]} params parameters controlling the current procedure call
   *               - UNDEPLOY: true, false (default)
   * @param {ResultTupleCB} [cb] - The callback handling the result. If not supplied, a function taking a callback as the first parameter will be returned.
   * @returns {Function | undefined} If no callback was supplied, returns a function taking a callback as the first parameter. Otherwise returns undefined.
   * @async
   */
  configureLibraries(libs, params, cb) {
    /**
     * Function wrapped for async
     * @param {Function} callback Callback Function
     * @returns {undefined}
     */
    const fn = (callback) => {
      try {
        typeCheck(libs, 'libs', LibraryConfiguration);
        typeCheck(params, 'params', Parameter);
      } catch (error) {
        return callback(error);
      }
      const command = 'CONFIGURE_LIBRARIES';
      const sql = `call ${this.apiSchema}.${command}(${this.paramSchema}.${CONSTANTS.LIBRARY_CONFIG_TABLE}, ${this.paramSchema}.${CONSTANTS.PARAMETERS_TABLE}, ?, ?, ?)`;
      async.series([
        this.fillHelperTable(CONSTANTS.LIBRARY_CONFIG_TABLE, libs),
        this.fillHelperTable(CONSTANTS.PARAMETERS_TABLE, params),
        this.executeCall(sql)
      ], series_callback(callback));
    };
    if (cb){
      return fn(cb);
    } else {
      return wrap(fn);
    }
  }

  /**
   * List the set of plugin libraries which are installed in the given container.
   * Requires EXECUTE privilege on LIST_CONFIGURED_LIBRARIES
   * @param {Parameter[]} params parameters controlling the current procedure call
   * @param {LibraryInformationResultTupleCB} [cb] - The callback handling the result. If not supplied, a function taking a callback as the first parameter will be returned.
   * @returns {Function | undefined} If no callback was supplied, returns a function taking a callback as the first parameter. Otherwise returns undefined.
   * @async
   */
  listConfiguredLibraries(params, cb) {
    /**
     * Function wrapped for async
     * @param {Function} callback Callback Function
     * @returns {undefined}
     */
    const fn = (callback) => {
      try {
        typeCheck(params, 'params', Parameter);
      } catch (error) {
        return callback(error);
      }
      const command = 'LIST_CONFIGURED_LIBRARIES';
      const sql = `call ${this.apiSchema}.${command}(${this.paramSchema}.${CONSTANTS.PARAMETERS_TABLE}, ?, ?, ?, ?)`;
      const result = new LibraryInformationResultTuple();
      async.series([
        this.fillHelperTable(CONSTANTS.PARAMETERS_TABLE, params),
        this.executeCall(sql, result)
      ], series_callback(callback));
    };
    if (cb){
      return fn(cb);
    } else {
      return wrap(fn);
    }
  }

  /**
   * Shows the status of the given files/folders in the container's file systems.
   * Requires EXECUTE privilege on STATUS
   * @param {Path[]} filesFolders list of files/folders to check for their status
   * @param {Parameter[]} params parameters controlling the current procedure call
   * @param {StatusResultTupleCB} [cb] - The callback handling the result. If not supplied, a function taking a callback as the first parameter will be returned.
   * @returns {Function | undefined} If no callback was supplied, returns a function taking a callback as the first parameter. Otherwise returns undefined.
   * @async
   */
  status(filesFolders, params, cb) {
    /**
     * Function wrapped for async
     * @param {Function} callback Callback Function
     * @returns {undefined}
     */
    const fn = (callback) => {
      try {
        typeCheck(filesFolders, 'filesFolders', Path);
        typeCheck(params, 'params', Parameter);
      } catch (error) {
        return callback(error);
      }
      const command = 'STATUS';
      const sql = `call ${this.apiSchema}.${command}(${this.paramSchema}.${CONSTANTS.PATHS_TABLE}, ${this.paramSchema}.${CONSTANTS.PARAMETERS_TABLE}, ?, ?, ?, ?)`;
      const result = new StatusResultTuple();
      async.series([
        this.fillHelperTable(CONSTANTS.PATHS_TABLE, filesFolders),
        this.fillHelperTable(CONSTANTS.PARAMETERS_TABLE, params),
        this.executeCall(sql, result)
      ], series_callback(callback));
    };
    if (cb){
      return fn(cb);
    } else {
      return wrap(fn);
    }
  }

  /**
   * Reads the given files/folders from the container's work file system.
   * Requires EXECUTE privilege on READ
   * @param {Path[]} filesFolders list of file/folders to read
   * @param {Parameter[]} params parameters controlling the current procedure call.
   *                  -RECURSIVE: true, false (default)
   *                  -IGNORE_FILES: true, false (default)
   *                  -IGNORE_FOLDERS: true, false (default)
   * @param {MetadataContentResultTupleCB} [cb] - The callback handling the result. If not supplied, a function taking a callback as the first parameter will be returned.
   * @returns {Function | undefined} If no callback was supplied, returns a function taking a callback as the first parameter. Otherwise returns undefined.
   * @async
   */
  read(filesFolders, params, cb) {
    /**
     * Function wrapped for async
     * @param {Function} callback Callback Function
     * @returns {undefined}
     */
    const fn = (callback) => {
      try {
        typeCheck(filesFolders, 'filesFolders', Path);
        typeCheck(params, 'params', Parameter);
      } catch (error) {
        return callback(error);
      }
      const command = 'READ';
      const sql = `call ${this.apiSchema}.${command}(${this.paramSchema}.${CONSTANTS.PATHS_TABLE}, ${this.paramSchema}.${CONSTANTS.PARAMETERS_TABLE}, ?, ?, ?, ?)`;
      const result = new MetadataContentResultTuple();
      async.series([
        this.fillHelperTable(CONSTANTS.PATHS_TABLE, filesFolders),
        this.fillHelperTable(CONSTANTS.PARAMETERS_TABLE, params),
        this.executeCall(sql, result)
      ], series_callback(callback));
    };
    if (cb){
      return fn(cb);
    } else {
      return wrap(fn);
    }
  }

  /**
   * Reads the given files/folders from the container's deployed file system.
   * Requires EXECUTE privilege on READ_DEPLOYED
   * @param {Path[]} filesFolders list of file/folders to read
   * @param {Parameter[]} params parameters controlling the current procedure call
   *               - RECURSIVE: true, false (default)
   *               - IGNORE_FILES: true, false (default)
   *               - IGNORE_FOLDERS: true, false (default)
   * @param {MetadataContentResultTupleCB} [cb] - The callback handling the result. If not supplied, a function taking a callback as the first parameter will be returned.
   * @returns {Function | undefined} If no callback was supplied, returns a function taking a callback as the first parameter. Otherwise returns undefined.
   * @async
   */
  readDeployed(filesFolders, params, cb) {
    /**
     * Function wrapped for async
     * @param {Function} callback Callback Function
     * @returns {undefined}
     */
    const fn = (callback) => {
      try {
        typeCheck(filesFolders, 'filesFolders', Path);
        typeCheck(params, 'params', Parameter);
      } catch (error) {
        return callback(error);
      }
      const command = 'READ_DEPLOYED';
      const sql = `call ${this.apiSchema}.${command}(${this.paramSchema}.${CONSTANTS.PATHS_TABLE}, ${this.paramSchema}.${CONSTANTS.PARAMETERS_TABLE}, ?, ?, ?, ?)`;
      const result = new MetadataContentResultTuple();
      async.series([
        this.fillHelperTable(CONSTANTS.PATHS_TABLE, filesFolders),
        this.fillHelperTable(CONSTANTS.PARAMETERS_TABLE, params),
        this.executeCall(sql, result)
      ], series_callback(callback));
    };
    if (cb){
      return fn(cb);
    } else {
      return wrap(fn);
    }
  }

  /**
   * Reads the metadata for the given files/folders from the container's work file system.
   * Requires EXECUTE privilege on LIST
   * @param {Path[]} filesFolders list of file/folders to read
   * @param {Parameter[]} params parameters controlling the current procedure call
   *               - RECURSIVE: true, false (default)
   *               - IGNORE_FILES: true, false (default)
   *               - IGNORE_FOLDERS: true, false (default)
   * @param {MetadataResultTupleCB} [cb] - The callback handling the result. If not supplied, a function taking a callback as the first parameter will be returned.
   * @returns {Function | undefined} If no callback was supplied, returns a function taking a callback as the first parameter. Otherwise returns undefined.
   * @async
   */
  list(filesFolders, params, cb) {
    /**
     * Function wrapped for async
     * @param {Function} callback Callback Function
     * @returns {undefined}
     */
    const fn = (callback) => {
      try {
        typeCheck(filesFolders, 'filesFolders', Path);
        typeCheck(params, 'params', Parameter);
      } catch (error) {
        return callback(error);
      }
      const command = 'LIST';
      const sql = `call ${this.apiSchema}.${command}(${this.paramSchema}.${CONSTANTS.PATHS_TABLE}, ${this.paramSchema}.${CONSTANTS.PARAMETERS_TABLE}, ?, ?, ?, ?)`;
      const result = new MetadataResultTuple();
      async.series([
        this.fillHelperTable(CONSTANTS.PATHS_TABLE, filesFolders),
        this.fillHelperTable(CONSTANTS.PARAMETERS_TABLE, params),
        this.executeCall(sql, result)
      ], series_callback(callback));
    };
    if (cb){
      return fn(cb);
    } else {
      return wrap(fn);
    }
  }

  /**
   * Reads the metadata for the given files/folders from the container's deployed file system.
   * Requires EXECUTE privilege on LIST_DEPLOYED
   * @param {Path[]} filesFolders list of file/folders to read
   * @param {Parameter[]} params parameters controlling the current procedure call
   *               - RECURSIVE: true, false (default)
   *               - IGNORE_FILES: true, false (default)
   *               - IGNORE_FOLDERS: true, false (default)
   * @param {MetadataResultTupleCB} [cb] - The callback handling the result. If not supplied, a function taking a callback as the first parameter will be returned.
   * @returns {Function | undefined} If no callback was supplied, returns a function taking a callback as the first parameter. Otherwise returns undefined.
   * @async
   */
  listDeployed(filesFolders, params, cb) {
    /**
     * Function wrapped for async
     * @param {Function} callback Callback Function
     * @returns {undefined}
     */
    const fn = (callback) => {
      try {
        typeCheck(filesFolders, 'filesFolders', Path);
        typeCheck(params, 'params', Parameter);
      } catch (error) {
        return callback(error);
      }
      const command = 'LIST_DEPLOYED';
      const sql = `call ${this.apiSchema}.${command}(${this.paramSchema}.${CONSTANTS.PATHS_TABLE}, ${this.paramSchema}.${CONSTANTS.PARAMETERS_TABLE}, ?, ?, ?, ?)`;
      const result = new MetadataResultTuple();
      async.series([
        this.fillHelperTable(CONSTANTS.PATHS_TABLE, filesFolders),
        this.fillHelperTable(CONSTANTS.PARAMETERS_TABLE, params),
        this.executeCall(sql, result)
      ], series_callback(callback));
    };
    if (cb){
      return fn(cb);
    } else {
      return wrap(fn);
    }
  }

  /**
   * Writes/creates the given files/folders to/in the container's work file system.
   * Requires EXECUTE privilege on WRITE
   * @param {PathWithContent[]} filesFolders list of file/folders to write, including content (NULL for folders)
   * @param {Parameter[]} params parameters controlling the current procedure call
   * @param {ResultTupleCB} [cb] - The callback handling the result. If not supplied, a function taking a callback as the first parameter will be returned.
   * @returns {Function | undefined} If no callback was supplied, returns a function taking a callback as the first parameter. Otherwise returns undefined.
   * @async
   */
  write(filesFolders, params, cb) {
    /**
     * Function wrapped for async
     * @param {Function} callback Callback Function
     * @returns {undefined}
     */
    const fn = (callback) => {
      try {
        typeCheck(filesFolders, 'filesFolders', PathWithContent);
        typeCheck(params, 'params', Parameter);
      } catch (error) {
        return callback(error);
      }
      const command = 'WRITE';
      const sql = `call ${this.apiSchema}.${command}(${this.paramSchema}.${CONSTANTS.PATHS_CONTENT_TABLE}, ${this.paramSchema}.${CONSTANTS.PARAMETERS_TABLE}, ?, ?, ?)`;
      async.series([
        this.fillHelperTable(CONSTANTS.PATHS_CONTENT_TABLE, filesFolders),
        this.fillHelperTable(CONSTANTS.PARAMETERS_TABLE, params),
        this.executeCall(sql)
      ], series_callback(callback));
    };
    if (cb){
      return fn(cb);
    } else {
      return wrap(fn);
    }
  }

  /**
   * Deletes the given files/folders from/in the container's work file system.
   * Requires EXECUTE privilege on DELETE
   * @param {Path[]} filesFolders list of files/folders to delete
   * @param {Parameter[]} params parameters controlling the current procedure call
   *               - RECURSIVE: true, false (default)
   * @param {ResultTupleCB} [cb] - The callback handling the result. If not supplied, a function taking a callback as the first parameter will be returned.´
   * @returns {Function | undefined} If no callback was supplied, returns a function taking a callback as the first parameter. Otherwise returns undefined.
   * @async
   */
  delete(filesFolders, params, cb) {
    /**
     * Function wrapped for async
     * @param {Function} callback Callback Function
     * @returns {undefined}
     */
    const fn = (callback) => {
      try {
        typeCheck(filesFolders, 'filesFolders', Path);
        typeCheck(params, 'params', Parameter);
      } catch (error) {
        return callback(error);
      }
      const command = 'DELETE';
      const sql = `call ${this.apiSchema}.${command}(${this.paramSchema}.${CONSTANTS.PATHS_TABLE}, ${this.paramSchema}.${CONSTANTS.PARAMETERS_TABLE}, ?, ?, ?)`;
      async.series([
        this.fillHelperTable(CONSTANTS.PATHS_TABLE, filesFolders),
        this.fillHelperTable(CONSTANTS.PARAMETERS_TABLE, params),
        this.executeCall(sql)
      ], series_callback(callback));
    };
    if (cb){
      return fn(cb);
    } else {
      return wrap(fn);
    }
  }

  /**
   * Triggers a make with the given set of files.
   * Requires EXECUTE privilege on MAKE
   * @param {File[]} deployFiles list of files to deploy
   * @param {File[]} undeployFiles list of files to undeploy
   * @param {PathParameter[]} pathParameters parameters controlling the current procedure call, specific for each single file
   * @param {Parameter[]} params parameters controlling the current procedure call
   * @param {ResultTupleCB} [cb] - The callback handling the result. If not supplied, a function taking a callback as the first parameter will be returned.
   * @returns {Function | undefined} If no callback was supplied, returns a function taking a callback as the first parameter. Otherwise returns undefined.
   * @async
   */
  make(deployFiles, undeployFiles, pathParameters, params, cb) {
    /**
     * Function wrapped for async
     * @param {Function} callback Callback Function
     * @returns {undefined}
     */
    const fn = (callback) => {
      try {
        typeCheck(deployFiles, 'deployFiles', File);
        typeCheck(undeployFiles, 'undeployFiles', File);
        typeCheck(pathParameters, 'pathParameters', PathParameter);
        typeCheck(params, 'params', Parameter);
      } catch (error) {
        return callback(error);
      }

      const command = 'MAKE';
      const sql = `call ${this.apiSchema}.${command}(${this.paramSchema}.${CONSTANTS.DEPLOY_PATHS_TABLE}, ${this.paramSchema}.${CONSTANTS.UNDEPLOY_PATHS_TABLE}, ${this.paramSchema}.${CONSTANTS.PATH_PARAMETERS_TABLE}, ${this.paramSchema}.${CONSTANTS.PARAMETERS_TABLE}, ?, ?, ?)`;
      async.series([
        this.fillHelperTable(CONSTANTS.DEPLOY_PATHS_TABLE, deployFiles),
        this.fillHelperTable(CONSTANTS.UNDEPLOY_PATHS_TABLE, undeployFiles),
        this.fillHelperTable(CONSTANTS.PATH_PARAMETERS_TABLE, pathParameters),
        this.fillHelperTable(CONSTANTS.PARAMETERS_TABLE, params),
        this.executeCall(sql)
      ], series_callback(callback));
    };
    if (cb){
      return fn(cb);
    } else {
      return wrap(fn);
    }
  }

  /**
   * Triggers a make with the given set of files in asynchronous mode.
   * The call returns with a REQUEST_ID while the make continuous to run in the background.
   * The status of the make can be checked via M_JOBS and M_MESSAGES.
   * Requires EXECUTE privilege on MAKE_ASYNC
   * @param {File[]} deployFiles list of files to deploy
   * @param {File[]} undeployFiles list of files to undeploy
   * @param {PathParameter[]} pathParameters file-level parameters
   * @param {Parameter[]} params parameters controlling the current procedure call
   * @param {ResultTupleCB} [cb] - The callback handling the result. If not supplied, a function taking a callback as the first parameter will be returned.
   * @returns {Function | undefined} If no callback was supplied, returns a function taking a callback as the first parameter. Otherwise returns undefined.
   * @async
   */
  makeAsync(deployFiles, undeployFiles, pathParameters, params, cb) {
    /**
     * Function wrapped for async
     * @param {Function} callback Callback Function
     * @returns {undefined}
     */
    const fn = (callback) => {
      try {
        typeCheck(deployFiles, 'deployFiles', File);
        typeCheck(undeployFiles, 'undeployFiles', File);
        typeCheck(pathParameters, 'pathParameters', PathParameter);
        typeCheck(params, 'params', Parameter);
      } catch (error) {
        return callback(error);
      }
      const command = 'MAKE_ASYNC';
      const sql = `call ${this.apiSchema}.${command}(${this.paramSchema}.${CONSTANTS.DEPLOY_PATHS_TABLE}, ${this.paramSchema}.${CONSTANTS.UNDEPLOY_PATHS_TABLE}, ${this.paramSchema}.${CONSTANTS.PATH_PARAMETERS_TABLE}, ${this.paramSchema}.${CONSTANTS.PARAMETERS_TABLE}, ?, ?, ?)`;
      async.series([
        this.fillHelperTable(CONSTANTS.DEPLOY_PATHS_TABLE, deployFiles),
        this.fillHelperTable(CONSTANTS.UNDEPLOY_PATHS_TABLE, undeployFiles),
        this.fillHelperTable(CONSTANTS.PATH_PARAMETERS_TABLE, pathParameters),
        this.fillHelperTable(CONSTANTS.PARAMETERS_TABLE, params),
        this.executeCall(sql)
      ], series_callback(callback));
    };
    if (cb){
      return fn(cb);
    } else {
      return wrap(fn);
    }
  }

  /**
   * Tries to cancel the asynchronous request with the given request id.
   * Requires EXECUTE privilege on CANCEL
   * @param {number} requestId request id of the request to cancel
   * @param {Parameter[]} params parameters controlling the current procedure call
   * @param {ResultTupleCB} [cb] - The callback handling the result. If not supplied, a function taking a callback as the first parameter will be returned.
   * @returns {Function | undefined} If no callback was supplied, returns a function taking a callback as the first parameter. Otherwise returns undefined.
   * @async
   */
  cancel(requestId, params, cb) {
    /**
     * Function wrapped for async
     * @param {Function} callback Callback Function
     * @returns {undefined}
     */
    const fn = (callback) => {
      try {
        typeCheck(params, 'params', Parameter);
      } catch (error) {
        return callback(error);
      }
      const command = 'CANCEL';
      const sql = `call ${this.apiSchema}.${command}(${requestId}, ${this.paramSchema}.${CONSTANTS.PARAMETERS_TABLE}, ?, ?, ?)`;
      async.series([
        this.fillHelperTable(CONSTANTS.PARAMETERS_TABLE, params),
        this.executeCall(sql)
      ], series_callback(callback));
    };
    if (cb){
      return fn(cb);
    } else {
      return wrap(fn);
    }
  }

  /**
   * Calculates groups of objects which can be passed to a make call independently.
   * Requires EXECUTE privilege on MAKE
   * Minimum required HANA server version: 2.00.000
   * @param {File[]} deployFiles list of files to deploy
   * @param {File[]} undeployFiles list of files to undeploy
   * @param {PathParameter[]} pathParameters parameters controlling the current procedure call, specific for each single file
   * @param {Parameter[]} params parameters controlling the current procedure call
   * @param {MakeGroupResultTupleCB} [cb] - The callback handling the result. If not supplied, a function taking a callback as the first parameter will be returned.
   * @returns {Function | undefined} If no callback was supplied, returns a function taking a callback as the first parameter. Otherwise returns undefined.
   * @async
   */
  getMakeGroups(deployFiles, undeployFiles, pathParameters, params, cb) {
    /**
     * Function wrapped for async
     * @param {Function} callback Callback Function
     * @returns {undefined}
     */
    const fn = (callback) => {
      try {
        typeCheck(deployFiles, 'deployFiles', File);
        typeCheck(undeployFiles, 'undeployFiles', File);
        typeCheck(pathParameters, 'pathParameters', PathParameter);
        typeCheck(params, 'params', Parameter);
      } catch (error) {
        return callback(error);
      }
      const command = 'GET_MAKE_GROUPS';
      const sql = `call ${this.apiSchema}.${command}(${this.paramSchema}.${CONSTANTS.DEPLOY_PATHS_TABLE}, ${this.paramSchema}.${CONSTANTS.UNDEPLOY_PATHS_TABLE}, ${this.paramSchema}.${CONSTANTS.PATH_PARAMETERS_TABLE}, ${this.paramSchema}.${CONSTANTS.PARAMETERS_TABLE}, ?, ?, ?, ?)`;
      const result = new MakeGroupResultTuple();
      async.series([
        this.fillHelperTable(CONSTANTS.DEPLOY_PATHS_TABLE, deployFiles),
        this.fillHelperTable(CONSTANTS.UNDEPLOY_PATHS_TABLE, undeployFiles),
        this.fillHelperTable(CONSTANTS.PATH_PARAMETERS_TABLE, pathParameters),
        this.fillHelperTable(CONSTANTS.PARAMETERS_TABLE, params),
        this.executeCall(sql, result)
      ], series_callback(callback));
    };
    if (cb){
      return fn(cb);
    } else {
      return wrap(fn);
    }
  }

  /**
   * Retrieves dependency data.
   * The kind of data retrieved depends on the optional parameter "variant" (passed via PARAMETERS).
   * Requires EXECUTE privilege on GET_DEPENDENCIES
   * Minimum required HANA server version: 2.00.000
   * @param {HDIObject[]} objects list of objects for which dependency data should be retrieved
   * @param {Parameter[]} params parameters controlling the current procedure call
   * @param {DependencyTupleCB} [cb] - The callback handling the result. If not supplied, a function taking a callback as the first parameter will be returned.
   * @returns {Function | undefined} If no callback was supplied, returns a function taking a callback as the first parameter. Otherwise returns undefined.
   * @async
   */
  getDependencies(objects, params, cb) {
    /**
     * Function wrapped for async
     * @param {Function} callback Callback Function
     * @returns {undefined}
     */
    const fn = (callback) => {
      try {
        typeCheck(objects, 'objects', HDIObject);
        typeCheck(params, 'params', Parameter);
      } catch (error) {
        return callback(error);
      }
      const command = 'GET_DEPENDENCIES';
      const sql = `call ${this.apiSchema}.${command}(${this.paramSchema}.${CONSTANTS.OBJECTS_TABLE}, ${this.paramSchema}.${CONSTANTS.PARAMETERS_TABLE}, ?, ?, ?, ?)`;
      const result = new DependencyResultTuple();
      async.series([
        this.fillHelperTable(CONSTANTS.OBJECTS_TABLE, objects),
        this.fillHelperTable(CONSTANTS.PARAMETERS_TABLE, params),
        this.executeCall(sql, result)
      ], series_callback(callback));
    };
    if (cb){
      return fn(cb);
    } else {
      return wrap(fn);
    }
  }



  /**
   * Close the lock_connection to unlock.
   *
   * @param {any} cb Callback called after disconnect.
   * @returns {Function} callback
   *
   * @memberOf Container
   */
  unlock(cb){
    /**
     * Function wrapped for async
     * @param {Function} callback Callback Function
     * @returns {undefined}
     */
    const fn = (callback) => {
      this.lock_connection.close();
      return callback();
    };

    if (cb){
      fn(cb);
    } else {
      return fn;
    }
  }

  /**
   * Grants the given privileges on the container's API objects to the given users.
   * Requires EXECUTE privilege on GRANT_CONTAINER_API_PRIVILEGES
   * @param {APIPrivilege[]} privileges list of APIPrivilege describing what and to whom to grant
   * @param {Parameter[]} params parameters controlling the current procedure call
   * @param {ResultTupleCB} [cb] - The callback handling the result. If not supplied, a function taking a callback as the first parameter will be returned.
   * @returns {Function | undefined} If no callback was supplied, returns a function taking a callback as the first parameter. Otherwise returns undefined.
   * @async
   */
  grantContainerApiPrivileges(privileges, params, cb) {
    /**
     * Function wrapped for async
     * @param {Function} callback Callback Function
     * @returns {undefined}
     */
    const fn = (callback) => {
      try {
        typeCheck(privileges, 'privileges', APIPrivilege);
        typeCheck(params, 'params', Parameter);
      } catch (error) {
        return callback(error);
      }
      const command = 'GRANT_CONTAINER_API_PRIVILEGES';
      const sql = `call ${this.apiSchema}.${command}(${this.paramSchema}.${CONSTANTS.API_PRIVILEGES_TABLE}, ${this.paramSchema}.${CONSTANTS.PARAMETERS_TABLE}, ?, ?, ?)`;
      async.series([
        this.fillHelperTable(CONSTANTS.API_PRIVILEGES_TABLE, privileges),
        this.fillHelperTable(CONSTANTS.PARAMETERS_TABLE, params),
        this.executeCall(sql)
      ], series_callback(callback));
    };
    if (cb){
      return fn(cb);
    } else {
      return wrap(fn);
    }
  }

  /**
   * Grants the given privileges on the container's API objects to the given users with grant option.
   * Requires EXECUTE privilege on GRANT_CONTAINER_API_PRIVILEGES_WITH_GRANT_OPTION
   * @param {APIPrivilege[]} privileges list of APIPrivilege describing what and to whom to grant
   * @param {Parameter[]} params parameters controlling the current procedure call
   * @param {ResultTupleCB} [cb] - The callback handling the result. If not supplied, a function taking a callback as the first parameter will be returned.
   * @returns {Function | undefined} If no callback was supplied, returns a function taking a callback as the first parameter. Otherwise returns undefined.
   * @async
   */
  grantContainerApiPrivilegesWithGrantOption(privileges, params, cb) {
    /**
     * Function wrapped for async
     * @param {Function} callback Callback Function
     * @returns {undefined}
     */
    const fn = (callback) => {
      try {
        typeCheck(privileges, 'privileges', APIPrivilege);
        typeCheck(params, 'params', Parameter);
      } catch (error) {
        return callback(error);
      }
      const command = 'GRANT_CONTAINER_API_PRIVILEGES_WITH_GRANT_OPTION';
      const sql = `call ${this.apiSchema}.${command}(${this.paramSchema}.${CONSTANTS.API_PRIVILEGES_TABLE}, ${this.paramSchema}.${CONSTANTS.PARAMETERS_TABLE}, ?, ?, ?)`;
      async.series([
        this.fillHelperTable(CONSTANTS.API_PRIVILEGES_TABLE, privileges),
        this.fillHelperTable(CONSTANTS.PARAMETERS_TABLE, params),
        this.executeCall(sql)
      ], series_callback(callback));
    };
    if (cb){
      return fn(cb);
    } else {
      return wrap(fn);
    }
  }

  /**
   * Revokes the given privileges on the container's API objects from the given users.
   * Requires EXECUTE privilege on REVOKE_CONTAINER_API_PRIVILEGES
   * @param {APIPrivilege[]} privileges list of APIPrivilege
   * @param {Parameter[]} params parameters controlling the current procedure call
   * @param {ResultTupleCB} [cb] - The callback handling the result. If not supplied, a function taking a callback as the first parameter will be returned.
   * @returns {Function | undefined} If no callback was supplied, returns a function taking a callback as the first parameter. Otherwise returns undefined.
   * @async
   */
  revokeContainerApiPrivileges(privileges, params, cb) {
    /**
     * Function wrapped for async
     * @param {Function} callback Callback Function
     * @returns {undefined}
     */
    const fn = (callback) => {
      try {
        typeCheck(privileges, 'privileges', APIPrivilege);
        typeCheck(params, 'params', Parameter);
      } catch (error) {
        return callback(error);
      }
      const command = 'REVOKE_CONTAINER_API_PRIVILEGES';
      const sql = `call ${this.apiSchema}.${command}(${this.paramSchema}.${CONSTANTS.API_PRIVILEGES_TABLE}, ${this.paramSchema}.${CONSTANTS.PARAMETERS_TABLE}, ?, ?, ?)`;
      async.series([
        this.fillHelperTable(CONSTANTS.API_PRIVILEGES_TABLE, privileges),
        this.fillHelperTable(CONSTANTS.PARAMETERS_TABLE, params),
        this.executeCall(sql)
      ], series_callback(callback));
    };
    if (cb){
      return fn(cb);
    } else {
      return wrap(fn);
    }
  }

  /**
   * Grants the given privileges on the container's target schema to the given users.
   * Requires EXECUTE privilege on GRANT_CONTAINER_SCHEMA_PRIVILEGES
   * @param {SchemaPrivilege[]} privileges list of SchemaPrivilege describing what and to whom to grant
   * @param {Parameter[]} params parameters controlling the current procedure call
   * @param {ResultTupleCB} [cb] - The callback handling the result. If not supplied, a function taking a callback as the first parameter will be returned.
   * @returns {Function | undefined} If no callback was supplied, returns a function taking a callback as the first parameter. Otherwise returns undefined.
   * @async
   */
  grantContainerSchemaPrivileges(privileges, params, cb) {
    /**
     * Function wrapped for async
     * @param {Function} callback Callback Function
     * @returns {undefined}
     */
    const fn = (callback) => {
      try {
        typeCheck(privileges, 'privileges', SchemaPrivilege);
        typeCheck(params, 'params', Parameter);
      } catch (error) {
        return callback(error);
      }
      const command = 'GRANT_CONTAINER_SCHEMA_PRIVILEGES';
      const sql = `call ${this.apiSchema}.${command}(${this.paramSchema}.${CONSTANTS.SCHEMA_PRIVILEGES_TABLE}, ${this.paramSchema}.${CONSTANTS.PARAMETERS_TABLE}, ?, ?, ?)`;
      async.series([
        this.fillHelperTable(CONSTANTS.SCHEMA_PRIVILEGES_TABLE, privileges),
        this.fillHelperTable(CONSTANTS.PARAMETERS_TABLE, params),
        this.executeCall(sql)
      ], series_callback(callback));
    };
    if (cb){
      return fn(cb);
    } else {
      return wrap(fn);
    }
  }

  /**
   * Revokes the given privileges on the container's target schema from the given users.
   * Requires EXECUTE privilege on REVOKE_CONTAINER_SCHEMA_PRIVILEGES
   * @param {SchemaPrivilege[]} privileges list of SchemaPrivilege
   * @param {Parameter[]} params parameters controlling the current procedure call
   * @param {ResultTupleCB} [cb] - The callback handling the result. If not supplied, a function taking a callback as the first parameter will be returned.
   * @returns {Function | undefined} If no callback was supplied, returns a function taking a callback as the first parameter. Otherwise returns undefined.
   * @async
   */
  revokeContainerSchemaPrivileges(privileges, params, cb) {
    /**
     * Function wrapped for async
     * @param {Function} callback Callback Function
     * @returns {undefined}
     */
    const fn = (callback) => {
      try {
        typeCheck(privileges, 'privileges', SchemaPrivilege);
        typeCheck(params, 'params', Parameter);
      } catch (error) {
        return callback(error);
      }
      const command = 'REVOKE_CONTAINER_SCHEMA_PRIVILEGES';
      const sql = `call ${this.apiSchema}.${command}(${this.paramSchema}.${CONSTANTS.SCHEMA_PRIVILEGES_TABLE}, ${this.paramSchema}.${CONSTANTS.PARAMETERS_TABLE}, ?, ?, ?)`;
      async.series([
        this.fillHelperTable(CONSTANTS.SCHEMA_PRIVILEGES_TABLE, privileges),
        this.fillHelperTable(CONSTANTS.PARAMETERS_TABLE, params),
        this.executeCall(sql)
      ], series_callback(callback));
    };
    if (cb){
      return fn(cb);
    } else {
      return wrap(fn);
    }
  }

  /**
   * Grants the given roles which are deployed inside the container to the given users.
   * Requires EXECUTE privilege on GRANT_CONTAINER_SCHEMA_ROLES
   * @param {SchemaRole[]} roles list of SchemaRole
   * @param {Parameter[]} params parameters controlling the current procedure call
   * @param {ResultTupleCB} [cb] - The callback handling the result. If not supplied, a function taking a callback as the first parameter will be returned.
   * @returns {Function | undefined} If no callback was supplied, returns a function taking a callback as the first parameter. Otherwise returns undefined.
   * @async
   */
  grantContainerSchemaRoles(roles, params, cb) {
    /**
     * Function wrapped for async
     * @param {Function} callback Callback Function
     * @returns {undefined}
     */
    const fn = (callback) => {
      try {
        typeCheck(roles, 'roles', SchemaRole);
        typeCheck(params, 'params', Parameter);
      } catch (error) {
        return callback(error);
      }
      const command = 'GRANT_CONTAINER_SCHEMA_ROLES';
      const sql = `call ${this.apiSchema}.${command}(${this.paramSchema}.${CONSTANTS.SCHEMA_ROLES_TABLE}, ${this.paramSchema}.${CONSTANTS.PARAMETERS_TABLE}, ?, ?, ?)`;
      async.series([
        this.fillHelperTable(CONSTANTS.SCHEMA_ROLES_TABLE, roles),
        this.fillHelperTable(CONSTANTS.PARAMETERS_TABLE, params),
        this.executeCall(sql)
      ], series_callback(callback));
    };
    if (cb){
      return fn(cb);
    } else {
      return wrap(fn);
    }
  }

  /**
   * Revokes the given roles which are deployed inside the container from the given users.
   * Requires EXECUTE privilege on REVOKE_CONTAINER_SCHEMA_ROLES
   * @param {SchemaRole[]} roles list of SchemaRole
   * @param {Parameter[]} params parameters controlling the current procedure call
   * @param {ResultTupleCB} [cb] - The callback handling the result. If not supplied, a function taking a callback as the first parameter will be returned.
   * @returns {Function | undefined} If no callback was supplied, returns a function taking a callback as the first parameter. Otherwise returns undefined.
   * @async
   */
  revokeContainerSchemaRoles(roles, params, cb) {
    /**
     * Function wrapped for async
     * @param {Function} callback Callback Function
     * @returns {undefined}
     */
    const fn = (callback) => {
      try {
        typeCheck(roles, 'roles', SchemaRole);
        typeCheck(params, 'params', Parameter);
      } catch (error) {
        return callback(error);
      }
      const command = 'REVOKE_CONTAINER_SCHEMA_ROLES';
      const sql = `call ${this.apiSchema}.${command}(${this.paramSchema}.${CONSTANTS.SCHEMA_ROLES_TABLE}, ${this.paramSchema}.${CONSTANTS.PARAMETERS_TABLE}, ?, ?, ?)`;
      async.series([
        this.fillHelperTable(CONSTANTS.SCHEMA_ROLES_TABLE, roles),
        this.fillHelperTable(CONSTANTS.PARAMETERS_TABLE, params),
        this.executeCall(sql)
      ], series_callback(callback));
    };
    if (cb){
      return fn(cb);
    } else {
      return wrap(fn);
    }
  }
}
module.exports = Container;