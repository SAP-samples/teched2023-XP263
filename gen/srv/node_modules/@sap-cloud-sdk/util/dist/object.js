"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.mergeIgnoreCase = exports.mergeLeftIgnoreCase = exports.pickNonNullish = exports.pickValueIgnoreCase = exports.pickIgnoreCase = exports.toSanitizedObject = exports.assoc = exports.exclude = exports.pick = exports.renameKeys = exports.propertyExists = void 0;
const nullish_1 = require("./nullish");
/**
 * Checks if a chain of properties exists on the given object.
 * @param obj - The object to be checked.
 * @param properties - Chained properties.
 * @returns `true` if the property chain leads to a truthy value, `false` otherwise.
 */
function propertyExists(obj, ...properties) {
    if (!properties.length) {
        return true;
    }
    if (obj && obj.hasOwnProperty(properties[0])) {
        return propertyExists(obj[properties[0]], ...properties.slice(1));
    }
    return false;
}
exports.propertyExists = propertyExists;
/**
 * Takes an object and returns a new object whose keys are renamed according to the provided key mapping.
 * Any keys in the input object not present in the key mapping will be present in the output object as-is.
 * If a key in the key mapping is not present in the input object, the output object will contain the key with value "undefined".
 * @param keyMapping - An object mapping keys of the input object to keys of the output object.
 * @param obj - The input object.
 * @returns An object with renamed keys.
 */
const renameKeys = (keyMapping, obj) => {
    const unchangedEntries = Object.keys(obj)
        .filter(k => !Object.keys(keyMapping).includes(k))
        .reduce((newObj, key) => ({ ...newObj, [key]: obj[key] }), {});
    return Object.entries(keyMapping).reduce((newObj, [oldKey, newKey]) => ({ ...newObj, [newKey]: obj[oldKey] }), unchangedEntries);
};
exports.renameKeys = renameKeys;
/**
 * Create a shallow copy of the given object, that contains the given keys.
 * Non existing keys in the source object are ignored.
 * @param keys - Properties to be selected.
 * @param obj - Object from which the values are taken.
 * @returns An object with the selected keys and corresponding values.
 */
const pick = (keys, obj) => {
    const result = {};
    keys.forEach(key => {
        const value = obj[key];
        if (Object.keys(obj).includes(key)) {
            result[key] = value;
        }
    });
    return result;
};
exports.pick = pick;
/**
 * Create a shallow copy of the given object, that does not contain the given keys.
 * Non existing keys in the source object are ignored.
 * @param keys - Properties to be selected.
 * @param obj - Object from which the values are taken.
 * @returns An object with the selected keys and corresponding values.
 */
const exclude = (keys, obj) => {
    const result = {};
    Object.keys(obj).forEach(key => {
        const value = obj[key];
        if (!keys.includes(key)) {
            result[key] = value;
        }
    });
    return result;
};
exports.exclude = exclude;
/**
 * Adds a key value pair to the given objects and returns a shallow copy.
 * If the key is already present it will be overwritten.
 * @param key - Key to be added.
 * @param value - Value to be added.
 * @param obj - Object the key value pair is added to.
 * @returns The object with the key value pair added.
 */
const assoc = (key, value, obj) => ({
    ...obj,
    [key]: value
});
exports.assoc = assoc;
/**
 * Create an object based on the given key and value if neither key nor value are nullish.
 * @param key - Name of the header.
 * @param value - Value of the header.
 * @returns - An object containing the given key and value of an empty object.
 */
function toSanitizedObject(key, value) {
    return (0, nullish_1.isNullish)(key) || (0, nullish_1.isNullish)(value) ? {} : { [key]: value };
}
exports.toSanitizedObject = toSanitizedObject;
/**
 * Create a shallow copy of the given object, that contains the given keys, independent of casing.
 * Non existing keys in the source object are ignored.
 * @param obj - Object to pick the given key from.
 * @param keys - Keys of the pair to be picked.
 * @returns - An object containing the given key-value pairs in its original case or an empty object if none of them are found.
 */
function pickIgnoreCase(obj = {}, ...keys) {
    return keys.reduce((filteredHeaders, providedKey) => {
        const originalKey = Object.keys(obj).find(objKey => objKey.toLowerCase() === providedKey.toLowerCase());
        return {
            ...filteredHeaders,
            ...(originalKey && { [originalKey]: obj[originalKey] })
        };
    }, {});
}
exports.pickIgnoreCase = pickIgnoreCase;
/**
 * Returns the value of an object based on the given key, independent of casing.
 * @param obj - Object to be searched for the given key.
 * @param key - Key of the value to pick.
 * @returns The value of for the given key or `undefined`, if not available.
 */
function pickValueIgnoreCase(obj = {}, key) {
    return Object.values(pickIgnoreCase(obj, key))[0];
}
exports.pickValueIgnoreCase = pickValueIgnoreCase;
/**
 * Create a shallow copy of the given object, that contains all entries with non-nullish values.
 * @param obj - An object to pick from.
 * @returns - A filtered object containing only keys with non-nullish values.
 */
function pickNonNullish(obj = {}) {
    return Object.entries(obj)
        .filter(([key, value]) => !(0, nullish_1.isNullish)(key) && !(0, nullish_1.isNullish)(value))
        .reduce((filtered, [key, value]) => ({ ...filtered, [key]: value }), {});
}
exports.pickNonNullish = pickNonNullish;
/**
 * Create an object by merging the `right` object into a shallow copy of the `left` object ignoring casing, but keeping the `right` casing. Only keys present in the `left` object will be present in the merged object.
 * @param left - Object to merge into. They keys of this object will be present in the returned object.
 * @param right - Object to merge. Only keys in `left` will be considered for merging.
 * @returns - An object containing all keys from the `left` object, where entries present in the `right` object are replaced. Note that the casing used by `right` will be used.
 */
function mergeLeftIgnoreCase(left = {}, right = {}) {
    return Object.entries(left)
        .map(([key, value]) => pickValueIgnoreCase(right, key)
        ? pickIgnoreCase(right, key)
        : { [key]: value })
        .reduce((replaced, obj) => ({ ...replaced, ...obj }), {});
}
exports.mergeLeftIgnoreCase = mergeLeftIgnoreCase;
/**
 * Create an object by merging the `right` object into a shallow copy of the `left` object ignoring casing, but keeping the right casing. Keys present both objects will be present in the merged object.
 * @param left - Object to merge.
 * @param right - Object to merge. The casing of the keys of this object takes precedence.
 * @returns - An object containing all keys from both objects, where entries present in the `right` object are replaced. Note that the casing used by `right` will be used.
 */
function mergeIgnoreCase(left = {}, right = {}) {
    return {
        ...mergeLeftIgnoreCase(left, right),
        ...right
    };
}
exports.mergeIgnoreCase = mergeIgnoreCase;
//# sourceMappingURL=object.js.map