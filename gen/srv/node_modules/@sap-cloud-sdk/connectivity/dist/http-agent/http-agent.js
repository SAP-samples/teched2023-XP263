"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.urlAndAgent = exports.getAgentConfig = exports.getAgentConfigAsync = void 0;
const promises_1 = require("fs/promises");
const http_1 = __importDefault(require("http"));
const https_1 = __importDefault(require("https"));
const util_1 = require("@sap-cloud-sdk/util");
const scp_cf_1 = require("../scp-cf");
/* Careful the proxy imports cause circular dependencies if imported from scp directly */
const destination_1 = require("../scp-cf/destination");
const register_destination_cache_1 = require("../scp-cf/destination/register-destination-cache");
const logger = (0, util_1.createLogger)({
    package: 'connectivity',
    messageContext: 'http-agent'
});
/**
 * Will be renamed to getAgentConfig in the next major release.
 * Returns a promise of the http or https-agent config depending on the destination URL.
 * If the destination contains a proxy configuration, the agent will be a proxy-agent.
 * If not it will be the default http-agent coming from node.
 * @param destination - Determining which kind of configuration is returned.
 * @returns A promise of the HTTP or HTTPS agent configuration.
 */
async function getAgentConfigAsync(destination) {
    const certificateOptions = {
        ...getTrustStoreOptions(destination),
        ...getKeyStoreOptions(destination),
        ...(await getMtlsOptions(destination))
    };
    return destination.proxyConfiguration
        ? (0, destination_1.proxyAgent)(destination, certificateOptions)
        : createDefaultAgent(destination, certificateOptions);
}
exports.getAgentConfigAsync = getAgentConfigAsync;
/**
 * Returns the http or https-agent config depending on the destination URL.
 * If the destination contains a proxy configuration, the agent will be a proxy-agent.
 * If not it will be the default http-agent coming from node.
 * @deprecated Temporarily replaced by {@link getAgentConfigAsync}, will change its default behavior to be asynchronous in next major release.
 * @param destination - Determining which kind of configuration is returned.
 * @returns The HTTP or HTTPS agent configuration.
 */
function getAgentConfig(destination) {
    const certificateOptions = {
        ...getTrustStoreOptions(destination),
        ...getKeyStoreOptions(destination)
    };
    return destination.proxyConfiguration
        ? (0, destination_1.proxyAgent)(destination, certificateOptions)
        : createDefaultAgent(destination, certificateOptions);
}
exports.getAgentConfig = getAgentConfig;
/**
 * @internal
 * The http agents (proxy and default) use node tls for trust handling. This method creates the options with the 'ca' or 'rejectUnauthorized' option.
 * https://nodejs.org/api/tls.html#tls_tls_createsecurecontext_options
 * @param destination - Destination object
 * @returns Options, which can be used later the http client.
 */
function getTrustStoreOptions(destination) {
    // http case: no certificate needed
    if ((0, scp_cf_1.getProtocolOrDefault)(destination) === 'http') {
        if (destination.isTrustingAllCertificates) {
            logger.warn('"isTrustingAllCertificates" is not available for HTTP.');
        }
        if (destination.trustStoreCertificate) {
            logger.warn('"trustStore" is not available for HTTP.');
        }
        return {};
    }
    // https case
    if (destination.isTrustingAllCertificates &&
        destination.trustStoreCertificate) {
        logger.warn(`Destination ${destination.name} contains the 'trustAll' and 'trustStoreLocation' property which is a redundant setup.`);
    }
    if (destination.isTrustingAllCertificates) {
        logger.warn('"isTrustingAllCertificates" property in the provided destination is set to "true". This is highly discouraged in production.');
        return { rejectUnauthorized: !destination.isTrustingAllCertificates };
    }
    if (destination.trustStoreCertificate) {
        const decoded = Buffer.from(destination.trustStoreCertificate.content, 'base64').toString('utf8');
        return {
            rejectUnauthorized: true,
            ca: [decoded]
        };
    }
    return { rejectUnauthorized: true };
}
/**
 * @internal
 * The http agents (proxy and default) use node tls for the certificate handling. This method creates the options with the pfx and passphrase.
 * https://nodejs.org/api/tls.html#tls_tls_createsecurecontext_options
 * @param destination - Destination object
 * @returns Options, which can be used later by tls.createSecureContext() e.g. pfx and passphrase or an empty object, if the protocol is not 'https:' or no client information are in the definition.
 */
function getKeyStoreOptions(destination) {
    if (destination.keyStoreName &&
        destination.keyStorePassword &&
        // Only add certificates, when using MTLS (https://github.com/SAP/cloud-sdk-js/issues/3544)
        destination.authentication === 'ClientCertificateAuthentication' &&
        // pfx is an alternative to providing key and cert individually
        // For mTLS we provide key and cert, in non-mTLS cases we provide pfx
        !mtlsIsEnabled(destination)) {
        const certificate = selectCertificate(destination);
        logger.debug(`Certificate with name "${certificate.name}" selected.`);
        return {
            pfx: Buffer.from(certificate.content, 'base64'),
            passphrase: destination.keyStorePassword
        };
    }
    return {};
}
/*
 Reads mTLS client certificates from known environment variables on CloudFoundry.
 */
async function getMtlsOptions(destination) {
    if (!mtlsIsEnabled(destination) && destination.mtls) {
        logger.warn(`Destination ${destination.name ? destination.name : ''} has mTLS enabled, but the required Cloud Foundry environment variables (CF_INSTANCE_CERT and CF_INSTANCE_KEY) are not defined. Note that 'inferMtls' only works on Cloud Foundry.`);
    }
    if (mtlsIsEnabled(destination)) {
        if (register_destination_cache_1.registerDestinationCache.mtls.useMtlsCache) {
            return register_destination_cache_1.registerDestinationCache.mtls.getMtlsOptions();
        }
        const getCert = (0, promises_1.readFile)(process.env.CF_INSTANCE_CERT, 'utf8');
        const getKey = (0, promises_1.readFile)(process.env.CF_INSTANCE_KEY, 'utf8');
        const [cert, key] = await Promise.all([getCert, getKey]);
        return {
            cert,
            key
        };
    }
    return {};
}
function mtlsIsEnabled(destination) {
    return (destination.mtls &&
        process.env.CF_INSTANCE_CERT &&
        process.env.CF_INSTANCE_KEY);
}
/*
 The node client supports only these store formats https://nodejs.org/api/tls.html#tlscreatesecurecontextoptions.
 */
const supportedCertificateFormats = ['p12', 'pfx'];
function hasSupportedFormat(certificate) {
    const certificateFormat = (0, util_1.last)(certificate.name.split('.'));
    if (certificateFormat) {
        return supportedCertificateFormats.includes(certificateFormat);
    }
    return false;
}
function selectCertificate(destination) {
    const certificate = destination.certificates.find(c => c.name === destination.keyStoreName);
    if (!certificate) {
        throw Error(`No certificate with name ${destination.keyStoreName} could be found on the destination!`);
    }
    if (!hasSupportedFormat(certificate)) {
        const format = (0, util_1.last)(certificate.name.split('.'));
        throw Error(`The format of the provided certificate '${certificate.name}' is not supported. Supported formats are: ${supportedCertificateFormats.join(', ')}. ${format && ['jks', 'keystore'].includes(format)
            ? "You can convert Java Keystores (.jks, .keystore) into PKCS#12 keystores using the JVM's keytool CLI: keytool -importkeystore -srckeystore your-keystore.jks -destkeystore your-keystore.p12 -deststoretype pkcs12"
            : ''}`);
    }
    return certificate;
}
/**
 * @internal
 * See https://nodejs.org/api/https.html#https_https_createserver_options_requestlistener for details on the possible options
 */
function createDefaultAgent(destination, options) {
    if ((0, scp_cf_1.getProtocolOrDefault)(destination) === 'https') {
        return { httpsAgent: new https_1.default.Agent(options) };
    }
    return { httpAgent: new http_1.default.Agent(options) };
}
/**
 * Builds part of the request config containing the URL and if needed proxy agents or normal http agents.
 * Considers the `no_proxy` environment variable together with the `targetUri`.
 * @internal
 * @param targetUri - Used as baseURL in request config.
 * @returns HttpRequestConfig containing baseUrl and http(s) agents.
 */
async function urlAndAgent(targetUri) {
    let destination = { url: targetUri, proxyType: 'Internet' };
    if ((0, destination_1.proxyStrategy)(destination) === 'internet') {
        destination = (0, destination_1.addProxyConfigurationInternet)(destination);
    }
    return {
        baseURL: destination.url,
        ...(await getAgentConfigAsync(destination))
    };
}
exports.urlAndAgent = urlAndAgent;
//# sourceMappingURL=http-agent.js.map