"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.setDestinationsInEnv = exports.validateNameAvailable = exports.searchEnvVariablesForDestination = exports.getDestinationsEnvVariable = exports.getDestinationFromEnvByName = exports.getDestinationsFromEnv = void 0;
const util_1 = require("@sap-cloud-sdk/util");
const destination_1 = require("./destination");
const http_proxy_util_1 = require("./http-proxy-util");
const destination_service_types_1 = require("./destination-service-types");
const logger = (0, util_1.createLogger)({
    package: 'connectivity',
    messageContext: 'env-destination-accessor'
});
/**
 * Get all destinations from the environment variable "destinations".
 * This is discouraged for productive use! Use {@link useOrFetchDestination} for fetching destinations from the Cloud Foundry destination service.
 *
 * @returns A list of destinations
 * @internal
 */
function getDestinationsFromEnv() {
    const destinationsEnv = getDestinationsEnvVariable();
    logger.debug(`The value for the destination environment variable is: ${destinationsEnv}`);
    if (destinationsEnv) {
        let destinations;
        try {
            destinations = JSON.parse(destinationsEnv);
        }
        catch (err) {
            throw new util_1.ErrorWithCause('Error in parsing the destinations from the environment variable.', err);
        }
        validateDestinations(destinations);
        return destinations.map(destination => (0, destination_1.isDestinationConfiguration)(destination)
            ? (0, destination_1.parseDestination)(destination)
            : (0, destination_1.sanitizeDestination)(destination));
    }
    return [];
}
exports.getDestinationsFromEnv = getDestinationsFromEnv;
/**
 * Get a destination from the environment variables by name. If there are multiple destinations with the same name the first one will be used.
 * This is discouraged for productive use! Use destination-accessor/useOrFetchDestination for fetching destinations
 * from the Cloud Foundry destination service.
 * @param name - Name of the destination
 * @returns The requested destination if existent, otherwise `null`
 * @internal
 */
function getDestinationFromEnvByName(name) {
    const matchingDestinations = getDestinationsFromEnv().filter(dest => dest.name === name);
    if (!matchingDestinations.length) {
        return null;
    }
    if (matchingDestinations.length > 1) {
        logger.warn(`The 'destinations' env variable contains multiple destinations with the name '${name}'. Only the first entry will be considered.`);
    }
    const destination = matchingDestinations[0];
    return (0, destination_service_types_1.isHttpDestination)(destination) &&
        ['internet', 'private-link'].includes((0, http_proxy_util_1.proxyStrategy)(destination))
        ? (0, http_proxy_util_1.addProxyConfigurationInternet)(destination)
        : destination;
}
exports.getDestinationFromEnvByName = getDestinationFromEnvByName;
/**
 * @internal
 */
function getDestinationsEnvVariable() {
    return process.env['destinations'];
}
exports.getDestinationsEnvVariable = getDestinationsEnvVariable;
function validateDestinations(destinations) {
    destinations.forEach(destination => {
        if (typeof destination.name === 'undefined' &&
            typeof destination.Name === 'undefined') {
            logger.warn("Destination from 'destinations' env variable is missing 'name' or 'Name' property.");
        }
    });
}
/**
 * @internal
 */
function searchEnvVariablesForDestination(options) {
    logger.debug('Attempting to retrieve destination from environment variable.');
    if (getDestinationsEnvVariable()) {
        try {
            const destination = getDestinationFromEnvByName(options.destinationName);
            if (destination) {
                logger.info(`Successfully retrieved destination '${options.destinationName}' from environment variable.`);
                return destination;
            }
        }
        catch (error) {
            logger.error(`Error in reading the given destinations from the environment variable ${error.message}.`);
        }
    }
    logger.debug('No environment variable set.');
    return null;
}
exports.searchEnvVariablesForDestination = searchEnvVariablesForDestination;
/**
 * @internal
 */
function validateNameAvailable(destinationName, existingNames) {
    if (existingNames.has(destinationName)) {
        throw new Error(`Parsing destinations failed, destination with name "${destinationName}" already exists in the "destinations" environment variables.`);
    }
}
exports.validateNameAvailable = validateNameAvailable;
/**
 * @internal
 */
function setDestinationsInEnv(destinations) {
    process.env.destinations = JSON.stringify(destinations);
}
exports.setDestinationsInEnv = setDestinationsInEnv;
//# sourceMappingURL=destination-from-env.js.map