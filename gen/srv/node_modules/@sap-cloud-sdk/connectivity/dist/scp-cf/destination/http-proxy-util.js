"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.proxyAgent = exports.addProxyConfigurationInternet = exports.parseProxyEnv = exports.proxyStrategy = void 0;
const node_url_1 = require("node:url");
const http_proxy_agent_1 = require("http-proxy-agent");
const https_proxy_agent_1 = require("https-proxy-agent");
const util_1 = require("@sap-cloud-sdk/util");
const protocol_1 = require("../protocol");
const authorization_header_1 = require("../authorization-header");
const get_protocol_1 = require("../get-protocol");
const destination_service_types_1 = require("./destination-service-types");
const logger = (0, util_1.createLogger)({
    package: 'connectivity',
    messageContext: 'proxy-util'
});
/**
 * @internal
 * Determines the proxy strategy. If the 'no_proxy' env variable is set, the `ProxyConfiguration` in the destination is omitted.
 * For the 'on-premise' and 'internet' proxy strategies the connectivity service or environment variables are checked to fill the `ProxyConfiguration`.
 * @param destination - Destination to derive the proxy strategy from.
 * @returns The proxy strategy for the given destination.
 */
function proxyStrategy(destination) {
    if (destination.proxyType === 'OnPremise') {
        logger.debug('OnPrem destination proxy settings from connectivity service will be used.');
        return 'on-premise';
    }
    if (destination.proxyType === 'PrivateLink') {
        logger.debug('PrivateLink destination proxy settings will be used. This is not supported in local/CI/CD environments.');
        return 'private-link';
    }
    if ((0, destination_service_types_1.isHttpDestination)(destination)) {
        const destinationProtocol = (0, get_protocol_1.getProtocolOrDefault)(destination);
        return getProxyStrategyFromProxyEnvValue(destinationProtocol, destination.url);
    }
    return 'no-proxy';
}
exports.proxyStrategy = proxyStrategy;
function getProxyStrategyFromProxyEnvValue(protocol, destinationUrl) {
    if (!getProxyEnvValue(protocol)) {
        logger.debug(`Could not find proxy settings for ${protocol} in the environment variables - no proxy used.`);
        return 'no-proxy';
    }
    if (getNoProxyEnvValue().includes(destinationUrl)) {
        logger.debug(`Destination URL ${destinationUrl} is in no_proxy list: ${getNoProxyEnvValue()} - no proxy used.`);
        return 'no-proxy';
    }
    if (getProxyEnvValue(protocol)) {
        logger.debug(`Proxy settings for ${protocol} are found in environment variables.`);
        return 'internet';
    }
    return 'no-proxy';
}
function getProxyEnvValue(protocol) {
    const proxyEnvKey = protocol + '_proxy';
    const proxyEnvValue = process.env[proxyEnvKey.toLowerCase()] ||
        process.env[proxyEnvKey.toUpperCase()];
    logger.debug(`Tried to read ${proxyEnvKey.toLowerCase()} or ${proxyEnvKey.toUpperCase()} from the environment variables. Value is ${proxyEnvValue}.`);
    return proxyEnvValue || undefined;
}
function getNoProxyEnvValue() {
    const noProxyEnv = process.env.no_proxy || process.env.NO_PROXY;
    if (!noProxyEnv) {
        return [];
    }
    const split = noProxyEnv.split(',').map(s => s.trim());
    if (split.find(s => s.includes('*'))) {
        logger.warn(`The no_proxy env contains a wildcard ${noProxyEnv}, which is currently not supported`);
    }
    return split;
}
function getPort(url) {
    if (url.port) {
        return parseInt(url.port);
    }
    return url.protocol === 'https:' ? 443 : 80;
}
function getOriginalProtocol(href) {
    const test = href.match(/^[\w.-]+:\/\//);
    return test ? test[0].slice(0, -2) : undefined;
}
function sanitizeUrl(href) {
    const protocol = getOriginalProtocol(href);
    if (!protocol) {
        logger.debug('No protocol specified, using "http:".');
        return `http://${href}`;
    }
    return href;
}
function validateUrl(url) {
    if (url.protocol !== 'http:' && url.protocol !== 'https:') {
        throw new Error(`Unsupported protocol "${url.protocol}".`);
    }
    if (url.protocol === 'https:') {
        logger.debug('Using protocol "https:" to connect to a proxy. This is unusual but possible.');
    }
    if (url.username && !url.password) {
        throw new Error('Password missing.');
    }
}
/**
 * Parses the environment variable for the web proxy and extracts the values considering defaults like http for the protocol and 80 or 443 for the port.
 * The general pattern to be parsed is `protocol://user:password@host:port`, where everything besides the host is optional.
 * Special characters in the user and password need to be percent encoded.
 * @param proxyEnvValue - Environment variable which is parsed.
 * @returns Configuration with default values or `undefined` if the parsing failed.
 */
function parseProxyEnv(proxyEnvValue) {
    const href = sanitizeUrl(proxyEnvValue);
    try {
        const url = new node_url_1.URL(href);
        validateUrl(url);
        const proxyConfig = {
            host: url.hostname,
            protocol: (0, protocol_1.getProtocol)(url.protocol),
            port: getPort(url)
        };
        if (url.username && url.password) {
            proxyConfig.headers = {
                'Proxy-Authorization': (0, authorization_header_1.basicHeader)(decodeURIComponent(url.username), decodeURIComponent(url.password))
            };
        }
        if (proxyConfig) {
            const loggableConfig = {
                ...proxyConfig,
                headers: (0, util_1.sanitizeRecord)(proxyConfig.headers || {}, 'Authorization header present. Not logged for security reasons.')
            };
            logger.debug(`Used Proxy Configuration: ${JSON.stringify(loggableConfig, null, 2)}.`);
        }
        return proxyConfig;
    }
    catch (err) {
        logger.warn(`Could not parse proxy configuration from environment variable. Reason: ${err.message}`);
        return undefined;
    }
}
exports.parseProxyEnv = parseProxyEnv;
/**
 * Adds the proxy configuration to a destination based on web proxies defined in environment variables. See {@link ProxyConfiguration} and {@link proxyStrategy} for details.
 * @param destination - to which the proxy configuration is added.
 * @returns Destination containing the configuration for web proxy.
 * @internal
 */
function addProxyConfigurationInternet(destination) {
    const proxyEnvValue = getProxyEnvValue((0, get_protocol_1.getProtocolOrDefault)(destination));
    if (proxyEnvValue) {
        return {
            ...destination,
            proxyConfiguration: parseProxyEnv(proxyEnvValue) || destination.proxyConfiguration
        };
    }
    logger.warn('Attempt to get proxy config from environment variables failed. At this point this should not happen - no proxy used.');
    return { ...destination };
}
exports.addProxyConfigurationInternet = addProxyConfigurationInternet;
/**
 * Builds the http(s)-agent config. Note that the proxy agent type like http or https is determined by the destination RUL protocol.
 * The protocol from the proxy is unrelated to this and in most cases http.
 * All additional options are forwarded to tls.connect and net.connect see https://github.com/TooTallNate/node-https-proxy-agent#new-httpsproxyagentobject-options
 * @param destination - Destination containing the proxy configurations
 * @param options - Additional options for the agent
 * @returns The http(s)-agent containing the proxy configuration
 * @internal
 */
function proxyAgent(destination, options) {
    const proxyConfig = destination.proxyConfiguration;
    if (!proxyConfig) {
        throw new Error('Proxy config must not be undefined.');
    }
    if (options?.host) {
        logger.warn(`The agent options you passed to the proxy agent creation contains the host "${options.host}" which will overwrite the host from the proxy config.`);
    }
    if (options?.port) {
        logger.warn(`The agent options you passed to the proxy agent creation contains the port "${options.port}" which will overwrite the port from the proxy config.`);
    }
    const agentConfig = {
        host: proxyConfig.host,
        protocol: proxyConfig.protocol,
        port: proxyConfig.port,
        ...options
    };
    const { protocol, host, port, ...agentOptions } = agentConfig;
    const proxyUrl = `${protocol}://${(0, util_1.removeTrailingSlashes)(host)}:${port}`;
    const targetProtocol = (0, get_protocol_1.getProtocolOrDefault)(destination);
    if (targetProtocol === 'http') {
        return {
            httpAgent: new http_proxy_agent_1.HttpProxyAgent(proxyUrl, agentOptions)
        };
    }
    if (targetProtocol === 'https') {
        return {
            httpsAgent: new https_proxy_agent_1.HttpsProxyAgent(proxyUrl, agentOptions)
        };
    }
    throw new Error(`The target protocol: ${targetProtocol} has to be either https or http.`);
}
exports.proxyAgent = proxyAgent;
//# sourceMappingURL=http-proxy-util.js.map