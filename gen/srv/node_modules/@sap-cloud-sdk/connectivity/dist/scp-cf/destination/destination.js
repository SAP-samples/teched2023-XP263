"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.noDestinationErrorMessage = exports.isDestinationJson = exports.isDestinationConfiguration = exports.parseCertificate = exports.toDestinationNameUrl = exports.getDestinationConfig = exports.getAdditionalQueryParameters = exports.getAdditionalHeaders = exports.getAdditionalHeadersAndQueryParameters = exports.parseDestination = exports.sanitizeDestination = void 0;
const util_1 = require("@sap-cloud-sdk/util");
const destination_accessor_types_1 = require("./destination-accessor-types");
/**
 * Takes an existing or a parsed destination and returns an SDK compatible destination object.
 * @param destination - An object that adheres to the {@link Destination} interface.
 * @returns An SDK compatible destination object.
 */
function sanitizeDestination(destination) {
    const destAuthToken = parseAuthTokens(destination);
    let parsedDestination = parseCertificates(destAuthToken);
    parsedDestination = setDefaultAuthenticationFallback(parsedDestination);
    parsedDestination = setTrustAll(parsedDestination);
    parsedDestination = setOriginalProperties(parsedDestination);
    return parsedDestination;
}
exports.sanitizeDestination = sanitizeDestination;
/**
 * Takes a JSON object returned by any of the calls to the destination service and returns an SDK compatible destination object.
 * This function only accepts destination configurations of type 'HTTP' and will error if no 'URL' is given.
 * TODO: Remove from public api in version 3. (Check if related types can also be removed from public api).
 * @param destinationJson - A JSON object returned by the destination service.
 * @returns An SDK compatible destination object.
 */
function parseDestination(destinationJson) {
    const destinationConfig = getDestinationConfig(destinationJson);
    const destination = Object.entries(destinationConfig).reduce((dest, [originalKey, value]) => {
        if (originalKey in configMapping) {
            dest[configMapping[originalKey]] = value;
        }
        return dest;
    }, {
        originalProperties: destinationJson,
        authTokens: destinationJson['authTokens'] || [],
        certificates: destinationJson['certificates'] || []
    });
    const additionalHeadersAndQueryParameters = getAdditionalHeadersAndQueryParameters(destinationConfig);
    return sanitizeDestination({
        ...destination,
        ...additionalHeadersAndQueryParameters
    });
}
exports.parseDestination = parseDestination;
/**
 * Get either additional headers or query parameters from a destination, depending on the given prefix.
 * @param destinationConfig - Original destination config that could include additional headers or query parameters.
 * @param originalKeyPrefix - This is what the additional header and query keys start with, when specified in the original destination config.
 * @returns An object with either the headers or query parameters and their values, depending on the `originalKeyPrefix`.
 */
function getAdditionalProperties(destinationConfig, originalKeyPrefix) {
    const relevantConfigEntries = Object.entries(destinationConfig).filter(([key]) => key.startsWith(originalKeyPrefix));
    return relevantConfigEntries.reduce((additionalProperties, [originalKey, value]) => {
        const headerKey = originalKey.replace(originalKeyPrefix, '');
        additionalProperties[headerKey] = value;
        return additionalProperties;
    }, {});
}
/**
 * @internal
 * Get additional headers and/or query parameters from a destination.
 * Destinations can specify additional headers and/or query parameters, that should be added to every request against the given destination.
 * They are specified in the following format:
 * `URL.headers.<header-name>` or `URL.queries.<query-parameter-name>`
 * @param destinationConfig - Original destination config that could include additional headers or query parameters.
 * @returns An object with either the headers or query parameters and their values, depending on the `originalKeyPrefix`.
 */
function getAdditionalHeadersAndQueryParameters(destinationConfig) {
    const additionalProperties = {};
    const additionalHeaders = getAdditionalHeaders(destinationConfig).headers;
    if (additionalHeaders && Object.keys(additionalHeaders).length) {
        additionalProperties['headers'] = additionalHeaders;
    }
    const additionalQueryParameters = getAdditionalQueryParameters(destinationConfig).queryParameters;
    if (additionalQueryParameters &&
        Object.keys(additionalQueryParameters).length) {
        additionalProperties['queryParameters'] = additionalQueryParameters;
    }
    return additionalProperties;
}
exports.getAdditionalHeadersAndQueryParameters = getAdditionalHeadersAndQueryParameters;
/**
 * @internal
 * Get additional headers from a destination.
 * Destinations can specify additional headers, that should be added to every request against the given destination.
 * They are specified in the following format:
 * `URL.headers.<header-name>`
 * @param destinationConfig - Original destination config that could include additional headers.
 * @returns An object with either the headers or query parameters and their values, depending on the `originalKeyPrefix`.
 */
function getAdditionalHeaders(destinationConfig) {
    const additionalHeaders = getAdditionalProperties(destinationConfig, 'URL.headers.');
    const additionalProperties = {};
    if (Object.keys(additionalHeaders).length) {
        additionalProperties['headers'] = additionalHeaders;
    }
    return additionalProperties;
}
exports.getAdditionalHeaders = getAdditionalHeaders;
/**
 * @internal
 * Get additional query parameters from a destination.
 * Destinations can specify additional query parameters, that should be added to every request against the given destination.
 * They are specified in the following format:
 * `URL.queries.<query-parameter-name>`
 * @param destinationConfig - Original destination config that could include additional headers or query parameters.
 * @returns An object with either the headers or query parameters and their values, depending on the `originalKeyPrefix`.
 */
function getAdditionalQueryParameters(destinationConfig) {
    const additionalQueryParameters = getAdditionalProperties(destinationConfig, 'URL.queries.');
    const additionalProperties = {};
    if (Object.keys(additionalQueryParameters).length) {
        additionalProperties['queryParameters'] = additionalQueryParameters;
    }
    return additionalProperties;
}
exports.getAdditionalQueryParameters = getAdditionalQueryParameters;
/**
 * @internal
 */
function getDestinationConfig(destinationJson) {
    return isDestinationJson(destinationJson)
        ? destinationJson.destinationConfiguration
        : destinationJson;
}
exports.getDestinationConfig = getDestinationConfig;
/**
 * Transform destination to string containing destination information.
 * @param destination - Either destination object or destinationName and Jwt.
 * @returns String containing information on the destination.
 */
function toDestinationNameUrl(destination) {
    if ((0, destination_accessor_types_1.isDestinationFetchOptions)(destination)) {
        return `name: ${destination.destinationName}`;
    }
    const text = ['name', 'url']
        .filter(key => destination[key])
        .map(key => `${key}: ${destination[key]}`);
    return text.length > 0
        ? text.join(',')
        : "Destination does not have a 'name' or 'url' property.";
}
exports.toDestinationNameUrl = toDestinationNameUrl;
function setOriginalProperties(destination) {
    const originalProperties = destination.originalProperties
        ? destination.originalProperties
        : destination;
    return (0, util_1.assoc)('originalProperties', originalProperties, destination);
}
function setDefaultAuthenticationFallback(destination) {
    return destination.authentication
        ? destination
        : (0, util_1.assoc)('authentication', getAuthenticationType(destination), destination);
}
/**
 * Transforms the upper case properties of the destination service response to lower case.
 * @internal
 * @param certificate - Response from the certificate endpoint of the destination service.
 * @returns The parsed Destination Certificate with lower case properties.
 */
function parseCertificate(certificate) {
    return {
        name: certificate.Name || certificate.name,
        content: certificate.Content || certificate.content,
        type: certificate.Type || certificate.type
    };
}
exports.parseCertificate = parseCertificate;
function parseCertificates(destination) {
    const certificates = destination.certificates
        ? destination.certificates.map(parseCertificate)
        : [];
    return (0, util_1.assoc)('certificates', certificates, destination);
}
function parseAuthToken(authToken) {
    return {
        type: authToken.type,
        value: authToken.value,
        expiresIn: authToken.expires_in,
        error: 'error' in authToken ? authToken.error : null,
        http_header: authToken.http_header
    };
}
function parseAuthTokens(destination) {
    const authTokens = destination.authTokens
        ? destination.authTokens.map(parseAuthToken)
        : [];
    return (0, util_1.assoc)('authTokens', authTokens, destination);
}
function setTrustAll(destination) {
    return (0, util_1.assoc)('isTrustingAllCertificates', parseTrustAll(destination.isTrustingAllCertificates), destination);
}
function parseTrustAll(isTrustingAllCertificates) {
    if (typeof isTrustingAllCertificates === 'string') {
        return isTrustingAllCertificates.toLowerCase() === 'true';
    }
    return !!isTrustingAllCertificates;
}
function getAuthenticationType(destination) {
    return destination.authentication ||
        (destination.username && destination.password)
        ? 'BasicAuthentication'
        : 'NoAuthentication';
}
/* eslint-disable-next-line valid-jsdoc */
/**
 * @internal
 */
function isDestinationConfiguration(destination) {
    return destination.URL !== undefined;
}
exports.isDestinationConfiguration = isDestinationConfiguration;
/* eslint-disable-next-line valid-jsdoc */
/**
 * @internal
 */
function isDestinationJson(destination) {
    return Object.keys(destination).includes('destinationConfiguration');
}
exports.isDestinationJson = isDestinationJson;
const configMapping = {
    URL: 'url',
    Name: 'name',
    User: 'username',
    Password: 'password',
    ProxyType: 'proxyType',
    'sap-client': 'sapClient',
    Authentication: 'authentication',
    TrustAll: 'isTrustingAllCertificates',
    Type: 'type',
    tokenServiceURL: 'tokenServiceUrl',
    clientId: 'clientId',
    clientSecret: 'clientSecret',
    tokenServiceUser: 'tokenServiceUser',
    tokenServicePassword: 'tokenServicePassword',
    CloudConnectorLocationId: 'cloudConnectorLocationId',
    certificates: 'certificates',
    KeyStoreLocation: 'keyStoreName',
    KeyStorePassword: 'keyStorePassword',
    SystemUser: 'systemUser',
    /**
     * Base64-encoded JSON web key set, containing the signing keys which are used to validate the JWT provided in the X-User-Token header.
     */
    'x_user_token.jwks': 'jwks',
    /**
     * URI of the JSON web key set, containing the signing keys which are used to validate the JWT provided in the X-User-Token header.
     */
    'x_user_token.jwks_uri': 'jwksUri'
};
/**
 * @internal
 */
function noDestinationErrorMessage(destination) {
    return (0, destination_accessor_types_1.isDestinationFetchOptions)(destination)
        ? `Could not find a destination with name "${destination.destinationName}"! Unable to execute request.`
        : 'Could not find a destination to execute request against and no destination name has been provided (this should never happen)!';
}
exports.noDestinationErrorMessage = noDestinationErrorMessage;
//# sourceMappingURL=destination.js.map