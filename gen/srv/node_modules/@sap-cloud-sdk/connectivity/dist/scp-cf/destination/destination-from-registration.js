"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.searchRegisteredDestination = exports.registerDestination = void 0;
const util_1 = require("@sap-cloud-sdk/util");
const jwt_1 = require("../jwt");
const destination_cache_1 = require("./destination-cache");
const destination_service_types_1 = require("./destination-service-types");
const http_proxy_util_1 = require("./http-proxy-util");
const register_destination_cache_1 = require("./register-destination-cache");
const logger = (0, util_1.createLogger)({
    package: 'connectivity',
    messageContext: 'register-destination'
});
/**
 * @internal
 */
const defaultTenantId = 'tenant_id';
/**
 * Registers a destination in a cache for later usage.
 *
 * If a destination with the same key is already in the cache, it is replaced.
 * The key is built using the `getDestinationCacheKey` method.
 * @param destination - A destination to add to the `destinations` cache.
 * @param options - Options how to cache the destination.
 */
async function registerDestination(destination, options) {
    if (!destination.name) {
        throw Error('Registering destinations requires a destination name.');
    }
    destination.mtls = !!options?.inferMtls;
    if (options?.useMtlsCache) {
        register_destination_cache_1.registerDestinationCache.mtls.useMtlsCache = true;
        await register_destination_cache_1.registerDestinationCache.mtls.cacheMtlsOptions();
    }
    await register_destination_cache_1.registerDestinationCache.destination.cacheRetrievedDestination(getJwtForCaching(options), destination, isolationStrategy(options));
}
exports.registerDestination = registerDestination;
function getJwtForCaching(options) {
    const jwt = (0, jwt_1.decodeOrMakeJwt)(options?.jwt);
    if (!jwt?.zid) {
        if (options?.jwt) {
            logger.error('Could neither determine tenant from JWT nor service binding to XSUAA, although a JWT was passed. Destination will be registered without tenant information.');
        }
        else {
            logger.debug('Could not determine tenant from service binding to XSUAA. Destination will be registered without tenant information.');
        }
        return { zid: defaultTenantId };
    }
    return jwt;
}
/**
 * @internal
 * @param options - The options for searching the cache
 * @returns Destination - the destination from cache
 */
async function searchRegisteredDestination(options) {
    const destination = await register_destination_cache_1.registerDestinationCache.destination.retrieveDestinationFromCache(getJwtForCaching(options), options.destinationName, isolationStrategy(options));
    if (!destination) {
        logger.debug(`Could not retrieve '${options.destinationName}' from registered destinations.`);
        return null;
    }
    logger.info(`Successfully retrieved destination '${options.destinationName}' from registered destinations.`);
    if (destination.forwardAuthToken) {
        destination.authTokens = destinationAuthToken(options.jwt);
    }
    return (0, destination_service_types_1.isHttpDestination)(destination) &&
        ['internet', 'private-link'].includes((0, http_proxy_util_1.proxyStrategy)(destination))
        ? (0, http_proxy_util_1.addProxyConfigurationInternet)(destination)
        : destination;
}
exports.searchRegisteredDestination = searchRegisteredDestination;
/**
 * If an explicit isolation strategy is given by the user this is used. If not the isolation strategy is determined in the following way:
 * If a JWT is given and it contains a user_id the isolation is 'TenantUser'. If no JWT is given or it does not contain a user the isolation is 'Tenant'.
 * @param options - Options passed to register the destination containing the jwt.
 * @returns The isolation strategy.
 */
function isolationStrategy(options) {
    if (options?.isolationStrategy) {
        return options.isolationStrategy;
    }
    const decoded = options?.jwt ? (0, jwt_1.decodeJwt)(options.jwt) : undefined;
    return (0, destination_cache_1.getDefaultIsolationStrategy)(decoded);
}
function destinationAuthToken(token) {
    if (token) {
        const decoded = (0, jwt_1.decodeJwt)(token);
        logger.debug("Option 'forwardAuthToken' enabled on destination. Using the initial token for the destination.");
        return [
            {
                value: token,
                expiresIn: decoded.exp?.toString(),
                error: null,
                http_header: { key: 'Authorization', value: `Bearer ${token}` },
                type: 'Bearer'
            }
        ];
    }
    logger.warn("Option 'forwardAuthToken' was set on destination but no token was provided to forward. This is most likely unintended and will lead to a authorization error on request execution.");
}
//# sourceMappingURL=destination-from-registration.js.map