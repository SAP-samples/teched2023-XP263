"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.fetchCertificate = exports.fetchDestination = exports.fetchSubaccountDestinations = exports.fetchInstanceDestinations = void 0;
const util_1 = require("@sap-cloud-sdk/util");
// eslint-disable-next-line import/named
const axios_1 = __importDefault(require("axios"));
const internal_1 = require("@sap-cloud-sdk/resilience/internal");
const resilience_1 = require("@sap-cloud-sdk/resilience");
const asyncRetry = __importStar(require("async-retry"));
const jwt_1 = require("../jwt");
const http_agent_1 = require("../../http-agent");
const authorization_header_1 = require("../authorization-header");
const tenant_1 = require("../tenant");
const destination_1 = require("./destination");
const destination_service_cache_1 = require("./destination-service-cache");
const logger = (0, util_1.createLogger)({
    package: 'connectivity',
    messageContext: 'destination-service'
});
/**
 * Fetches all instance destinations from the given URI.
 * @param destinationServiceUri - The URI of the destination service
 * @param jwt - The access token
 * @param options - Options to use by retrieving destinations
 * @returns A promise resolving to a list of instance destinations
 * @internal
 */
function fetchInstanceDestinations(destinationServiceUri, jwt, options) {
    return fetchDestinations(destinationServiceUri, jwt, 'instance', options);
}
exports.fetchInstanceDestinations = fetchInstanceDestinations;
/**
 * Fetches all subaccount destinations from the given URI.
 * @param destinationServiceUri - The URI of the destination service
 * @param jwt - The access token
 * @param options - Options to use by retrieving destinations
 * @returns A promise resolving to a list of subaccount destinations
 * @internal
 */
function fetchSubaccountDestinations(destinationServiceUri, jwt, options) {
    return fetchDestinations(destinationServiceUri, jwt, 'subaccount', options);
}
exports.fetchSubaccountDestinations = fetchSubaccountDestinations;
async function fetchDestinations(destinationServiceUri, jwt, type, options) {
    const targetUri = `${(0, util_1.removeTrailingSlashes)(destinationServiceUri)}/destination-configuration/v1/${type}Destinations`;
    if (options?.useCache) {
        const destinationsFromCache = destination_service_cache_1.destinationServiceCache.retrieveDestinationsFromCache(targetUri, (0, jwt_1.decodeJwt)(jwt));
        if (destinationsFromCache) {
            logger.debug(`Destinations retrieved from cache. There were ${destinationsFromCache.length} destinations returned from the cache.`);
            return destinationsFromCache;
        }
    }
    const headers = (0, jwt_1.wrapJwtInHeader)(jwt).headers;
    return callDestinationEndpoint({ uri: targetUri, tenantId: getTenantFromTokens(jwt) }, headers)
        .then(response => {
        const destinations = response.data.map(destination => (0, destination_1.parseDestination)(destination));
        if (options?.useCache) {
            destination_service_cache_1.destinationServiceCache.cacheRetrievedDestinations(targetUri, (0, jwt_1.decodeJwt)(jwt), destinations);
        }
        return destinations;
    })
        .catch(error => {
        throw new util_1.ErrorWithCause(`Failed to fetch ${type} destinations.${errorMessageFromResponse(error)}`, error);
    });
}
/**
 * Fetches a specific destination by name from the given URI, including authorization tokens.
 * For destinations with authenticationType OAuth2SAMLBearerAssertion, this call will trigger the OAuth2SAMLBearerFlow against the target destination.
 * In this pass the access token as string.
 * Fetches a specific destination with authenticationType OAuth2UserTokenExchange by name from the given URI, including authorization tokens.
 * @param destinationServiceUri - The URI of the destination service
 * @param token - The access token or AuthAndExchangeTokens if you want to include the X-user-token for OAuth2UserTokenExchange.
 * @param options - Options to use by retrieving destinations
 * @returns A Promise resolving to the destination
 * @internal
 */
async function fetchDestination(destinationServiceUri, token, options) {
    return fetchDestinationByTokens(destinationServiceUri, typeof token === 'string' ? { authHeaderJwt: token } : token, options);
}
exports.fetchDestination = fetchDestination;
/**
 * Fetches a certificate from the subaccount and destination instance for a given a name.
 * Subaccount is tried first.
 * @param destinationServiceUri - The URI of the destination service
 * @param token - The access token for destination service.
 * @param certificateName - Name of the Certificate to be fetched
 * @returns A Promise resolving to the destination
 * @internal
 */
async function fetchCertificate(destinationServiceUri, token, certificateName) {
    const filetype = certificateName.split('.')[1];
    if (filetype.toLowerCase() !== 'pem') {
        logger.warn(`The provided truststore ${certificateName} is not in 'pem' format which is currently the only supported format. Truststore is ignored.`);
        return;
    }
    const accountUri = `${(0, util_1.removeTrailingSlashes)(destinationServiceUri)}/destination-configuration/v1/subaccountCertificates/${certificateName}`;
    const instanceUri = `${(0, util_1.removeTrailingSlashes)(destinationServiceUri)}/destination-configuration/v1/instanceCertificates/${certificateName}`;
    const header = (0, jwt_1.wrapJwtInHeader)(token).headers;
    try {
        const response = await callCertificateEndpoint({ uri: accountUri, tenantId: getTenantFromTokens(token) }, header).catch(() => callCertificateEndpoint({
            uri: instanceUri,
            tenantId: getTenantFromTokens(token)
        }, header));
        return (0, destination_1.parseCertificate)(response.data);
    }
    catch (err) {
        logger.warn(`Failed to fetch truststore certificate ${certificateName} - Continuing without certificate. This may cause failing requests`, err);
    }
}
exports.fetchCertificate = fetchCertificate;
function getTenantFromTokens(token) {
    let tenant;
    if (typeof token === 'string') {
        tenant = (0, tenant_1.getTenantIdWithFallback)(token);
    }
    else {
        tenant =
            token.exchangeTenant || // represents the tenant as string already see https://api.sap.com/api/SAP_CP_CF_Connectivity_Destination/resource
                (0, tenant_1.getTenantIdWithFallback)(token.exchangeHeaderJwt) ||
                (0, tenant_1.getTenantIdWithFallback)(token.authHeaderJwt);
    }
    if (!tenant) {
        throw new Error('Could not obtain tenant identifier from JWT.');
    }
    return tenant;
}
async function fetchDestinationByTokens(destinationServiceUri, tokens, options) {
    const targetUri = `${(0, util_1.removeTrailingSlashes)(destinationServiceUri)}/destination-configuration/v1/destinations/${options.destinationName}`;
    let authHeader = (0, jwt_1.wrapJwtInHeader)(tokens.authHeaderJwt).headers;
    authHeader = tokens.exchangeHeaderJwt
        ? { ...authHeader, 'X-user-token': tokens.exchangeHeaderJwt }
        : authHeader;
    authHeader = tokens.exchangeTenant
        ? { ...authHeader, 'X-tenant': tokens.exchangeTenant }
        : authHeader;
    authHeader = tokens.refreshToken
        ? { ...authHeader, 'X-refresh-token': tokens.refreshToken }
        : authHeader;
    return callDestinationEndpoint({ uri: targetUri, tenantId: getTenantFromTokens(tokens) }, authHeader, options)
        .then(response => {
        const destination = (0, destination_1.parseDestination)(response.data);
        return destination;
    })
        .catch(error => {
        {
            throw new util_1.ErrorWithCause(`Failed to fetch destination ${options.destinationName}.${errorMessageFromResponse(error)}`, error);
        }
    });
}
function errorMessageFromResponse(error) {
    return (0, util_1.propertyExists)(error, 'response', 'data', 'ErrorMessage')
        ? ` ${error.response.data.ErrorMessage}`
        : '';
}
function retryDestination(destinationName) {
    return options => arg => {
        let retryCount = 1;
        return asyncRetry.default(async (bail) => {
            try {
                const destination = await options.fn(arg);
                if (retryCount < 3) {
                    retryCount++;
                    // this will throw if the destination does not contain valid auth headers and a second try is done to get a destination with valid tokens.
                    await (0, authorization_header_1.buildAuthorizationHeaders)((0, destination_1.parseDestination)(destination.data));
                }
                return destination;
            }
            catch (error) {
                const status = error?.response?.status;
                if (status.toString().startsWith('4')) {
                    bail(new Error(`Request failed with status code ${status}`));
                    // We need to return something here but the actual value does not matter
                    return undefined;
                }
                throw error;
            }
        }, {
            retries: 3,
            onRetry: err => logger.warn(`Failed to retrieve destination ${destinationName} - doing a retry. Original Error ${err.message}`)
        });
    };
}
async function callCertificateEndpoint(context, headers) {
    if (!context.uri.includes('Certificates')) {
        throw new Error(`callCertificateEndpoint was called with illegal argument: ${context.uri}. URL must be certificate endpoint of destination service.`);
    }
    return callDestinationService(context, headers);
}
async function callDestinationEndpoint(context, headers, options) {
    if (!context.uri.match(/[instance|subaccount]Destinations|v1\/destinations/)) {
        throw new Error(`callDestinationEndpoint was called with illegal argument: ${context.uri}. URL must be destination(s) endpoint of destination service.`);
    }
    return callDestinationService(context, headers, options);
}
async function callDestinationService(context, headers, options) {
    const { destinationName, retry } = options || {};
    const requestConfig = {
        ...(await (0, http_agent_1.urlAndAgent)(context.uri)),
        proxy: false,
        method: 'get',
        headers
    };
    const resilienceMiddleware = (0, resilience_1.resilience)();
    if (destinationName && retry) {
        resilienceMiddleware.unshift(retryDestination(destinationName));
    }
    return (0, internal_1.executeWithMiddleware)(resilienceMiddleware, {
        context,
        fnArgument: requestConfig,
        fn: config => axios_1.default.request(config)
    });
}
//# sourceMappingURL=destination-service.js.map