"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.decodeOrMakeJwt = exports.isUserToken = exports.getJwtPair = exports.isXsuaaToken = exports.checkMandatoryValue = exports.readPropertyWithWarn = exports.wrapJwtInHeader = exports.audiences = exports.issuerUrl = exports.verificationKeyCache = exports.verifyJwt = exports.retrieveJwt = exports.decodeJwtComplete = exports.decodeJwt = void 0;
const util_1 = require("@sap-cloud-sdk/util");
const xssec = __importStar(require("@sap/xssec"));
const jsonwebtoken_1 = require("jsonwebtoken");
const cache_1 = require("./cache");
const environment_accessor_1 = require("./environment-accessor");
const logger = (0, util_1.createLogger)({
    package: 'connectivity',
    messageContext: 'jwt'
});
/**
 * Decode JWT.
 * @param token - JWT to be decoded.
 * @returns Decoded payload.
 */
function decodeJwt(token) {
    return typeof token === 'string' ? decodeJwtComplete(token).payload : token;
}
exports.decodeJwt = decodeJwt;
/**
 * Decode JWT and return the complete decoded token.
 * @param token - JWT to be decoded.
 * @returns Decoded token containing payload, header and signature.
 * @internal
 */
function decodeJwtComplete(token) {
    const decodedToken = (0, jsonwebtoken_1.decode)(token, { complete: true, json: true });
    if (decodedToken !== null && isJwtWithPayloadObject(decodedToken)) {
        return decodedToken;
    }
    throw new Error('JwtError: The given jwt payload does not encode valid JSON.');
}
exports.decodeJwtComplete = decodeJwtComplete;
/**
 * Retrieve JWT from a request that is based on the node `IncomingMessage`. Fails if no authorization header is given or has the wrong format. Expected format is 'Bearer <TOKEN>'.
 * @param req - Request to retrieve the JWT from.
 * @returns JWT found in header.
 */
function retrieveJwt(req) {
    const header = authHeader(req);
    if (validateAuthHeader(header)) {
        return header.split(' ')[1];
    }
}
exports.retrieveJwt = retrieveJwt;
function authHeader(req) {
    const entries = Object.entries(req.headers).find(([key]) => key.toLowerCase() === 'authorization');
    if (entries) {
        const header = entries[1];
        // Header could be a list of headers
        return Array.isArray(header) ? header[0] : header;
    }
    return undefined;
}
function validateAuthHeader(header) {
    if (typeof header === 'undefined') {
        logger.warn('Authorization header not set.');
        return false;
    }
    const [authType, token] = header.split(' ');
    if (typeof token === 'undefined') {
        logger.warn('Token in auth header missing.');
        return false;
    }
    if (authType.toLowerCase() !== 'bearer') {
        logger.warn('Authorization type is not Bearer.');
        return false;
    }
    return true;
}
/**
 * Verifies the given JWT and returns the decoded payload.
 * @param token - JWT to be verified
 * @param options - Options to control certain aspects of JWT verification behavior.
 * @returns A Promise to the decoded and verified JWT.
 * @internal
 */
async function verifyJwt(token, options) {
    const disableCache = !{ ...defaultVerifyJwtOptions, ...options }
        .cacheVerificationKeys;
    const credentials = (0, environment_accessor_1.getXsuaaServiceCredentials)(token);
    const promise = new Promise((resolve, reject) => {
        xssec.createSecurityContext(token, { disableCache, credentials }, function (error, securityContext, tokenInfo) {
            if (error) {
                return reject(error);
            }
            return resolve(tokenInfo.getPayload());
        });
    });
    return promise
        .then(data => data)
        .catch(e => {
        throw new util_1.ErrorWithCause('Failed to verify JWT.', e);
    });
}
exports.verifyJwt = verifyJwt;
const defaultVerifyJwtOptions = {
    cacheVerificationKeys: true
};
/**
 * 15 minutes is the default value used by the xssec lib.
 * @internal
 */
exports.verificationKeyCache = new cache_1.Cache(900000);
/**
 * Get the issuer URL of a decoded JWT.
 * @param decodedToken - Token to read the issuer URL from.
 * @returns The issuer URL if available.
 * @internal
 */
function issuerUrl(decodedToken) {
    return readPropertyWithWarn(decodedToken, 'iss');
}
exports.issuerUrl = issuerUrl;
/**
 * Retrieve the audiences of a decoded JWT based on the audiences and scopes in the token.
 * @param decodedToken - Token to retrieve the audiences from.
 * @returns A set of audiences.
 * @internal
 */
// Comments taken from the Java SDK implementation
// Currently, scopes containing dots are allowed.
// Since the UAA builds audiences by taking the substring of scopes up to the last dot,
// scopes with dots will lead to an incorrect audience which is worked around here.
// If a JWT contains no audience, infer audiences based on the scope names in the JWT.
// This is currently necessary as the UAA does not correctly fill the audience in the user token flow.
function audiences(decodedToken) {
    if (audiencesFromAud(decodedToken).length) {
        return new Set(audiencesFromAud(decodedToken));
    }
    return new Set(audiencesFromScope(decodedToken));
}
exports.audiences = audiences;
function audiencesFromAud(decodedToken) {
    if (!(decodedToken.aud instanceof Array && decodedToken.aud.length)) {
        return [];
    }
    return decodedToken.aud.map(aud => aud.includes('.') ? aud.substr(0, aud.indexOf('.')) : aud);
}
function audiencesFromScope(decodedToken) {
    if (!decodedToken.scope) {
        return [];
    }
    const scopes = decodedToken.scope instanceof Array
        ? decodedToken.scope
        : [decodedToken.scope];
    return scopes.reduce((aud, scope) => {
        if (scope.includes('.')) {
            return [...aud, scope.substr(0, scope.indexOf('.'))];
        }
        return aud;
    }, []);
}
/**
 * Wraps the access token in header's authorization.
 * @param token - Token to attach in request header
 * @returns The request header that holds the access token
 * @internal
 */
function wrapJwtInHeader(token) {
    return { headers: { Authorization: 'Bearer ' + token } };
}
exports.wrapJwtInHeader = wrapJwtInHeader;
/**
 * @internal
 * @param jwtPayload - The jwt payload.
 * @param property - The property to be read.
 * @returns the property if present.
 */
function readPropertyWithWarn(jwtPayload, property) {
    if (!jwtPayload[property]) {
        logger.warn(`Warning JWT: The provided JWT payload does not include a '${property}' property.`);
    }
    return jwtPayload[property];
}
exports.readPropertyWithWarn = readPropertyWithWarn;
/**
 * Checks if a given key is present in the decoded JWT. If not, an error is thrown.
 * @param key - The key of the representation in typescript
 * @param mapping - The mapping between the typescript keys and the JWT key
 * @param jwtPayload - JWT payload to check fo the given key.
 * @internal
 */
function checkMandatoryValue(key, mapping, jwtPayload) {
    const value = mapping[key].extractorFunction(jwtPayload);
    if (!value) {
        throw new Error(`Property '${mapping[key].keyInJwt}' is missing in JWT payload.`);
    }
}
exports.checkMandatoryValue = checkMandatoryValue;
/**
 * Checks if the given JWT was issued by XSUAA based on the iss property and the uaa domain of the XSUAA.
 * @param jwt - JWT to be checked.
 * @returns Whether the JWT was issued by XSUAA.
 * @internal
 */
function isXsuaaToken(jwt) {
    return jwt.payload.ext_attr?.enhancer === 'XSUAA';
}
exports.isXsuaaToken = isXsuaaToken;
/**
 * Build JwtPair from an encoded JWT.
 * @internal
 */
function getJwtPair(encodedJwt) {
    return { encoded: encodedJwt, decoded: decodeJwt(encodedJwt) };
}
exports.getJwtPair = getJwtPair;
/**
 * The user JWT can be a full JWT containing user information but also a reduced one setting only the iss value
 * This method divides the two cases.
 * @param token - Token to be investigated
 * @returns Boolean value with true if the input is a UserJwtPair
 * @internal
 */
function isUserToken(token) {
    if (!token) {
        return false;
    }
    // Check if it is an Issuer Payload
    const keys = Object.keys(token.decoded);
    return !(keys.length === 1 && keys[0] === 'iss');
}
exports.isUserToken = isUserToken;
function isJwtWithPayloadObject(decoded) {
    return typeof decoded.payload !== 'string';
}
/**
 * This method either decodes the given JWT or tries to retrieve the subaccount ID from the XSUAA service binding as `zid`.
 * @param options - Options passed to register the destination containing the JWT.
 * @returns The decoded JWT or a dummy JWT containing the tenant identifier (zid).
 * @internal
 */
function decodeOrMakeJwt(jwt) {
    if (jwt) {
        const decodedJwt = typeof jwt === 'string' ? decodeJwt(jwt) : jwt;
        if (decodedJwt.zid) {
            return decodedJwt;
        }
    }
    const providerTenantId = (0, environment_accessor_1.getServiceCredentials)('xsuaa', jwt)?.subaccountid;
    if (providerTenantId) {
        return { zid: providerTenantId };
    }
}
exports.decodeOrMakeJwt = decodeOrMakeJwt;
//# sourceMappingURL=jwt.js.map