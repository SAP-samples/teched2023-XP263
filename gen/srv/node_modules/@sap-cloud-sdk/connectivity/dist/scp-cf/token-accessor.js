"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.jwtBearerToken = exports.serviceToken = void 0;
const util_1 = require("@sap-cloud-sdk/util");
const jwt_1 = require("./jwt");
const client_credentials_token_cache_1 = require("./client-credentials-token-cache");
const environment_accessor_1 = require("./environment-accessor");
const subdomain_replacer_1 = require("./subdomain-replacer");
const xsuaa_service_1 = require("./xsuaa-service");
/**
 * Returns an access token that can be used to call the given service. The token is fetched via a client credentials grant with the credentials of the given service.
 * If multiple instances of the provided service exist, the first instance will be selected.
 * When a JWT is passed, the tenant of the JWT will be used when performing the grant.
 * When no JWT is passed, the grant will be performed using the provider tenant.
 *
 * Throws an error if there is no instance of the given service type or the XSUAA service, or if the request to the XSUAA service fails.
 * @param service - The type of the service or an instance of {@link Service}.
 * @param options - Options to influence caching behavior (see {@link CachingOptions}) and a JWT. By default, caching and usage of a circuit breaker are enabled.
 * @returns Access token.
 */
async function serviceToken(service, options) {
    const opts = {
        useCache: true,
        enableCircuitBreaker: true,
        ...options
    };
    const serviceBinding = (0, environment_accessor_1.resolveServiceBinding)(service);
    const serviceCredentials = serviceBinding.credentials;
    if (opts.useCache) {
        const xsuaaUrl = getMultiTenantXsuaaUrl(serviceCredentials, options?.jwt);
        const cachedToken = client_credentials_token_cache_1.clientCredentialsTokenCache.getToken(xsuaaUrl, serviceCredentials.clientid);
        if (cachedToken) {
            return cachedToken.access_token;
        }
    }
    try {
        const token = await (0, xsuaa_service_1.getClientCredentialsToken)(serviceBinding, options?.jwt);
        if (opts.useCache) {
            const xsuaaUrl = getMultiTenantXsuaaUrl(serviceCredentials, options?.jwt);
            client_credentials_token_cache_1.clientCredentialsTokenCache.cacheToken(xsuaaUrl, serviceCredentials.clientid, token);
        }
        return token.access_token;
    }
    catch (err) {
        throw new util_1.ErrorWithCause(`Could not fetch client credentials token for service of type "${serviceBinding.label}".`, err);
    }
}
exports.serviceToken = serviceToken;
/**
 * Returns a jwt bearer token that can be used to call the given service.
 * The token is fetched via a JWT bearer token grant using the user token + client credentials.
 *
 * Throws an error if there is no instance of the given service type or the XSUAA service, or if the request to the XSUAA service fails.
 * @param jwt - The JWT of the user for whom the access token should be fetched.
 * @param service - The type of the service or an instance of {@link Service}.
 * @returns A jwt bearer token.
 */
async function jwtBearerToken(jwt, service) {
    const resolvedService = (0, environment_accessor_1.resolveServiceBinding)(service);
    return (0, xsuaa_service_1.getUserToken)(resolvedService, jwt);
}
exports.jwtBearerToken = jwtBearerToken;
function getMultiTenantXsuaaUrl(credentials, jwt) {
    return jwt
        ? (0, subdomain_replacer_1.replaceWithIssuerSubdomain)(credentials.url, (0, jwt_1.decodeJwt)(jwt))
        : credentials.url;
}
//# sourceMappingURL=token-accessor.js.map