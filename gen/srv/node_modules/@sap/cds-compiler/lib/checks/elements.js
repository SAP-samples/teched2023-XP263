'use strict';

const {
  forEachMember, forEachMemberRecursively, isBuiltinType, cardinality2str,
} = require('../model/csnUtils');
const { isGeoTypeName } = require('../compiler/builtins');
const { setProp } = require('../base/model');
// Only to be used with validator.js - a correct `this` value needs to be provided!

/**
 * Checks artifact's primary keys and an error is registered if some of the keys
 * is of type 'cds.hana.ST_POINT', 'cds.hana.ST_GEOMETRY' or if it is arrayed
 *
 * @param {CSN.Artifact} art The artifacts that will be checked
 */
function checkPrimaryKey( art ) {
  if (art.kind !== 'entity' && art.kind !== 'aspect')
    return;
  forEachMember(art, (member, memberName, prop, path) => {
    checkIfPrimaryKeyIsOfGeoType.bind(this)(member, memberName);
    checkIfPrimaryKeyIsArray.bind(this)(member, memberName);
    if (member.elements) {
      forEachMemberRecursively(member, (subMember, subMemberName) => {
        checkIfPrimaryKeyIsOfGeoType.bind(this)(subMember, subMemberName, member.key);
        checkIfPrimaryKeyIsArray.bind(this)(subMember, subMemberName, member.key);
      },
                               path);
    }
  });

  /**
   *
   * @param {CSN.Element} member The member
   * @param {string} elemFqName Full name of the element following the structure,
   *                            concatenated with '/', used for error reporting
   * @param {boolean} parentIsKey Whether parent is a key
   * @param {CSN.Path} parentPath The path of the parent element (optional)
   */
  function checkIfPrimaryKeyIsOfGeoType( member, elemFqName, parentIsKey, parentPath ) {
    if (member.key || parentIsKey) {
      const finalBaseType = this.csnUtils.getFinalTypeInfo(member.type);
      if (isGeoTypeName(finalBaseType?.type)) {
        this.error(null, parentPath || member.$path,
                   { type: finalBaseType.type, name: elemFqName },
                   'Type $(TYPE) can\'t be used as primary key in element $(NAME)');
      }
      else if (finalBaseType && this.csnUtils.isStructured(finalBaseType) && !finalBaseType.$visited) {
        setProp(finalBaseType, '$visited', true);
        forEachMemberRecursively(finalBaseType,
                                 (subMember, subMemberName) => checkIfPrimaryKeyIsOfGeoType
                                   .bind(this)(subMember,
                                               `${ elemFqName }/${ subMemberName }`,
                                               member.key || parentIsKey,
                                               member.$path));
        delete finalBaseType.$visited;
      }
    }
  }

  /**
   *
   * @param {CSN.Element} member The member
   * @param {string} elemFqName Full name of the element following the structure,
   *                            concatenated with '/', used for error reporting
   * @param {boolean} parentIsKey Whether parent is a key
   * @param {CSN.Path} parentPath The path of the parent element (optional)
   */
  function checkIfPrimaryKeyIsArray( member, elemFqName, parentIsKey, parentPath ) {
    if (member.key || parentIsKey) {
      const finalBaseType = this.csnUtils.getFinalTypeInfo(member.type);
      if (member.items || (finalBaseType && finalBaseType.items)) {
        let msg = 'std';
        if (member.target)
          msg = this.csnUtils.isComposition(member) ? 'comp' : 'assoc';

        this.error('def-invalid-key-cardinality', parentPath || member.$path,
                   {
                     name: elemFqName,
                     value: cardinality2str(member, false),
                     '#': msg,
                   }, 'Array-like type in element $(NAME) can\'t be used as primary key');
      }
      else if (finalBaseType && this.csnUtils.isStructured(finalBaseType) && !finalBaseType.$visited) {
        setProp(finalBaseType, '$visited', true);
        forEachMemberRecursively(finalBaseType,
                                 (subMember, subMemberName) => checkIfPrimaryKeyIsArray
                                   .bind(this)(subMember,
                                               `${ elemFqName }/${ subMemberName }`,
                                               member.key || parentIsKey,
                                               member.$path));
        delete finalBaseType.$visited;
      }
    }
  }
}


/**
 * Checks virtual elements and throws an error if some is either structured or
 * an association
 *
 * @param {CSN.Element} member Element to be checked
 */
function checkVirtualElement( member ) {
  if (member.virtual) {
    if (this.csnUtils.isAssocOrComposition(member))
      this.error(null, member.$path, {}, 'Element can\'t be virtual and an association or composition');
  }
}

/**
 * Checks whether managed associations
 * with cardinality 'to many' have an on-condition.
 *
 * @param {CSN.Artifact} art The artifact
 * @todo this is a member validator, is it not?
 */
function checkManagedAssoc( art ) {
  forEachMemberRecursively(art, (member) => {
    if (this.csnUtils.isAssocOrComposition(member) &&
        !isManagedComposition.bind(this)(member)) {
      const max = member.cardinality?.max ? member.cardinality.max : 1;
      if (max !== 1 && !member.on) {
        const isNoDb = art['@cds.persistence.skip'] || art['@cds.persistence.exists'];
        this.warning(isNoDb ? 'to-many-no-on-noDB' : 'to-many-no-on', member.cardinality ? member.cardinality.$path : member.$path,
                     {
                       value: cardinality2str(member, false),
                       '#': this.csnUtils.isComposition(member) ? 'comp' : 'std',
                     },
                     {
                       std: 'Expected association with target cardinality $(VALUE) to have an ON-condition',
                       comp: 'Expected composition with target cardinality $(VALUE) to have an ON-condition',
                     });
      }
    }
  });

  /**
   *
   * @param {CSN.Element} member The member
   * @returns {boolean} Whether the member is managed composition
   */
  function isManagedComposition( member ) {
    if (member.targetAspect)
      return true;
    if (!member.target)
      return false;
    const target = typeof member.target === 'object' ? member.target : this.csnUtils.getCsnDef(member.target);
    return target.kind !== 'entity';
  }
}

/**
 * All DB  & OData flat mode must reject recursive type usages in entities
 * 'items' break recursion as 'items' will turn into an NCLOB and the path
 * prefix to 'items' can be flattend in the DB.
 * In OData flat mode the first appearance of 'items' breaks out into structured
 * mode producing (legal) recursive complex types.
 *
 * @param {CSN.Artifact} art The artifact
 */
function checkRecursiveTypeUsage( art ) {
  const visit = (def) => {
    const loc = def.$path;
    // recursive types are allowed inside arrays
    if (def.items)
      return;
    let { type } = def;
    let prevType;
    let isDeref = false;
    if (type && !isBuiltinType(type) && !def.elements) {
      do {
        prevType = type;
        // TODO: `type.ref.length > 1`, but OData backend must be tested first (#5144)
        //  e.g. `{ ref: [ "MyType" ] }`
        if (type.ref) {
          def = this.artifactRef(type);
          isDeref = true;
        }
        else {
          def = this.csn.definitions[type];
        }
        type = def.type;
      } while (type && !isBuiltinType(type) && !def.items && !def.elements && prevType !== type);
    }
    if (def.$visited || (type && prevType === type)) {
      // Recursion via type is allowed in V4 struct, but not via dereferencing
      if (!isDeref && this.options.odataVersion === 'v4' && this.options.odataFormat === 'structured')
        return;
      if (!def.$recErr) {
        this.error(null, loc, {}, 'Unexpected recursive type definition');
        setProp(def, '$recErr', true);
      }
    }
    else if (def.elements) {
      setProp(def, '$visited', true);
      for (const n in def.elements)
        visit(def.elements[n]);
      delete def.$visited;
    }
  };
  // elements & params are flattening candidates
  // FUTURE:
  // Once we have universal CSN for the runtimes
  // Validate service members only for OData
  if (art.kind === 'entity') {
    for (const n in art.elements)
      visit(art.elements[n]);
    for (const n in art.params)
      visit(art.params[n]);
  }
  if (this.options.odataVersion) {
    // func/action params/returns don't allow recursive type derefs
    if (art.kind === 'action' || art.kind === 'function') {
      for (const n in art.params)
        visit(art.params[n]);
      if (art.returns)
        visit(art.returns);
    }
  }
}

/**
 * Member validator to check that certain annotations (@cds.valid { from, to, key }) are not
 * assigned to calculated elements in an entity.
 *
 * TODO: Allow @cds.valid on persisted calculated elements (when they become available).
 *
 * @param {CSN.Element} member the element to be checked
 * @param {string} _memberName the elements name
 * @param {string} _prop which kind of member are we looking at -> only prop "elements"
 * @param {CSN.Path} _path the path to the member
 */
function rejectAnnotationsOnCalcElement( member, _memberName, _prop, _path ) {
  if (this.artifact.kind === 'entity' && !(this.artifact.query && this.artifact.projection)) {
    if (member.value) {
      for (const anno in member) {
        if (anno.startsWith('@cds.valid.')) {
          this.error('anno-unexpected-temporal', member.$path, { anno },
                     'Unexpected $(ANNO) assigned to a calculated element');
        }
      }
    }
  }
}
module.exports = {
  checkPrimaryKey,
  checkVirtualElement,
  checkManagedAssoc,
  checkRecursiveTypeUsage,
  rejectAnnotationsOnCalcElement,
};
