'use strict';

const { forEachGeneric, applyTransformationsOnNonDictionary } = require('../model/csnUtils');

// Only to be used with validator.js - a correct this value needs to be provided!

/**
 * Validate select items of a query. If a column reference starts with $self or $projection, it must not contain association steps.
 * Furthermore, for to.hdbcds, window functions are not allowed.
 *
 * For to.hdbcds-hdbcds, structures and managed associations are not allowed as they are not flattened - @see rejectManagedAssociationsAndStructuresForHdbcdsNames
 *
 * @param {CSN.Query} query query object
 * @todo Why do we care about this with $self?
 */
function validateSelectItems( query ) {
  const { SELECT } = query;
  if (!SELECT)
    return;
  /**
   * Check for a $self.<assoc> in columns etc. - since the $self.<assoc> references the "outside" view
   * of the association, this is not allowed.
   *
   * @param {string} queryPart Part of the query that is being checked
   * @returns {Function} Function as callback for applyTransformations
   */
  function checkRefForInvalid$Self( queryPart ) {
    const signalError = (error, parent, type) => {
      if (queryPart === 'columns') {
        error(null, parent.$path,
              { name: parent.ref[0], type },
              'Select items starting with $(NAME) must not contain path steps of type $(TYPE)');
      }
      else if (queryPart === 'orderBy') {
        error(null, parent.$path,
              { id: queryPart, type },
              'Items of the $(ID)-clause must not contain path steps of type $(TYPE)');
      }
      else {
        error(null, parent.$path,
              { id: queryPart, name: parent.ref[0], type },
              'Items of the $(ID)-clause starting with $(NAME) must not contain path steps of type $(TYPE)');
      }
    };
    return function checkForInvalid$SelfInRef(parent) {
      if (parent.ref && (parent.$scope === '$self' || parent.$scope === '$query')) {
        const { _links } = parent;
        for (let j = parent.$scope === '$self' ? 1 : 0; j < _links.length - 1; j++) {
          if (_links[j].art.target) {
            if (_links[j].art.on) {
              // It's an unmanaged association - traversal is always forbidden
              signalError(this.error, parent, _links[j].art.type);
            }
            else {
              // It's a managed association - access of the foreign keys is allowed
              const nextRef = parent.ref[j + 1].id || parent.ref[j + 1];
              if (!_links[j].art.keys.some(r => r.ref[0] === nextRef))
                signalError(this.error, parent, _links[j].art.type);
            }
          }
        }

        const last = _links[_links.length - 1];

        if (last.art.target && last.art.on) {
          // It's an unmanaged association - traversal is always forbidden
          signalError(this.error, parent, last.art.type);
        } // managed is okay, can be handled via tuple expansion
      }
    };
  }

  /**
   * Check the given assoc filter for usage of $self - in an assoc-filter, you must only
   * address things on the target side of the association, not from global scope.
   *
   * @param {object} parent
   * @param {string} prop
   * @param {Array} where
   */
  function checkFilterForInvalid$Self( parent, prop, where ) {
    where.forEach((whereStep) => {
      if (whereStep.ref && ( whereStep.ref[0] === '$projection' || whereStep.ref[0] === '$self')) {
        this.error('expr-where-unexpected-self', whereStep.$path,
                   { name: whereStep.ref[0] },
                   'Path steps inside of filters must not start with $(NAME)');
      }
    });
  }

  const aTCB = (parent, prop) => {
    applyTransformationsOnNonDictionary(parent, prop, {
      ref: checkRefForInvalid$Self(prop).bind(this),
      where: checkFilterForInvalid$Self.bind(this),
    }, { skipStandard: { on: true }, drillRef: true });
  };

  const transformers = {
    columns: aTCB,
    groupBy: aTCB,
    orderBy: aTCB,
    having: aTCB,
    where: aTCB,
  };

  if (this.options.transformation === 'hdbcds') {
    transformers.xpr = (parent) => {
      if (parent.func) {
        this.error(null, parent.$path, {},
                   'Window functions are not supported by SAP HANA CDS');
      }
    };
  }

  applyTransformationsOnNonDictionary(query, 'SELECT', transformers );

  // .call() with 'this' to ensure we have access to the options
  rejectManagedAssociationsAndStructuresForHdbcdsNames.call(this, SELECT, SELECT.$path);
}


/**
 * For the to.hdbcds transformation with naming mode 'hdbcds', structures and managed associations are not flattened/resolved.
 * It is therefore not possible to publish such elements in a view.
 * This function iterates over all published elements of a query artifact and asserts that no such elements are published.
 *
 * @param {CSN.Artifact} queryArtifact the query artifact which should be checked
 * @param {CSN.Path} artifactPath the path to that artifact
 */
function rejectManagedAssociationsAndStructuresForHdbcdsNames( queryArtifact, artifactPath ) {
  if (this.options.transformation === 'hdbcds' && this.options.sqlMapping === 'hdbcds') {
    forEachGeneric(queryArtifact, 'elements', (selectItem, elemName, prop, elementPath) => {
      if (this.csnUtils.isManagedAssociation(selectItem))
        this.error('query-unexpected-assoc-hdbcds', elementPath);
      if (this.csnUtils.isStructured(selectItem))
        this.error('query-unexpected-structure-hdbcds', elementPath);
    }, artifactPath);
  }
}

module.exports = { validateSelectItems, rejectManagedAssociationsAndStructuresForHdbcdsNames };
