'use strict';

const edmUtils = require('./edmUtils.js');
const { setProp } = require('../base/model');
const { forEachGeneric } = require('../model/csnUtils');

/*
 * Late application specific transformations
 *  At present there are two transformation targets: Structure and Element
 *  These transformations are available today:
 *
 *  Analytical Scenario:
 *    If a structure is annotated with @Aggregation.ApplySupported.PropertyRestrictions
 *    then a number of annotation rewrites are done to this structure and to the
 *    elements of this structure
 *    Also the key properties of all structure elements are removed and a new
 *    artificial key element 'key _ID : String' is inserted at first position of
 *    the elements dictionary
 *
 * PDM (Personal Data Management)
 *    Planned but not yet implemented annotation rewriting (pending to finalization)
 */

/* eslint max-statements-per-line:off */

function mapAnnotationAssignment(artifact, parent, mappingDictionary)
{
  let props = edmUtils.intersect(Object.keys(mappingDictionary), Object.keys(artifact));
  // now start the substitution
  props.forEach(prop => {
    let [ mapping, value, remove_original ] = mappingDictionary[prop];
    if(mapping instanceof Function)
    {
      mapping(artifact, parent, prop);
    }
    else
    {
      edmUtils.assignAnnotation(artifact, mapping, value || artifact[prop]['='] || artifact[prop]);
    }

    if(remove_original)
      delete artifact[prop];
  });
}

function addToSetAttr(carrier, propName, propValue, removeFromType=true) {
  edmUtils.assignProp(carrier, '_SetAttributes', Object.create(null));
  edmUtils.assignAnnotation(carrier._SetAttributes, propName, propValue);
  if(removeFromType) {
    delete carrier[propName];
  }
}

function applyAppSpecificLateCsnTransformationOnElement(options, element, struct, error)
{
  if(options.isV2())
  {
    if(struct['@Aggregation.ApplySupported.PropertyRestrictions'])
    {
      mapAnnotationAssignment(element, struct, AnalyticalAnnotations());
    }
    mapAnnotationAssignment(element, struct, PDMSemantics());
  }

  // etag requires Core.OptimisticConcurrency to be set in V4 (cap/issues#2641)
  // Oliver Heinrich mentions in the issue that the Okra runtime must be set to a
  // concurrent runtime mode by the caller, if the annotation is added this late,
  // it doesn't appear in the forOData processed CSN, meaning that the
  // runtime cannot set that okra flag (alternatively the runtime has to search
  // for @[odata|cds].etag annotations...
  if(options.isV4())
  {
    // eslint-disable-next-line sonarjs/no-redundant-boolean
    if(element['@odata.etag'] == true || element['@cds.etag'] == true) {
      // don't put element name into collection as per advice from Ralf Handl, as
      // no runtime is interested in the property itself, it is sufficient to mark
      // the entity set.
      edmUtils.assignAnnotation(struct, '@Core.OptimisticConcurrency',
        (struct['@Core.OptimisticConcurrency'] || [])/*.push(element.name)*/);
    }
  }

  // nested functions begin
  function PDMSemantics()
  {
    /*
    let dict = Object.create(null);

    dict['@PDM.xxx1'] = [ '@sap.pdm-semantics' ];
    dict['@PDM.xxx2'] = [ '@sap.pdm-propery' ];
    dict['@PDM.xxx3'] = [ '@sap.pdm-display-sq-no' ];
    dict['@PDM.xxx4'] = [ '@sap.pdm-record-identifier' ];
    dict['@PDM.xxx5'] = [ '@sap.pdm-field-group' ];
    dict['@PDM.xxx6'] = [ '@sap.pdm-mask-find-pattern' ];
    dict['@PDM.xxx7'] = [ '@sap.pdm-mask-replacement-pattern' ];
    dict['@PDM.xxx8'] = [ '@sap.deletable' ];
    dict['@PDM.xxx8'] = [ '@sap.updatable' ];

    // respect flattened annotation $value
    Object.keys(dict).forEach(k => dict[k+'.$value'] = dict[k]);
    */
    return Object.create(null);
  }

  function AnalyticalAnnotations()
  {
    function mapCommonAttributes(element, struct, prop)
    {
      let CommonAttributes = element[prop];
      if(!Array.isArray(CommonAttributes)) {
        error(null, ['definitions', struct.name, 'elements', element.name],
          { anno: '@Common.Attributes', code: JSON.stringify(CommonAttributes) },
          'Expecting array value for $(ANNO): $(CODE)');
        return;
      }

      let targets = edmUtils.intersect(CommonAttributes, Object.keys(struct.elements));
      targets.forEach(tgt => {
        edmUtils.assignAnnotation(struct.elements[tgt], '@sap.attribute-for', element.name);
      });
    }

    function mapContextDefiningProperties(element, struct, prop)
    {
      let ContextDefiningProperties = element[prop];
      if(!Array.isArray(ContextDefiningProperties)) {
        error(null, ['definitions', struct.name, 'elements', element.name],
          { anno: '@Aggregation.ContextDefiningProperties', code: JSON.stringify(ContextDefiningProperties) },
          'Expecting array value for $(ANNO): $(CODE)');
        return;
      }
      if(ContextDefiningProperties.length > 0)
        edmUtils.assignAnnotation(element, '@sap.super-ordinate', ContextDefiningProperties[ContextDefiningProperties.length-1]);
    }

    let dict = Object.create(null);
    //analytics term definition unknown, lower case
    dict['@Analytics.Measure'] = [ '@sap.aggregation-role', 'measure' ];
    dict['@Analytics.Dimension'] = [ '@sap.aggregation-role', 'dimension' ];
    dict['@Semantics.currencyCode'] = [ '@sap.semantics', 'currency-code', true ];
    dict['@Semantics.unitOfMeasure'] = [ '@sap.semantics', 'unit-of-measure', true ];

    dict['@Measures.ISOCurrency'] = [ '@sap.unit' ];
    dict['@Measures.Unit'] = [ '@sap.unit' ];

    dict['@Common.Label'] = [ '@sap.label' ];
    dict['@Common.Text'] = [ '@sap.text' ];
    dict['@Aggregation.ContextDefiningProperties'] = [ mapContextDefiningProperties ];
    dict['@Common.Attributes'] = [ mapCommonAttributes ];

    // respect flattened annotation $value
    Object.entries(dict).forEach(([k, v]) => dict[k+'.$value'] = v);
    return dict;
  }
}

function applyAppSpecificLateCsnTransformationOnStructure(options, struct, error)
{
  if(options.isV2())
  {
    if(struct['@Aggregation.ApplySupported.PropertyRestrictions'])
    {
      transformAnalyticalModel(struct);
      mapAnnotationAssignment(struct, undefined, AnalyticalAnnotations());
    }
  }

  // nested functions begin
  function transformAnalyticalModel(struct)
  {
    let keyName = 'ID__';
    if(struct == undefined || struct.elements == undefined || struct.elements[keyName] != undefined)
      return;

    // remove key prop from elements, add new key to elements
    let elements = Object.create(null);
    let key =  { name: keyName, key : true, type : 'cds.String', '@sap.sortable':false, '@sap.filterable':false, '@UI.Hidden': true };
    elements[keyName] = key;
    setProp(struct, '$keys',{ [keyName] : key } );
    forEachGeneric(struct.items || struct, 'elements', (e,n) =>
    {
      if(e.key) delete e.key;
      elements[n] = e;
    });
    struct.elements = elements;
  }

  function AnalyticalAnnotations()
  {
    function mapFilterRestrictions(struct, parent, prop)
    {
      let stringDict = Object.create(null);
      stringDict['SingleValue'] = 'single-value';
      stringDict['MultiValue'] = 'multi-value';
      stringDict['SingleRange'] = 'interval';

      let filterRestrictions = struct[prop];
      if(!Array.isArray(filterRestrictions)) {
        error(null, ['definitions', struct.name ],
          { anno: '@Capabilities.FilterRestrictions.FilterExpressionRestrictions',
            code: JSON.stringify(filterRestrictions) },
          'Expected array value for $(ANNO): $(CODE)');
        return;
      }
      filterRestrictions.forEach(v => {
        let e = struct.elements[v.Property];
        if(e)
          edmUtils.assignAnnotation(e, '@sap.filter-restriction', stringDict[v.AllowedExpressions]);
      });
    }

    function mapRequiredProperties(struct, parent, prop)
    {
      let requiredProperties = struct[prop];
      if(!Array.isArray(requiredProperties)) {
        error(null, ['definitions', struct.name],
          { anno: '@Capabilities.FilterRestrictions.RequiredProperties',
            code: JSON.stringify(requiredProperties) },
          'Expecting array value for $(ANNO): $(CODE)');
        return;
      }

      let props = edmUtils.intersect(Object.keys(struct.elements), requiredProperties)
      props.forEach(p => {
        edmUtils.assignAnnotation(struct.elements[p], '@sap.required-in-filter', true);
      });
    }

    function mapRequiresFilter(struct, parent, prop)
    {
      let requiresFilter = struct[prop];
      if(requiresFilter)
        edmUtils.assignAnnotation(struct._SetAttributes, '@sap.requires-filter', requiresFilter);
    }

      // Entity Props
    let dict = Object.create(null);
    dict['@Aggregation.ApplySupported.PropertyRestrictions'] = [ '@sap.semantics', 'aggregate' ];
    dict['@Common.Label'] = [ '@sap.label' ];
    dict['@Capabilities.FilterRestrictions.RequiresFilter'] = [ mapRequiresFilter ];
    dict['@Capabilities.FilterRestrictions.RequiredProperties'] = [ mapRequiredProperties ];
    dict['@Capabilities.FilterRestrictions.FilterExpressionRestrictions'] = [ mapFilterRestrictions ];

    // respect flattened annotation $value
    Object.keys(dict).forEach(k => dict[k+'.$value'] = dict[k]);

    return dict;
  }
}

function setSAPSpecificV2AnnotationsToEntityContainer(options, carrier) {
  if(!options.isV2())
    return;
  // documented in https://wiki.scn.sap.com/wiki/display/EmTech/SAP+Annotations+for+OData+Version+2.0#SAPAnnotationsforODataVersion2.0-Elementedm:EntityContainer
  const SetAttributes = {
    // EntityContainer only
    '@sap.supported.formats' : addToSetAttr,
    '@sap.use.batch': addToSetAttr,
    '@sap.message.scope.supported': addToSetAttr,
  };

  Object.entries(carrier).forEach(([p, v]) => {
    (SetAttributes[p] || function() { /* no-op */ })(carrier, p, v);
  });
}

function setSAPSpecificV2AnnotationsToEntitySet(options, carrier) {
  if(!options.isV2())
    return;
  // documented in https://wiki.scn.sap.com/wiki/display/EmTech/SAP+Annotations+for+OData+Version+2.0#SAPAnnotationsforODataVersion2.0-Elementedm:EntitySet
  const SetAttributes = {
    // EntitySet, EntityType
    '@sap.label' : (s,pn, pv) => { addToSetAttr(s, pn, pv, false); },
    '@sap.semantics': checkSemantics,
    // EntitySet only
    '@sap.creatable' : addToSetAttr,
    '@sap.updatable' : addToSetAttr,
    '@sap.deletable': addToSetAttr,
    '@sap.updatable.path': addToSetAttr,
    '@sap.deletable.path': addToSetAttr,
    '@sap.searchable' : addToSetAttr,
    '@sap.pagable': addToSetAttr,
    '@sap.topable': addToSetAttr,
    '@sap.countable': addToSetAttr,
    '@sap.addressable': addToSetAttr,
    '@sap.requires.filter': addToSetAttr,
    '@sap.change.tracking': addToSetAttr,
    '@sap.maxpagesize': addToSetAttr,
    '@sap.delta.link.validity': addToSetAttr,
  };

  Object.entries(carrier).forEach(([p, v]) => {
    (SetAttributes[p] || function() { /* no-op */ })(carrier, p, v);
  });

  function checkSemantics(struct, propName, propValue) {
    if(propValue === 'timeseries' || propValue === 'aggregate') {
      // aggregate is forwarded to Set and must remain on Type
      addToSetAttr(struct, propName, propValue, propValue !== 'aggregate');
    }
  }
}

function setSAPSpecificV2AnnotationsToAssociation(carrier) {
  // documented in https://wiki.scn.sap.com/wiki/display/EmTech/SAP+Annotations+for+OData+Version+2.0
  const SetAttributes = {
    // Applicable to NavProp and foreign keys, add to AssociationSet
    '@sap.creatable' : (c, pn, pv) => { addToAssociationSet(c, pn, pv, false); },
    // Not applicable to NavProp, applicable to foreign keys, add to AssociationSet
    '@sap.updatable' : addToAssociationSet,
    // Not applicable to NavProp, not applicable to foreign key, add to AssociationSet
    '@sap.deletable': (c, pn, pv) => {
      addToAssociationSet(c, pn, pv);
      removeFromForeignKey(c, pn);
    },
    // applicable to NavProp, not applicable to foreign keys, not applicable to AssociationSet
    '@sap.creatable.path': removeFromForeignKey,
    '@sap.filterable': removeFromForeignKey,
  };

  Object.entries(carrier).forEach(([p, v]) => {
    (SetAttributes[p] || function() {/* no-op */})(carrier, p, v);
  });

  function addToAssociationSet(carrier, propName, propValue, removeFromType=true) {
    if(carrier.target) {
      edmUtils.assignProp(carrier, '_SetAttributes', Object.create(null));
      edmUtils.assignAnnotation(carrier._SetAttributes, propName, propValue);
      if(removeFromType) {
        delete carrier[propName];
      }
    }
  }

  function removeFromForeignKey(carrier, propName) {
    if(carrier['@odata.foreignKey4'] && carrier[propName] !== undefined) {
      delete carrier[propName];
    }
  }
}



module.exports = {
  applyAppSpecificLateCsnTransformationOnElement,
  applyAppSpecificLateCsnTransformationOnStructure,
  setSAPSpecificV2AnnotationsToEntityContainer,
  setSAPSpecificV2AnnotationsToEntitySet,
  setSAPSpecificV2AnnotationsToAssociation
};
