'use strict';

const { setProp, isBetaEnabled } = require('../base/model');
const {
  forEachDefinition, forEachMemberRecursively,
} = require('../model/csnUtils');

// eslint-disable-next-line no-unused-vars
function resolveForeignKeyRefs(csn, csnUtils) {
  forEachDefinition(csn, (def, defName) => {
    let currPath = ['definitions', defName ];
    forEachMemberRecursively(def, (construct, _constructName, _prop, path) => {
      if(construct.target && construct.keys) {
        construct.keys.forEach((fk, i) => {
          setProp(fk, '_artifact', csnUtils.inspectRef([...path, 'keys', i]).art);
        });
      }
    }, currPath, true, { elementsOnly: true });
  });
}


function inboundQualificationChecks(csn, options, messageFunctions,
  serviceRootNames, requestedServiceNames, isMyServiceRequested, whatsMyServiceRootName, csnUtils) {
  const { message, throwWithError } = messageFunctions;

  forEachDefinition(csn, [ attach$path, checkChainedArray ]);
  checkNestedContextsAndServices();
  throwWithError();

    // attach $path to all
  function attach$path(def, defName) {
    setProp(def, '$path', [ 'definitions', defName ]);
    forEachMemberRecursively(def,
        (member, _memberName, _prop, path) => {
          setProp(member, '$path', path);
        }, [ 'definitions', defName ]);
  }

  function checkChainedArray(def, defName) {
    if (!isMyServiceRequested(defName))
      return;
    let currPath = ['definitions', defName];
    checkIfItemsOfItems(def, undefined, undefined, currPath);
    forEachMemberRecursively(def, checkIfItemsOfItems, currPath);

    function checkIfItemsOfItems(construct, _constructName, _prop, path) {
      const constructType = csnUtils.effectiveType(construct);
      if (constructType.items) {
        if (constructType.items.items) {
          message('chained-array-of', path);
          return;
        }

        const itemsType = csnUtils.effectiveType(constructType.items);
        if (itemsType.items)
          message('chained-array-of', path);
      }
    }
  }

  function checkNestedContextsAndServices() {
    !isBetaEnabled(options, 'nestedServices') && serviceRootNames.forEach(sn => {
      const parent = whatsMyServiceRootName(sn, false);
      if(parent && requestedServiceNames.includes(parent) && parent !== sn) {
        message( 'service-nested-service', [ 'definitions', sn ], { art: parent },
               'A service can\'t be nested within a service $(ART)' );
      }
    });

    Object.entries(csn.definitions).forEach(([fqName, art]) => {
      if(art.kind === 'context') {
        const parent = whatsMyServiceRootName(fqName);
        if(requestedServiceNames.includes(parent)) {
          message( 'service-nested-context', [ 'definitions', fqName ], { art: parent },
               'A context can\'t be nested within a service $(ART)' );
        }
      }
    });
  }
}

module.exports = { inboundQualificationChecks }
