// Propagate properties in XSN

// See also internalDoc/PropagatedCsn.md.
// As opposed to that document, the propagator here works on XSN, not CSN.
// We also do not deep-copy member dictionaries here, but create proxy members
// which get their properties via propagation: we use function `onlyViaParent`
// if that property would not be propagated otherwise.

'use strict';

const {
  forEachDefinition,
  forEachMember,
  forEachGeneric,
  isDeprecatedEnabled,
  isBetaEnabled,
} = require( '../base/model');
const {
  setLink,
  linkToOrigin,
  withAssociation,
  viewFromPrimary,
} = require('./utils');
const $inferred = Symbol.for('cds.$inferred');
// const { refString } = require( '../base/messages')

// Note that propagation here is also used for deep-copying (function `onlyViaParent`)
function propagate( model ) {
  const props = {
    '@com.sap.gtt.core.CoreModel.Indexable': never,
    '@cds.persistence.exists': never,
    '@cds.persistence.table': never,
    '@cds.persistence.calcview': never,
    '@cds.persistence.udf': never,
    '@cds.persistence.skip': notWithPersistenceTable,
    '@sql.append': never,
    '@sql.prepend': never,
    '@sql.replace': never,
    '@Analytics.hidden': never,
    '@Analytics.visible': never,
    '@cds.autoexpose': onlyViaArtifact,
    '@cds.autoexposed': never,  // in case people set it themselves
    '@cds.external': never,
    '@cds.redirection.target': never,
    '@fiori.draft.enabled': onlyViaArtifact,
    '@': annotation,            // always except in 'items'
    doc: annotation,            // always except in 'items'
    default: withKind,          // always except in 'items'
    virtual,
    notNull,
    targetElement: onlyViaParent, // in foreign keys
    value: onlyViaParent,      // enum symbol value
    // masked: special = done in definer
    // key: special = done in resolver
    // actions: struct includes & primary source = in definer/resolver
    type: notWithExpand,
    length: always,
    precision: always,
    scale: always,
    srid: always,
    localized: always,
    target: notWithExpand,
    targetAspect: notWithExpand,
    cardinality: notWithExpand,
    on: notWithExpand,
    foreignKeys: expensive,    // includes "notWithExpand", dictionary copy
    items,
    elements: expensive,
    enum: expensive,
    params: expensive,          // actually only with parent action
    returns,
  };
  const { options } = model;
  // eslint-disable-next-line max-len
  const oldVirtualNotNullPropagation = isDeprecatedEnabled( options, '_oldVirtualNotNullPropagation' );
  const { warning, throwWithError } = model.$messageFunctions;
  const propagateToReturns = isBetaEnabled( options, 'v4preview' );

  forEachDefinition( model, run );

  // TODO: move 'virtual' handling/checks to resolver if
  //       'deprecated.oldVirtualNotNullPropagation' is gone
  if (!oldVirtualNotNullPropagation) // check would always be right, but to be ultra compatibleâ€¦
    forEachDefinition( model, checkVirtual );
  throwWithError();
  return model;

  function run( art ) {
    if (!art)
      return;
    if (!checkAndSetStatus( art ) || art.kind === 'select') {
      runMembers( art );
      return;
    }
    // console.log('RUN:', art.name, art.elements ? Object.keys(art.elements) : 0)

    const chain = [];
    let targets = [ art ];
    while (targets.length) {
      const news = [];
      for (const target of targets) {
        const origin = getOrigin( target );
        if (origin) {
          // Calculated elements that are simple references: `calc = field;`.
          // Respect sibling properties in inheritance.
          if (target._calcOrigin?._origin && target.value?._artifact) {
            chain.push({ target, source: target.value._artifact });
            if (checkAndSetStatus( target.value._artifact ))
              news.push(target.value._artifact);

            if (target.value?._artifact.$inferred !== 'include') {
              // If the referred to element is not inferred, it is a new one and not the original.
              // The new one was not originally referred to => error;
              warning( 'ref-unexpected-override', [ target.name.location, target ],
                       { id: target.name.id, target: target.value?._artifact },
                       'Calculated element $(ID) does not originally refer to $(TARGET)' );
            }
          }
          chain.push( { target, source: origin } );
          if (checkAndSetStatus( origin ))
            news.push( origin );
        }

        for (const ref of target.includes || []) {
          const include = ref._artifact;
          if (!include)
            continue;
          chain.push( { target, source: include } );
          if (checkAndSetStatus( include ))
            news.push( include );
        }
      }
      targets = news;
    }

    chain.reverse();
    chain.forEach( step );
    runMembers( art );
    // console.log('DONE:', art.name, art.elements ? Object.keys(art.elements) : 0);
  }

  function runMembers( art ) {
    // console.log('MEMBERS:',refString(art), art.elements ? Object.keys(art.elements) : 0)
    forEachMember( art, run ); // after propagation in parent!
    // propagate to sub query elements even if not requested:
    if (art.$queries)
      art.$queries.forEach( run );
    let obj = art;
    if (art.returns) {
      obj = art.returns;
      run( obj );
    }
    if (obj.items)
      run( obj.items );
    setLink( art, '_status', 'propagated' );
  }

  function step({ target, source }) {
    // console.log('PROPS:',source&&source.name,'->',target.name)
    const viaType = target.type && // TODO: falsy $inferred value instead 'cast'?
          (!target.type.$inferred || target.type.$inferred === 'cast');
    const keys = Object.keys( source );
    for (const prop of keys) {
      if (prop in target)       // TODO: warning with competing props from multi-includes
        continue;
      const transformer = props[prop] || props[prop.charAt(0)];
      if (transformer)
        transformer( prop, target, source, viaType );
    }
    // propagate NOT NULL and VIRTUAL from sub elements with
    // 'deprecated.oldVirtualNotNullPropagation':
    if (oldVirtualNotNullPropagation &&
        target.$inferred !== 'proxy' &&
        target.kind === 'element' && source.kind === 'element') {
      let elem = source;        // the outer element
      while (elem._parent.kind === 'element')
        elem = elem._parent;
      if (elem !== source) {
        if (!('notNull' in target) && ('notNull' in elem))
          props.notNull( 'notNull', target, elem );
        if (!('virtual' in target) && ('virtual' in elem))
          props.virtual( 'virtual', target, elem );
      }
    }
    // setLink( target, '_status', 'shallow-propagated' );
  }

  function never() { /* no-op: don't propagate */ }

  function always( prop, target, source ) {
    const val = source[prop];
    if (Array.isArray( val )) {
      target[prop] = [ ...val ];
      target[prop].$inferred = 'prop';
    }
    else {
      target[prop] = Object.assign( {}, val, { $inferred: 'prop' } );
      if (val._artifact !== undefined)
        setLink( target[prop], '_artifact', val._artifact );
      if (val._outer !== undefined)
        setLink( target[prop], '_outer', val._outer );
      if (val._parent !== undefined)
        setLink( target[prop], '_parent', val._parent );
      if (val._main !== undefined)
        setLink( target[prop], '_main', val._main );
    }
  }

  function availableAtType( prop, target, source ) {
    if (target.kind === 'type')
      return false;
    const ref = target.type || source.type;
    const type = ref && ref._artifact;
    if (!type || type._main)
      return false;
    // We do not consider the $expand status, as elements are already expanded
    // by the resolve()
    run( type );
    return type[prop];
  }

  // Expensive properties are not really propagated if they can be directly
  // accessed at their type being a main artifact
  // Expensive properties are also not propagated with `expand`:
  // * `elements`: the compiler calculates its own `elements` for a structure
  //   ref with `expand`.
  // * `params`: no element has parameters
  // * `enum`: an enum cannot be used with `expand`
  // * `keys`: should also not be propagated with `expand`
  function expensive( prop, target, source ) {
    // console.log(prop,source.name,'->',target.kind,target.name);
    if (source.kind === 'builtin')
      return;
    if (target.expand)          // do not propagate `keys` with expand
      return;
    if (prop !== 'foreignKeys' && availableAtType( prop, target, source ))
      // foreignKeys must always be copied with target to avoid any confusion
      // whether we have to generated implicit keys
      return;
    if (prop === 'params' && target.$inferred !== 'proxy' && target.$inferred !== 'include')
      return;
    const location = target.type && !target.type.$inferred && target.type.location ||
                target.location ||
                target._outer && target._outer.location;
    const dict = source[prop];
    target[prop] = Object.create(null); // also propagate empty elements
    for (const name in dict) {
      const member = linkToOrigin( dict[name], name, target, prop, location );
      member.$inferred = 'proxy';
      setEffectiveType(member, dict[name]);
    }
    target[prop][$inferred] = 'prop';
  }

  function onlyViaParent( prop, target, source ) {
    if (target.$inferred === 'proxy' || target.$inferred === 'expanded')
      // assocs and enums do not have 'include'
      always( prop, target, source );
  }

  function notWithExpand( prop, target, source ) {
    if (!target.expand || prop === 'type' && source.elements)
      always( prop, target, source );
  }

  function notWithPersistenceTable( prop, target, source ) {
    const tableAnno = target['@cds.persistence.table'];
    if (!tableAnno || tableAnno.val === null)
      annotation( prop, target, source );
  }

  function annotation( prop, target, source ) {
    const anno = source[prop];
    if (anno.val !== null)
      withKind( prop, target, source );
  }

  function onlyViaArtifact( prop, target, source ) {
    const from = viewFromPrimary( target )?.path;
    // do not propagate from member / if follow assoc in from or into `returns` of actions (v4)
    if (!(from ? from[from.length - 1]._artifact : source)._main &&
       !(propagateToReturns && target._parent && target._parent.returns === target))
      annotation( prop, target, source );
  }

  function withKind( prop, target, source ) {
    if (target.kind &&
      (propagateToReturns || !target._parent || target._parent.returns !== target))
      always(prop, target, source); // not in 'items'
  }

  function notNull( prop, target, source, viaType ) {
    // Really "reset" NOT NULL when ref has assoc with cardinality min: 0 (TODO: Universal CSN)
    if (oldVirtualNotNullPropagation && viaType)
      return;                   // strange propagation not supported with Universal CSN
    if (target.value && withAssociation( target.value, targetMinZero ))
      target[prop] = { $inferred: 'NULL', val: undefined }; // set null value in Universal CSN
    // $inferred: 'NULL' is only an issue for sub elements with a 'value' property;
    // it only exists with nested projections, i.e. never with deprecated option enabled
    else
      always( prop, target, source );
  }

  function virtual( prop, target, source, viaType ) {
    if (!viaType)
      always( prop, target, source );
    else if (!oldVirtualNotNullPropagation) // NULL would block strange propagation to sub element
      target[prop] = { $inferred: 'NULL', val: undefined }; // set null value in Universal CSN
  }

  function checkVirtual( view ) {
    if (view.query)
      forEachGeneric( view, 'elements', checkNonVirtualElement );
  }

  function checkNonVirtualElement( elem ) {
    // Not enough at all, but so are the current checks - a complete expression
    // must be checked.  Here we just check what might have worked before.
    // TODO: Propagate 'virtual' in resolver if 'deprecated.oldVirtualNotNullPropagation' is gone.
    const path = !elem.virtual && elem.value && elem.value.path;
    if (!path || path.broken)
      return;
    for (const item of path) {
      const art = item && item._artifact;
      if (art && art.virtual && art.virtual.val) {
        warning( 'def-missing-virtual', [ item.location, elem ], { art, keyword: 'virtual' },
                 // eslint-disable-next-line max-len
                 'Prepend $(KEYWORD) to current select item - referred element $(ART) is virtual which is not inherited' );
        return;
      }
    }
  }

  function returns( prop, target, source, ok ) {
    if (ok || target.$inferred === 'proxy' || target.$inferred === 'include' ) {
      target[prop] = { $inferred: 'proxy' };
      setEffectiveType( target[prop], source[prop] );
      setLink( target[prop], '_origin', source[prop] );
      setLink( target[prop], '_outer', target._outer || target ); // for setMemberParent
    }
  }

  function items( prop, target, source ) {
    // usually considered expensive, except:
    // - array of Entity
    const line = availableAtType( prop, target, source );
    if (!line ||
        line.type && line.type._artifact && line.type._artifact.kind === 'entity')
      returns( prop, target, source, true );
  }
}

function targetMinZero( art ) {
  // Semantics of associations without provided cardinality: [*,0..1]
  return !(art.cardinality && art.cardinality.targetMin && art.cardinality.targetMin.val);
}

function getOrigin( art ) {
  let origin = art._origin;
  while (origin?.kind === 'select')
    origin = origin._origin;
  if (origin)
    // Do not consider _origin if due to expand of table alias ref
    return (!art.expand || origin.kind === 'element') && origin;
  // Remark: a column with an 'inline' is never an element -> no need to check
  // art.inline

  return (art.type && (!art.type.$inferred || art.type.$inferred === 'cast'))
    ? art.type._artifact
    : art._origin;
}

function checkAndSetStatus( art ) {
  if (art._status === 'propagated' || art._status === 'propagating')
    return false;
  setLink( art, '_status', 'propagating' );
  return true;
}

function setEffectiveType( target, source ) {
  if (source._effectiveType !== undefined)
    setLink( target, '_effectiveType', source._effectiveType);
}

module.exports = {
  propagate,
};
