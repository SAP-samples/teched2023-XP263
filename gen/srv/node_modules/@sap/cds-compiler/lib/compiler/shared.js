// Compiler functions and utilities shared across all phases
// TODO: rename to paths.js and move non resolve-paths functions to somewhere else

'use strict';

const { searchName } = require('../base/messages');
const { isDeprecatedEnabled } = require('../base/model');

const {
  setLink,
  setArtifactLink,
  dependsOn,
  pathName,
} = require('./utils');

function artifactsEnv( art ) {
  return art._subArtifacts || Object.create(null);
}

/**
 * Main export function of this file.  Attach "resolve" functions shared for phase
 * "define" and "resolve" to `model.$functions`, where argument `model` is the XSN.
 *
 * Before calling these functions, make sure that the following function
 * in model.$volatileFunctions is set:
 * - `environment`: a function which returns the search environment defined by
 *    its argument, e.g. a function which returns the dictionary of subartifacts.
 *
 * @param {XSN.Model} model
 */
// TODO: yes, this function will be renamed
function fns( model ) {
  const { options } = model;
  const {
    info, warning, error, message,
  } = model.$messageFunctions;
  // TODO: combine envFn and assoc ?
  const specExpected = {
    global: { // for using declaration
      envFn: artifactsEnv,
      artItemsCount: Number.MAX_SAFE_INTEGER,
      useDefinitions: true,
      global: 'definitions',
    },
    // TODO: re-check --------------------------------------------------------
    annotation: { useDefinitions: true, noMessage: true, global: 'vocabularies' },
    // TODO: artifact references ---------------------------------------------
    extend: {
      useDefinitions: true,
      envFn: artifactsEnv,
      artItemsCount: Number.MAX_SAFE_INTEGER,
    },
    // ref in top-level EXTEND
    annotate: {
      useDefinitions: true,
      envFn: artifactsEnv,
      artItemsCount: Number.MAX_SAFE_INTEGER,
      undefinedDef: 'anno-undefined-def',
      undefinedArt: 'anno-undefined-art',
      allowAutoexposed: true,   // TODO: think about Info/Warning
      noMessageForLocalized: true, // TODO: should we issue a Debug message for code completion?
    },
    type: { // TODO: more detailed later (e.g. for enum base type?)
      envFn: artifactsEnv,
      check: checkTypeRef,
      expectedMsgId: 'expected-type',
      sloppyMsgId: 'ref-sloppy-type',
      deprecateSmart: true,
    },
    actionParamType: {
      envFn: artifactsEnv,
      check: checkActionParamTypeRef,
      expectedMsgId: 'expected-actionparam-type',
      sloppyMsgId: 'ref-sloppy-actionparam-type',
      deprecateSmart: true,
    },
    eventType: {
      envFn: artifactsEnv,
      check: checkEventTypeRef,
      expectedMsgId: 'expected-event-type',
      sloppyMsgId: 'ref-sloppy-event-type',
      deprecateSmart: true,
    },
    include: {
      check: checkIncludesRef,
      expectedMsgId: 'expected-struct',
      envFn: artifactsEnv,
    },
    viewInclude: {
      check: checkViewIncludesRef,
      expectedMsgId: 'ref-expecting-bare-aspect',
      envFn: artifactsEnv,
    },
    target: {
      check: checkEntityRef,
      expectedMsgId: 'expected-entity',
      noDep: true,
      envFn: artifactsEnv,
    },
    compositionTarget: {
      check: checkTargetRef,
      expectedMsgId: 'expected-target',
      sloppyMsgId: 'ref-sloppy-target',
      noDep: 'only-entity',
      envFn: artifactsEnv,
    },
    from: {
      envFn: artifactsEnv,
      check: checkSourceRef,
      expectedMsgId: 'expected-source',
      assoc: 'from',
      argsSpec: 'expr',
      deprecateSmart: true,
    },
    // element references ----------------------------------------------------
    // if we want to disallow assoc nav for TYPE, do not do it here
    typeOf: { next: '_$next', dollar: true }, // TODO: disallow in var
    // TODO: dep for (explicit+implicit!) foreign keys
    targetElement: { next: '__none_', assoc: false, dollar: false },
    filter: {
      next: '_$next', lexical: 'main', dollar: 'none', escape: 'param',
    },
    default: {
      next: '_$next',
      dollar: true,
      check: checkConstRef,
      expectedMsgId: 'expected-const',
    },
    expr: {                     // in: from-on,
      next: '_$next', dollar: true, escape: 'param', assoc: 'nav',
    },
    exists: { // same as expr
      next: '_$next', dollar: true, escape: 'param', assoc: 'nav',
    },
    'approved-exists': { // same as expr
      next: '_$next', dollar: true, escape: 'param', assoc: 'nav',
    },
    on: {               // TODO: there will also be a 'from-on' (see 'expr')
      noAliasOrMixin: true,     // TODO: some headReject or similar
      next: '_$next',           // TODO: lexical: ... how to find the (next) lexical environment
      dollar: true,
      rootEnv: 'elements',      // the final environment for the path root
      noDep: true,              // do not set dependency for circular-check
      allowSelf: true,
    }, // TODO: special assoc for only on user
    'mixin-on': {
      escape: 'param',    // TODO: extra check that assocs containing param in ON is not published
      next: '_$next',           // TODO: lexical: ... how to find the (next) lexical environment
      dollar: true,
      noDep: true,              // do not set dependency for circular-check
      allowSelf: true,
    }, // TODO: special assoc for only on user
    rewrite: {
      next: '_$next',
      dollar: true,
      escape: 'param',
      noDep: true,
      allowSelf: true,
      rewrite: true,
    }, // TODO: assertion that there is no next/escape used
    'order-by': {
      next: '_$next',
      dollar: true,
      escape: 'param',
      assoc: 'nav',
      deprecatedSourceRefs: true,
    },
    'order-by-union': {
      next: '_$next',
      dollar: true,
      escape: 'param',
      noDep: true,
      noExt: true,
    },
    // expr TODO: better - on condition for assoc, other on
    // expr TODO: write dependency, but care for $self
    param: {
      check: checkConstRef,
      expectedMsgId: 'expected-const',
    },
  };

  const VolatileFns = model.$volatileFunctions;
  Object.assign( model.$functions, {
    resolveUncheckedPath,
    resolveTypeArgumentsUnchecked,
    resolvePath,
    attachAndEmitValidNames,
  } );
  return;

  function checkConstRef( art ) {
    return art.kind !== 'builtin' && art.kind !== 'param';
  }

  function checkIncludesRef( art ) {
    // We currently disallow using
    // - derived structure types: would have to follow type in extend/include;
    // - entities with params: clarify inheritance, use of param in ON/DEFAULT;
    // - query entities/events: difficult sequence of resolve steps
    // - aspect without elements (useful for actions/annotations)
    return !(art.elements && !art.query && !art.type && !art.params) && art.kind !== 'aspect';
  }

  /**
   * Returns true, if the given artifact can be included by a query entity / view.
   *
   * We currently allow:
   * - aspects without elements (the aspect may have actions):
   *   either no `elements` property or empty dictionary
   *
   * @param {XSN.Artifact} art
   * @return {boolean}
   */
  function checkViewIncludesRef( art ) {
    return !(art.kind === 'aspect' && (!art.elements || Object.keys(art.elements).length === 0));
  }

  /**
   * @returns {boolean|string}
   */
  function checkTypeRef( art ) {
    if (art.kind === 'type' || art.kind === 'element')
      return false;
    return ![ 'entity', 'aspect', 'event' ].includes( art.kind ) || 'sloppy';
  }

  /**
   * @returns {boolean|string}
   */
  function checkActionParamTypeRef( art ) {
    return !(art.kind === 'entity' && art._service) && checkTypeRef( art );
  }

  /**
   * @returns {boolean|string}
   */
  function checkEventTypeRef( art ) {
    return art.kind !== 'event' && checkActionParamTypeRef( art );
  }

  function checkEntityRef( art ) {
    return art.kind !== 'entity';
  }

  /**
   * @returns {boolean|string}
   */
  function checkTargetRef( art ) {
    if (art.kind === 'entity' || art.kind === 'aspect')
      return false;
    return art.kind !== 'type' || 'sloppy';
  }

  function checkSourceRef( art, path ) { // for FROM
    if (!art._main)
      return (art.kind !== 'entity');
    const elem = path.find( item => item._artifact._main )._artifact;
    // at least the last main definition should be an entity
    // an additional check for target would need effectiveType()
    return (elem && elem._main.kind !== 'entity');
  }

  // Return absolute name for unchecked path `ref`.  We first try searching for
  // the path root starting from `env`.  If it exists, return its absolute name
  // appended with the name of the rest of the path and set `ref.absolute` to
  // the return value.  Otherwise, complain if `unchecked` is false, and set
  // `ref.absolute` to the path name of `ref`.
  // Used for collecting artifact extension, and annotation assignments.
  function resolveUncheckedPath( ref, expected, user ) {
    if (!ref.path || ref.path.broken) // incomplete type AST
      return undefined;
    if (ref._artifact)
      return ref._artifact.name.absolute;
    const spec = specExpected[expected];
    let art = (ref.scope === 'global' || spec.global)
      ? getPathRoot( ref.path, spec, user, {}, model[spec.global || 'definitions'] )
      : getPathRoot( ref.path, spec, user, user._block, null, true );
    if (art === false)          // redefinitions
      art = ref.path[0]._artifact[0]; // array stored in head's _artifact
    else if (!art)
      return (spec.useDefinitions) ? pathName( ref.path ) : null;
    // art can be using proxy...
    if (ref.path.length > 1)
      return `${ art.name.absolute }.${ pathName( ref.path.slice(1) ) }`;
    return art.name.absolute;
  }

  function userQuery( user ) {
    // TODO: we need _query links set by the definer
    while (user._main) {
      if (user.kind === 'select' || user.kind === '$join')
        return user;
      user = user._parent;
    }
    return null;
  }

  // Return artifact or element referred by the path in `ref`.  The first
  // environment we search in is `env`.  If no such artifact or element exist,
  // complain with message and return `undefined`.  Record a dependency from
  // `user` to the found artifact if `user` is provided.
  function resolvePath( ref, expected, user, extDict, msgArt ) {
    if (ref == null)       // no references -> nothing to do
      return undefined;
    if (ref._artifact !== undefined)
      return ref._artifact;
    if (!ref.path || ref.path.broken || !ref.path.length) {
      // incomplete type AST or empty env (already reported)
      return setArtifactLink( ref, undefined );
    }

    let spec = specExpected[expected];
    const { path } = ref;
    const head = path[0];
    // message(null,head.location,{art:user,expected, id: head.id},
    //   'Info','User $(ART), $(EXPECTED) $(ID)')
    let env = user._block;     // artifact references: block

    if (ref.scope === 'param') {
      if (!spec.escape) {
        error( 'ref-unexpected-scope', [ ref.location, user ], { '#': 'std' } );
        return setArtifactLink( ref, null );
      }
      if (user.$syntax === 'calc')
        error('ref-unexpected-scope', [ ref.location, user ], { '#': 'calc' } );

      spec = specExpected[spec.escape];
      // In queries and query entities, the first lexical search environment
      // are the parameters, otherwise the block.  It is currently ensured that
      // _block in queries is the same as _block of the query entity:
      const lexical = (user._main || user).$tableAliases; // queries (but also query entities)
      env = lexical && lexical.$parameters || user._block;
      extDict = null;           // let getPathRoot() choose it
    }
    else if (spec.next === '__none_') {
      env = {};
    }
    else if (spec.next) {       // TODO: combine spec.next / spec.lexical to spec.lexical
      // TODO: SIMPLIFY this function
      const query = (spec.lexical === 'main') ? user._main : userQuery( user );
      // in path filter, just $magic (and $parameters)
      env = (spec.lexical === 'from') ? query._parent : query || user._main || user;
      // queries: first table aliases, then $magic - value refs: first $self, then $magic
      if (!extDict && !spec.noExt) {
        // TODO: change to name restriction for $joins, not own environments
        extDict = query && spec.rootEnv !== 'elements' &&
                  // first step: only use _combined of real query - TODO:
                  // reject if not visible, but not allow more (!)
                  (query._combined || query._parent._combined) ||
                  VolatileFns.environment( user._main ? user._parent : user );
      }
    }

    // 'global' for CSN later in value paths, CDL for Association/Composition:
    let art = (ref.scope === 'global' || spec.global)
      ? getPathRoot( path, spec, user, {}, model[spec.global || 'definitions'] )
      : getPathRoot( path, spec, user, env, extDict, msgArt || 0 );
    if (!art) {
      return setArtifactLink( ref, art );
    }
    else if (!spec.envFn && user._pathHead) {
      if (art.kind === '$self') {
        const headEnv = VolatileFns.environment( user._pathHead ) &&
              user._pathHead._origin &&
              VolatileFns.environment( user._pathHead._origin );
        rejectBareSelf( spec, path, user, headEnv );
      }
    }
    else if (art.kind === 'using') {
      const def = model.definitions[art.name.absolute];
      if (!def) {
        // It could be that the artifact was removed and that the using-proxy needs to be reported.
        // The check for $inferred is required to avoid consequential errors for cases such as:
        //   using unknown.abc;
        //   entity P as projection on abc; // <-- no consequential error here
        if (art.$inferred === 'path-prefix') {
          // head._artifact referred to the `using`.  Remove the reference,
          // so that getPathItem() below emits an error.
          setArtifactLink( head, false );
          setArtifactLink( ref, false );
        }
        else {
          return setArtifactLink( ref, false );
        }
      }
      else if (def.$duplicates) { // redefined art referenced by using proxy
        return setArtifactLink( ref, false );
      }
      else {
        setArtifactLink( head, def ); // we do not want to see the using
      }
    }
    else if (art.kind === 'mixin') {
      if (spec.noAliasOrMixin) {
        // TODO: good enough for now - change later to not search for table aliases at all
        signalNotFound( 'ref-rejected-on', [ head.location, user ], extDict && [ extDict ],
                        { '#': 'mixin', id: head.id } );
        // also set link on head?
        return setArtifactLink( ref, false );
      }
      // console.log(message( null, art.location, art, {}, 'Info','MIX').toString())
      setLink( head, '_navigation', art );
    }
    else if (art.kind === '$navElement') {
      setLink( head, '_navigation', art );
      setArtifactLink( head, art._origin );
      // TODO: set art?
    }
    else if (art.kind === '$tableAlias' || art.kind === '$self') {
      if (art.kind === '$self') {
        rejectBareSelf( spec, path, user, extDict );
      }
      else if (spec.noAliasOrMixin) {
        // TODO: good enough for now - change later to not search for table aliases at all
        signalNotFound( 'ref-rejected-on', [ head.location, user ], extDict && [ extDict ],
                        { '#': 'alias', id: head.id } );
        // also set link on head?
        return setArtifactLink( ref, false );
      }
      setLink( head, '_navigation', art );
      setArtifactLink( head, art._origin ); // query source or leading query in FROM
      // require('../model/revealInternalProperties').log(model, 'foo.bar.S.V1a')
      if (!art._origin)
        return setArtifactLink( ref, art._origin );
      // if just table alias (with expand), mark `user` with `$noOrigin` to indicate
      // that the corresponding entity should not be put as $origin into the CSN
      if (path.length === 1 && user && art.kind === '$tableAlias')
        user.$noOrigin = true;
    }

    // how many path items are for artifacts (rest: elements)
    const artItemsCount = (typeof ref.scope === 'number')
      ? ref.scope || Number.MAX_SAFE_INTEGER
      : spec.artItemsCount || 1;
    // console.log(expected, ref.path.map(a=>a.id),artItemsCount)
    art = getPathItem( path, spec, user, artItemsCount, !spec.envFn && user._pathHead && art);
    if (!art)
      return setArtifactLink( ref, art );

    if (art.$autoElement) {
      const { location } = path[path.length - 1];
      const step = { id: art.$autoElement, $inferred: '$autoElement', location };
      art = art.elements[step.id];
      setArtifactLink( step, art );
      path.push( step );
    }
    if (spec.check) {
      const fail = spec.check( art, path );
      if (fail === true) {
        signalNotFound( spec.expectedMsgId, [ ref.location, user ], null );
        return setArtifactLink( ref, false );
      }
      else if (fail) {
        signalNotFound( spec.sloppyMsgId, [ ref.location, user ], null );
        // no return!
      }
    }
    if (spec.warn) {
      const msgId = spec.warn( art, user );
      if (msgId)
        warning( msgId, [ ref.location, user ] );
    }
    if (user && (!spec.noDep ||
                 spec.noDep === 'only-entity' && art.kind !== 'entity')) {
      const { location } = ref; // || combinedLocation( head, path[tail.length] );
      // TODO: location of last path item if not main artifact
      if (spec.assoc === 'from' && art._main) {
        dependsOn( user, art._main, location );
        VolatileFns.environment( art, location, user );
      }
      else if (art.kind !== 'select') { // no real dependency to bare $self
        dependsOn( user, art, location );
        // Without on-demand resolve, we can simply signal 'undefined "x"'
      // instead of 'illegal cycle' in the following case:
      //    element elem: type of elem.x;
      }
    }
    // Warning for CDL TYPE OF references without ':' or shifted ':'
    if (spec.deprecateSmart && typeof ref.scope === 'number' &&
        !(env.$frontend && env.$frontend !== 'cdl'))
      deprecateSmart( ref, art, user );
    // TODO: follow FROM here, see csnRef - fromRef
    return setArtifactLink( ref, art );
  }

  function rejectBareSelf( spec, path, user, extDict ) {
    if (path.length === 1 && !spec.allowSelf && !user.expand && !user.inline) {
      const head = path[0];
      // TODO: extra text variant for JOIN-ON (if we have an extra `expected`)
      signalNotFound( 'ref-unexpected-self', [ head.location, user ], extDict && [ extDict ],
                      { id: head.id } );
    }
  }

  // Issue errors for "smart" element-in-artifact references
  // without a colon; and errors for misplaced colons in references.
  // This function likely disappears again in cds-compiler v2.x.
  function deprecateSmart( ref, art, user ) {
    const { path } = ref;
    const scope = path.findIndex( i => i._artifact._main );
    if (ref.scope) {            // provided a ':' in the ref path
      if (scope === ref.scope)  // correctly between main artifact and element
        return;
      const item = path[ref.scope];
      error( 'ref-unexpected-colon', [ item.location, user ], { id: item.id },
             'Replace the colon before $(ID) by a dot' );
      ref.scope = 0;          // correct (otherwise CSN refs are wrong)
    }
    if (scope >= 0) {           // we have a element-in-artifact reference
      const item = path[scope];
      error( 'ref-missing-colon', [ item.location, user ], { id: item.id },
             'Replace the dot before $(ID) by a colon' );
      ref.scope = scope;        // no need to recalculate in to-csn.js
    }
  }

  /**
   * Resolve the type arguments of `artifact` according to the type `typeArtifact`.
   * User is used for semantic message location.
   *
   * For builtins, for each property name `<prop>` in `typeArtifact.parameters`, we move a value
   * in art.$typeArgs (a vector of numbers with locations) to `artifact.<prop>`.
   *
   * For non-builtins, we take either one or two arguments and interpret them
   * as `length` or `precision`/`scale`.
   *
   * Left-over arguments are errors for non-builtins and warnings for builtins.
   *
   * @param {object}  artifact
   * @param {object} typeArtifact
   * @param {CSN.Artifact} user
   */
  function resolveTypeArgumentsUnchecked( artifact, typeArtifact, user ) {
    let args = artifact.$typeArgs || [];
    const parameters = typeArtifact.parameters || [];

    if (parameters.length > 0) {
      // For Builtins
      for (let i = 0; i < parameters.length; ++i) {
        let par = parameters[i];
        if (!(par instanceof Object))
          par = { name: par };
        if (!artifact[par.name] && i < args.length)
          artifact[par.name] = args[i];
      }
      args = args.slice(parameters.length);
    }
    else if (args.length > 0 && !typeArtifact.builtin) {
      // One or two arguments are interpreted as either length or precision/scale.
      // For builtins, we know what arguments are expected, and we do not need this mapping.
      // Also, we expect non-structured types.
      if (args.length === 1) {
        artifact.length = args[0];
        args = args.slice(1);
      }
      else if (args.length === 2) {
        artifact.precision = args[0];
        artifact.scale = args[1];
        args = args.slice(2);
      }
    }

    if (!artifact.$typeArgs)
      return;

    // Warn about left-over arguments.
    if (args.length > 0) {
      const loc = [ args[args.length - 1].location, user ];
      if (typeArtifact.builtin)
        message( 'type-ignoring-argument', loc, { art: typeArtifact } );
      else
        error( 'type-unexpected-argument', loc, { '#': 'std', art: typeArtifact });
    }
    artifact.$typeArgs = undefined;
  }

  /**
   * Return artifact or element referred by name `head`.  The first environment
   * we search in is `env`.  If `unchecked` is equal to `true`, do not report an error
   * if the artifact does not exist.  Return a "fresh" artifact for
   * non-existing external using references if `unchecked` is truthy.
   */
  function getPathRoot( path, spec, user, env, extDict, msgArt ) {
    const head = path[0];
    if (!head || !head.id || !env)
      return undefined;         // parse error
    if (!spec.envFn && user._pathHead && head.id.charAt(0) !== '$') {
      if (spec.rootEnv === 'elements') { // ON condition in expand/inline
        let root = user._pathHead;
        while (root.kind === '$inline')
          root = root._parent;
        return root;
      }
      VolatileFns.environment( user._pathHead ); // make sure _origin is set
      return user._pathHead._origin;
      // const { _origin } = user._pathHead;
      // return (_origin && _origin.kind === '$tableAlias') ? _origin._origin : _origin;
    }
    // if (head.id === 'k') {console.log(Object.keys(user));
    // throw new CompilerAssertion(JSON.stringify(user.name))}
    // if head._artifact is set or is null then it was already computed once
    if (head._artifact !== undefined)
      return Array.isArray(head._artifact) ? false : head._artifact;
    // console.log(pathName(path), !spec.next && !extDict &&
    //   (spec.useDefinitions || env.$frontend === 'json' || env))
    if (!spec.next && !extDict) {
      // CSN artifact paths are always fully qualified so we use
      // model.definitions for the JSON frontend.
      extDict = (spec.useDefinitions || env.$frontend && env.$frontend !== 'cdl')
        ? model.definitions
        : model.$builtins;
    }
    const nodollar = !spec.dollar && spec.next;
    const nextProp = spec.next || '_block';
    for (let art = env; art; art = art[nextProp]) {
      if (nodollar && !art._main) // $self stored in main.$tableAliases
        break;                    // TODO: probably remove _$next link
      const e = art.artifacts || art.$tableAliases || Object.create(null);
      const r = e[head.id];
      if (r && r.$inferred !== '$internal') {
        if (Array.isArray(r)) { // redefinitions
          setArtifactLink( head, r );
          return false;
        }
        // if (head.$delimited && r.kind !== '$tableAlias' && r.kind !== 'mixin')
        // TODO: warning for delimited special - or directly in parser
        if (r.kind === '$parameters') {
          if (!head.$delimited && path.length > 1) {
            message( 'ref-obsolete-parameters', [ head.location, user ],
                     { code: `$parameters.${ path[1].id }`, newcode: `:${ path[1].id }` },
                     'Obsolete $(CODE) - replace by $(NEWCODE)' );
            // TODO: replace it in to-csn correspondingly  !!!
            return setArtifactLink( head, r );
          }
        }
        else if (r.kind === '$self') {
          // TODO: handle $delimited differently
          // TODO: $projection only if not delimited _and_ length > 1
          return setArtifactLink( head, r );
        }
        else if (r.kind !== '$tableAlias' || path.length > 1 || user.expand || user.inline) {
          // except "real" table aliases (not $self) with path len 1
          // TODO: $projection only if not delimited _and_ length > 1
          return setArtifactLink( head, r );
        }
      }
    }
    if (extDict && (!spec.dollar || head.id[0] !== '$')) {
      const r = extDict[head.id];
      if (Array.isArray(r)) {
        if (r[0].kind === '$navElement' && r.every( e => !e._parent.$duplicates )) {
          // only complain about ambiguous source elements if we do not have
          // duplicate table aliases, only mention non-ambiguous source elems
          const uniqueNames = r.filter( e => !e.$duplicates);
          if (uniqueNames.length) {
            const names = uniqueNames.filter( e => e._parent.$inferred !== '$internal' )
              .map( e => `${ e.name.alias }.${ e.name.element }` );
            let variant = names.length === uniqueNames.length ? 'std' : 'few';
            if (names.length === 0)
              variant = 'none';
            error( 'ref-ambiguous', [ head.location, user ], { '#': variant, id: head.id, names });
          }
        }
        setArtifactLink( head, r );
        return false;
      }
      else if (r) {
        return setArtifactLink( head, r );
      }
      else if (spec.deprecatedSourceRefs && env._combined &&
               isDeprecatedEnabled( options, 'autoCorrectOrderBySourceRefs' )) {
        // User has provided a source element without table alias where a query
        // element is expected.  Possible on many DBs (and compiler v1), in CAP
        // only with table alias.  Auto-correct it if no duplicate.
        // TODO: we could use that info also in messages when the deprecated flag is not set
        const s = env._combined[head.id];
        if (s && !Array.isArray(s)) {
          path.$prefix = s.name.alias; // pushing it to path directly could be problematic
          warning( null, [ head.location, user ],
                   { id: head.id, newcode: `${ s.name.alias }.${ head.id }` },
                   'Replace source element reference $(ID) by $(NEWCODE); auto-corrected' );
          return setArtifactLink( head, s );
        }
      }
    }
    if (spec.noMessage || msgArt === true && extDict === model.definitions)
      return null;

    const valid = [];
    for (let art = env; art; art = art[nextProp]) {
      const e = art.artifacts || art.$tableAliases || Object.create(null);
      valid.push( e );
    }
    if (extDict) {
      const e = Object.create(null);
      // the names of the external dictionary are valid, too, except duplicate
      // navigation elements (for which you should use a table alias)
      if (extDict !== model.definitions) {
        for (const name in extDict) {
          if (!spec.dollar || name[0] !== '$')
            e[name] = extDict[name];
        }
      }
      else {
        for (const name in extDict) {
          if (!name.includes('.') && (!spec.dollar || name[0] !== '$'))
            e[name] = extDict[name];
        }
      }
      valid.push( e );
    }

    if (spec.next) {            // value ref
      // TODO: if not in query, specify where we search for elements and delete env.$msg
      // TODO: also something special if it starts with '$'
      if (msgArt) {
        // TODO: we might mention both the "direct" and the "effective" type and
        // always just mentioned one identifier as not found
        signalNotFound( 'ref-undefined-element', [ head.location, user ], valid,
                        { art: searchName( msgArt, head.id, 'element' ) } );
      }
      else if (head.id[0] === '$') {
        const tableAlias = extDict[head.id]?._parent;
        const alias = tableAlias?.kind === '$tableAlias' ? tableAlias.name?.alias : null;
        signalNotFound( 'ref-undefined-var', [ head.location, user ], valid, {
          '#': alias ? 'alias' : 'std',
          alias,
          id: head.id,
        } );
      }
      else {
        const isVirtual = (user.name?.id === head.id && user.virtual?.val);
        const code = isVirtual ? 'virtual null as ‹name›' : '';
        signalNotFound( 'ref-undefined-element', [ head.location, user ], valid,
                        { art: head.id, '#': isVirtual ? 'virtual' : 'std', code } );
      }
    }
    else if (env.$frontend && env.$frontend !== 'cdl' || spec.global) {
      // IDE can inspect <model>.definitions - provide null for valid
      if (!spec.noMessageForLocalized || !head.id.startsWith( 'localized.' )) {
        signalNotFound( spec.undefinedDef || 'ref-undefined-def', [ head.location, user ],
                        valid, { art: head.id } );
      }
    }
    else if (!spec.noMessageForLocalized || head.id !== 'localized') {
      signalNotFound( spec.undefinedArt || 'ref-undefined-art', [ head.location, user ],
                      valid, { name: head.id } );
    }
    return setArtifactLink( head, null );
  }

  // Return artifact or element referred by path (array of ids) `tail`.  The
  // search environment (for the first path item) is `arg`.  For messages about
  // missing artifacts (as opposed to elements), provide the `head` (first
  // element item in the path)
  // TODO - think about setting _navigation for all $navElement – the
  // "ref: ['tabAlias']: inline: […]" handling might be easier
  // (no _pathHead consultation for key prop and renaming support)
  function getPathItem( path, spec, user, artItemsCount, headArt ) {
    // let art = (headArt && headArt.kind === '$tableAlias') ? headArt._origin : headArt;
    let art = headArt;
    let nav = spec.assoc !== '$keys' && null; // false for '$keys'
    const last = path[path.length - 1];
    for (const item of path) {
      --artItemsCount;
      if (!item || !item.id)    // incomplete AST due to parse error
        return undefined;
      if (item._artifact) { // should be there on first path element (except with expand)
        art = item._artifact;
        if (Array.isArray(art))
          return false;
        if (art.$requireElementAccess && path.length === 1)
          // Path with only one item, but we expect an element, e.g. `$at.from`.
          signalMissingElementAccess(art, [ item.location, user ]);
        continue;
      }

      const fn = (spec.envFn && artItemsCount >= 0) ? spec.envFn : VolatileFns.environment;
      const env = fn( art, item.location, user, spec.assoc );
      const sub = setArtifactLink( item, env?.[item.id] );

      if (!sub) {
        // element was not found in environment

        // TODO (done?): if `env` was 0, we might set a dependency to induce an
        // illegal-cycle error instead of reporting via `errorNotFound`.
        if (art.$uncheckedElements) { // magic variable / replacement variable
          signalNotFound( 'ref-unknown-var', [ item.location, user ], [ env ],
                          { id: pathName( path ) } );
        }
        else {
          errorNotFound( item, env );
        }
        return null;
      }
      else if (Array.isArray(sub)) { // redefinitions
        return false;
      }

      if (nav) {              // we have already "pseudo-followed" a managed association
        // We currently rely on the check that targetElement references do
        // not (pseudo-) follow associations, otherwise potential redirection
        // there had to be considered, too.  Also, fk refs to sub elements in
        // combinations with redirections of the target which directly access
        // the potentially renamed sub elements would be really complex.
        // With our restriction, no renaming must be considered for item.id.
        setTargetReferenceKey( item.id, item );
      }
      // Now set an _navigation link for managed assocs in ON condition etc
      else if (art && art.target && nav != null) {
        // Find the original ref for sub and the original foreign key
        // definition.  This way, we do not need the foreign keys with
        // rewritten target element path, which might not be available at
        // this point (rewriteKeys in Resolver Phase 5).  If we want to
        // follow associations in foreign key definitions, rewriteKeys must
        // be moved to the on-demand Resolver Phase 2.
        let orig;             // for the original target element
        for (let o = sub; o; o = o.value && o.value._artifact) // TODO: or use _origin?
          orig = o;
        nav = (orig._effectiveType || orig).$keysNavigation;
        setTargetReferenceKey( orig.name.id, item );
      }
      art = sub;
      if (spec.envFn && !spec.allowAutoexposed && (!artItemsCount || item === last) &&
          art && art.$inferred === 'autoexposed' && !user.$inferred) {
        // Depending on the processing sequence, the following could be a
        // simple 'ref-undefined-art'/'ref-undefined-def' - TODO: which we
        // could "change" to this message at the end of compile():
        message( 'ref-autoexposed', [ item.location, user ], { art },
                 // eslint-disable-next-line max-len
                 'An auto-exposed entity can\'t be referred to - expose entity $(ART) explicitly' );
      }
    }
    return art;

    function setTargetReferenceKey( id, item ) {
      const node = nav && nav[id];
      nav = null;
      if (node) {
        if (node._artifact) {
          // set the original(!) foreign key for the assoc - the "right" ones
          // after rewriteKeys() is the one with the same name.id
          setLink( item, '_navigation', node._artifact );
          if (item === last)
            return;
        }
        else if (item !== last) {
          nav = node.$keysNavigation;
          return;
        }
      }
      error( null, [ item.location, user ], {},
             // eslint-disable-next-line max-len
             'You can\'t follow associations other than to elements referred to in a managed association\'s key' );
    }

    function errorNotFound( item, env ) {
      if (!spec.next && artItemsCount >= 0) {         // artifact ref
        // TODO: better for FROM e.Assoc (even disallow for other refs)
        const a = searchName( art, item.id, (spec.envFn || art._subArtifacts) && 'absolute' );
        signalNotFound( spec.undefinedDef || 'ref-undefined-def', [ item.location, user ],
                        [ env ], { art: a } );
      }
      else if (art.name && art.name.select && art.name.select > 1) {
        // TODO: 'The current query has no element $(MEMBER)' with $self.MEMBER
        // and 'The sub query for alias $(ALIAS) has no element $(MEMBER)'
        // TODO: probably not extra messageId, but text variant
        // TODO: views elements are proxies to query-0 elements, not the same
        // TODO: better message text
        signalNotFound( 'query-undefined-element', [ item.location, user ],
                        [ env ], { id: item.id } );
      }
      else if (art.kind === '$parameters') {
        signalNotFound( 'ref-undefined-param', [ item.location, user ],
                        [ env ], { art: art._main, id: item.id } );
      }
      else {
        const variant = art.kind === 'aspect' && !art.name && 'aspect';
        signalNotFound( spec.undefinedDef || 'ref-undefined-element', [ item.location, user ],
                        [ env ], {
                          '#': variant,
                          art: (variant ? '' : searchName( art, item.id, 'element' )),
                          id: item.id,
                        } );
      }
      return null;
    }
  }

  /**
   * Make a "not found" error and optionally attach valid names.
   *
   * @param {string} msgId
   * @param {any} location
   * @param {object[]} valid
   * @param  {object} [textParams]
   */
  function signalNotFound( msgId, location, valid, textParams ) {
    if (location.$notFound)
      return;
    location.$notFound = true;
    /** @type {object} */
    const err = message( msgId, location, textParams );
    if (valid) {
      valid.reverse();
      attachAndEmitValidNames(err, ...valid);
    }
  }

  /**
   * Emit a 'ref-expected-element' error for magic variable references
   * that require element accesses but don't do.
   * For example: `$at`, but `$at.from` or `$at.to` is required.
   *
   * @param {object} art
   * @param {any} location
   */
  function signalMissingElementAccess( art, location ) {
    const err = message( 'ref-expected-element', location,
                         { '#': 'magicVar', id: art.name.id } );
    // Mapping for better valid names: from -> $at.from
    const valid = Object.keys(art.elements || {}).reduce((prev, curr) => {
      prev[`${ art.name.id }.${ curr }`] = true;
      return prev;
    }, Object.create(null));
    attachAndEmitValidNames(err, valid);
  }

  /**
   * Attaches a dictionary of valid names to the given compiler message.
   * In test mode, an info message is emitted with a list of valid names.
   *
   * @param {CompileMessage} msg CDS Compiler message
   * @param  {...object} validDicts One ore more artifact dictionaries such as in `_block`.
   */
  function attachAndEmitValidNames( msg, ...validDicts ) {
    if (!options.testMode && !options.attachValidNames)
      return;

    const valid = Object.assign( Object.create( null ), ...validDicts );
    msg.validNames = Object.create( null );
    for (const name of Object.keys( valid )) {
      // ignore internal types such as cds.Association
      if (valid[name].internal || valid[name].deprecated || valid[name].$inferred === '$internal')
        continue;
      msg.validNames[name] = valid[name];
    }

    if (options.testMode && !options.$recompile) {
      // no semantic location => either first of [loc, semantic loc] pair or just location.
      const loc = msg.location[0] || msg.location;
      const names = Object.keys(msg.validNames);
      info( null, loc,
            { '#': !names.length ? 'zero' : 'std' },
            { std: `Valid: ${ names.sort().join(', ') }`, zero: 'No valid names' });
    }
  }
}

module.exports = {
  fns,
};
