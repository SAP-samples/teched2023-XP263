// Checks on XSN performed during compile()
//
// TODO: to be reworked.  It is not the intention to include more checks,
// rather the opposite.  Therefore, this file will become smaller.

// Major issues so far:
//  * Different ad-hoc value/type checks (associations, enum, ...) -
//    specify a proper one and use consistently
//  * Using name comparisons instead proper object comparisons.
//  * effectiveType issues.
//  * Often forgot to consider CSN input
//  * Bad message texts/locations.

'use strict';

// const { hasArtifactTypeInformation } = require('../model/csnUtils')
const builtins = require('../compiler/builtins');
const {
  forEachGeneric, forEachDefinition, forEachMember, isBetaEnabled,
} = require('../base/model');
const { CompilerAssertion } = require('../base/error');
const { pathName } = require('./utils');
const { forEachMemberRecursively } = require('../model/csnUtils');
const $location = Symbol.for('cds.$location');

function check( model ) {       // = XSN
  const {
    error, warning, message, info,
  } = model.$messageFunctions;

  checkSapCommonLocale( model );
  checkSapCommonTextsAspects( model );

  forEachDefinition( model, checkDefinition );
  forEachGeneric( model, 'vocabularies', checkAnnotationDefinition );
  return;

  function checkDefinition( def ) {
    checkGenericConstruct( def );
    if (def.includes && def.elements)
      checkElementIncludeOverride( def );
    forEachMember( def, member => checkMember(member) );
    if (def.$queries)
      def.$queries.forEach( checkQuery );
  }

  function checkAnnotationDefinition( art ) {
    checkEnumType( art );
    forEachMemberRecursively( art, (member) => {
      if (member.localized?.val)
        warning( 'def-unexpected-localized-anno', [ member.localized.location, member ] );
    });
    // TODO: Should we check elements similar to definition-elements as well?
  }

  function checkGenericConstruct( art ) {
    checkName( art );
    if (model.vocabularies) {
      Object.keys( art )
        .filter( a => a.startsWith('@') )
        .forEach( a => checkAnnotationAssignment1( art, art[a] ) );
    }
    checkTypeStructure(art);
    if (art.kind === 'enum')
      checkEnum( art );
    checkEnumType( art );
  }

  function checkMember( member, parentProps = { key: false, virtual: false } ) {
    // To avoid "bubble-up" checks, store required parent properties.
    if (member.key?.val === true)
      parentProps.key = member.key;
    if (member.virtual?.val === true)
      parentProps.virtual = member.virtual;

    checkGenericConstruct(member);

    if (member.kind === 'element')
      checkElement( member, parentProps );

    forEachMember( member, m => checkMember(m, parentProps) );
  }

  function checkVirtualKey( elem, parentProps ) {
    const isKey = parentProps.key || (elem.key?.val && elem.key);
    const isVirtual = parentProps.virtual?.val || (elem.virtual?.val && elem.virtual);
    if (isKey && isVirtual) {
      error('def-unexpected-key', [ isKey.location, elem ],
            { '#': 'virtual', name: elem.name.element, prop: 'key' });
    }
  }

  function checkElement( elem, parentProps ) {
    checkLocalizedSubElement(elem);
    checkVirtualKey(elem, parentProps);
    checkForUnmanagedAssociationsAsKey( elem, parentProps );
    checkLocalizedElement( elem );
    checkAssociation( elem );

    if (elem.value) {
      if (elem._main.query)
        checkSelectItemValue(elem);
      else if (elem.$syntax === 'calc')
        checkCalculatedElementValue( elem );
    }

    checkCardinality(elem); // TODO: also for assoc types
  }


  function checkName( construct ) { // TODO: move to define.js
    if (model.options.$skipNameCheck)
      return;
    // TODO: Move a corrected version of this check to definer (but do not rely
    // on it!): The code below misses to consider CSN input.
    if (construct.name.id && construct.name.id.indexOf('.') !== -1) {
      // TODO: No, we should not forbid this
      error(null, [ construct.name.location, construct ], {},
            'The character \'.\' is not allowed in identifiers');
    }
  }

  function checkLocalizedElement( elem ) {
    // if it is directly a localized element
    if (elem.localized && elem.localized.val) {
      const type = elem._effectiveType;
      // See discussion issue #6520: should we allow all scalar types?
      if (!type || !type.builtin || type.category !== 'string') {
        info('ref-expecting-localized-string', [ elem.type?.location, elem ],
             { keyword: 'localized' },
             'Expecting a string type in combination with keyword $(KEYWORD)');
      }
    }
    // "key" keyword at localized element in SELECT list.
    // TODO: This check should be moved to localized.js
    if (elem.key && elem.key.val && elem._main && elem._main.query) {
      // original element is localized but not key, as that would have
      // already resulted in a warning
      if (elem._origin && elem._origin.localized && elem._origin.localized.val &&
        ( !elem._origin.key || !elem._origin.key.val)) {
        warning('localized-key', [ elem.key.location, elem ], { keyword: 'localized' },
                'Keyword $(KEYWORD) is ignored for primary keys');
      }
    }
  }

  function checkQuery( query ) {
    checkNoUnmanagedAssocsInGroupByOrderBy( query );
    // TODO: check too simple (just one source), as most of those in this file
    // Check expressions in the various places where they may occur
    if (query.from)
      visitSubExpression(query.from, query, checkGenericExpression);

    if (query.where)
      visitExpression(query.where, query, checkGenericExpression);

    if (query.groupBy) {
      for (const groupByEntry of query.groupBy)
        visitExpression(groupByEntry, query, checkGenericExpression);
    }
    if (query.having)
      visitExpression(query.having, query, checkGenericExpression);

    if (query.orderBy) {
      for (const orderByEntry of query.orderBy)
        visitExpression(orderByEntry, query, checkGenericExpression);
    }
    if (query.mixin) {
      for (const mixinName in query.mixin)
        checkAssociation(query.mixin[mixinName]);
    }
  }

  // Individual checks -------------------------------------------------------

  /**
   * The enumNode is a single enum element and not the whole type.
   *
   * @param {XSN.Artifact} enumNode
   */
  function checkEnum( enumNode ) {
    if (!enumNode.value)
      return;

    const type = enumNode.value.literal;
    const loc = enumNode.value.location;

    // Special handling to print a more detailed error message.
    // Other cases like `null` as enum value are handled in `checkEnumValueType()`
    if (type === 'enum') {
      warning('enum-value-ref', [ loc, enumNode ], {}, // TODO: make this an error in v4
              'References to other values are not allowed as enum values');
    }
  }

  function checkEnumType( enumNode ) {
    // Either the type is an enum or an arrayed enum.  We are only interested in
    // the enum and don't care whether the enum is arrayed.
    enumNode = enumNode.enum ? enumNode : enumNode.items;
    if (!enumNode || !enumNode.enum)
      return;
    const type = enumNode.type && enumNode.type._artifact &&
                 enumNode.type._artifact._effectiveType;

    // We can't distinguish (in CSN) between these two cases:
    //   type Base : String enum { b;a = 'abc'; };
    //   type ThroughRef : Base;            (1)
    //   type NotAllowed : Base enum { a }  (2)
    // (2) should not be allowed but (1) should be.  That's why we allow (2).
    if (!type || type.enum)
      return;

    const name = type.name.absolute;

    // All builtin types are allowed except binary and relational types.
    // The latter are "internal" types.
    const isBinary = builtins.isBinaryTypeName(name);

    if (!type.builtin || type.internal || isBinary) {
      let typeclass = 'std';

      if (isBinary)
        typeclass = 'binary';
      else if (builtins.isRelationTypeName(name))
        typeclass = 'relation';
      else if (type.elements)
        typeclass = 'struct';
      else if (type.items)
        typeclass = 'items';

      error('enum-invalid-type', [ enumNode.type.location, enumNode ], { '#': typeclass }, {
        std: 'Only builtin types are allowed as enums',
        binary: 'Binary types are not allowed as enums',
        relation: 'Relational types are not allowed as enums',
        struct: 'Structured types are not allowed as enums',
        items: 'Arrayed types are not allowed as enums',
      });
      return;
    }

    checkEnumValue(enumNode);
  }

  /**
   * Check the given enum's elements and their values.  For example
   * whether the value types are valid for the used enum type.
   * `enumNode` can be also be `type.items` if the type is an arrayed enum.
   *
   * @param {XSN.Definition} enumNode
   */
  function checkEnumValue( enumNode ) {
    const type = enumNode.type && enumNode.type._artifact &&
                 enumNode.type._artifact._effectiveType;
    if (!enumNode.enum || !type || !type.builtin)
      return;

    const isNumeric = builtins.isNumericTypeName(type.name.absolute);
    const isString = builtins.isStringTypeName(type.name.absolute);

    if (!isString) {
      // Non-string enums MUST have a value as the value is only deducted for string types.
      const emptyValue = Object.keys(enumNode.enum).find(name => !enumNode.enum[name].value);
      if (emptyValue) {
        const failedEnum = enumNode.enum[emptyValue];
        warning('enum-missing-value', [ failedEnum.location, failedEnum ],
                { '#': isNumeric ? 'numeric' : 'std', name: emptyValue },
                {
                  std: 'Missing value for non-string enum element $(NAME)',
                  numeric: 'Missing value for numeric enum element $(NAME)',
                });
      }
    }

    // We only check string and numeric value types.
    // TODO: share value-type check with that of annotation assignments
    if (!isString && !isNumeric)
      return;

    const expectedType = isNumeric ? 'number' : 'string';

    // Do not check elements that don't have a value at all or are
    // references to other enum elements.  There are other checks for that.
    const hasWrongType = element => element.value &&
          (element.value.literal !== expectedType) &&
          (element.value.literal !== 'enum');

    for (const key of Object.keys(enumNode.enum)) {
      const element = enumNode.enum[key];
      if (!hasWrongType(element))
        continue;

      const actualType = element.value.literal;
      warning('enum-value-type', [ element.value.location, element ],
              { '#': expectedType, name: key, prop: actualType }, {
                std: 'Incorrect value type $(PROP) for enum element $(NAME)', // Not used
                number: 'Expected numeric value for enum element $(NAME) but was $(PROP)',
                string: 'Expected string value for enum element $(NAME) but was $(PROP)',
              });
    }
  }

  // TODO: check inside compiler as it is a compiler restriction - improve
  /**
   * Non-recursive check if sub-elements have a "localized" keyword since this is
   * not yet supported.
   *
   * This check is not recursive to avoid a runtime overhead. Because of this it fails
   * to detect scenarios with indirections, e.g.
   *
   *   type L : localized String;
   *   type L1 : L;
   *   type L2 : L1;
   *
   *   entity E {
   *     struct : {
   *       subElement : L2;
   *     }
   *   }
   *
   * @param {XSN.Artifact} element
   */
  function checkLocalizedSubElement( element ) {
    if (element._parent.kind !== 'element')
      return;

    const isLocalizedSubElement = element.localized && element.localized.val;
    if (isLocalizedSubElement || (element.type && isTypeLocalized(element.type._artifact))) {
      const loc = isLocalizedSubElement ? element.localized.location : element.type.location;
      warning('localized-sub-element', [ loc, element ],
              { type: element.type, '#': isLocalizedSubElement ? 'std' : 'type' },
              {
                std: 'Keyword "localized" is ignored for sub elements',
                type: 'Keyword "localized" in type $(TYPE) is ignored for sub elements',
              } );
    }
    return;

    // TODO: Recursive check
    function isTypeLocalized( type ) {
      return (type && type.localized && type.localized.val);
    }
  }

  /**
   * Check that a primary key element is not an unmanaged association or
   * contains unmanaged associations
   *
   * TODO: ease check for subelements: using unmanaged assocs is OK there, as
   *       long as the whole key is "closed", i.e., no ref in ON refers to element
   *       outside.
   *
   * @param {any} element Element to check recursively
   */
  function checkForUnmanagedAssociationsAsKey( element, parentProps ) {
    if (!parentProps.key?.val && !element.key?.val)
      return;
    if (element.targetAspect) {
      // TODO: bad location / message
      message('composition-as-key', [ parentProps.key.location, element ], {},
              // TODO: give semantics when error downgraded
              'Managed compositions can\'t be used as primary key');
    }
    else if (element.on) {
      // TODO: bad location / message
      message('unmanaged-as-key', [ parentProps.key.location, element ], {},
              // TODO: give semantics when error downgraded
              'Unmanaged associations can\'t be used as primary key');
    }
  }

  // Check that min and max cardinalities of 'elem' in 'art' have legal values
  // TODO: move to define.js or parsers
  function checkCardinality( elem ) {
    if (!elem.cardinality)
      return;

    // Max cardinalities must be a positive number or '*'
    for (const prop of [ 'sourceMax', 'targetMax' ]) {
      if (elem.cardinality[prop]) {
        const { literal, val, location } = elem.cardinality[prop];
        if (!(literal === 'number' && val > 0 ||
              literal === 'string' && val === '*')) {
          error('invalid-cardinality', [ location, elem ], { '#': prop, code: val, newcode: '*' }, {
            // eslint-disable-next-line max-len
            std: 'Value $(CODE) is invalid for maximum cardinality, expecting a positive number or $(NEWCODE)',
            // eslint-disable-next-line max-len
            sourceMax: 'Value $(CODE) is invalid for maximum source cardinality, expecting a positive number or $(NEWCODE)',
            // eslint-disable-next-line max-len
            targetMax: 'Value $(CODE) is invalid for maximum target cardinality, expecting a positive number or $(NEWCODE)',
          });
        }
      }
    }

    // Min cardinality must be a non-negative number
    // Note: Already checked by parser (syntax error if -1 is used) and
    //       from-csn.json (expected non-negative number)
    for (const prop of [ 'sourceMin', 'targetMin' ]) {
      if (elem.cardinality[prop]) {
        const { literal, val, location } = elem.cardinality[prop];
        if (!(literal === 'number' && val >= 0)) {
          error('invalid-cardinality', [ location, elem ], { '#': prop, code: val }, {
            // eslint-disable-next-line max-len
            std: 'Value $(CODE) is invalid for minimum cardinality, expecting a non-negative number',
            // eslint-disable-next-line max-len
            targetMin: 'Value $(CODE) is invalid for minimum target cardinality, expecting a non-negative number',
            // eslint-disable-next-line max-len
            sourceMin: 'Value $(CODE) is invalid for minimum source cardinality, expecting a non-negative number',
          });
        }
      }
    }

    // If provided, min cardinality must not exceed max cardinality (note that
    // '*' is considered to be >= any number)
    const pair = [ [ 'sourceMin', 'sourceMax', 'source' ], [ 'targetMin', 'targetMax', 'target' ] ];
    pair.forEach((p) => {
      if (elem.cardinality[p[0]] && elem.cardinality[p[1]] &&
          elem.cardinality[p[1]].literal === 'number' &&
          elem.cardinality[p[0]].val > elem.cardinality[p[1]].val) {
        error(null, [ elem.cardinality.location, elem ], { '#': p[2] }, {
          std: 'Minimum cardinality must not be greater than maximum cardinality', // variant unused
          source: 'Source minimum cardinality must not be greater than source maximum cardinality',
          target: 'Target minimum cardinality must not be greater than target maximum cardinality',
        });
      }
    });
  }

  // TODO: make this part of the name resolution in the compiler
  // Check that queries in 'art' do not contain unmanaged associations in GROUP BY or ORDER BY
  function checkNoUnmanagedAssocsInGroupByOrderBy( query ) {
    const art = query._main;    // TODO - remove, use query for semantic location
    for (const groupByEntry of query.groupBy || []) {
      if (groupByEntry._artifact && groupByEntry._artifact._effectiveType &&
          groupByEntry._artifact._effectiveType.on) {
        // Unmanaged association - complain
        error(null, [ groupByEntry.location, art ], {},
              'Unmanaged associations are not allowed in GROUP BY');
      }
    }
    for (const orderByEntry of query.orderBy || []) {
      if (orderByEntry._artifact && orderByEntry._artifact._effectiveType &&
          orderByEntry._artifact._effectiveType.on) {
        // Unmanaged association - complain
        error(null, [ orderByEntry.location, art ], {},
              'Unmanaged associations are not allowed in ORDER BY');
      }
    }
  }

  function checkAssociation( elem ) {
    // TODO: yes, a check similar to this could make it into the compiler)
    //       when virtual element is part of association
    if (elem.foreignKeys) {
      for (const k in elem.foreignKeys) {
        const key = elem.foreignKeys[k].targetElement;
        if (key && isVirtualElement(key._artifact))
          error('ref-unexpected-virtual', [ key.location, elem ], { '#': 'fkey' });
        else if (key._artifact?.$syntax === 'calc')
          error( 'ref-unexpected-calculated', [ key.location, elem ], { '#': 'fkey' } );
      }
    }

    checkOnCondition(elem);
  }

  function getBinaryOp( cond ) {
    const { op, args } = cond;
    return op?.val === 'ixpr' && args?.length === 3 && args[1].literal === 'token' &&
      args[1] || op;
  }

  // A function like this could be part of the compiler
  /**
   * Check that the given type has no conflicts between its `type` property
   * and its `elements` or `items` property. For example if `type` is not
   * structured but the artifact has an `elements` property then the user
   * made a mistake. This scenario can only happen through CSN and not CDL.
   *
   * @param {XSN.Artifact} artifact
   */
  function checkTypeStructure( artifact ) {
    // Just a basic check. We do not check that the inner structure of `items`
    // is the same as the type but only that all are arrayed or structured.
    if (artifact.type && artifact.type._artifact) {
      const finalType = artifact.type._artifact._effectiveType || artifact.type._artifact;

      if (artifact.items && !finalType.items) {
        warning('type-items-mismatch', [ artifact.type.location, artifact ],
                { type: artifact.type, prop: 'items' },
                'Used type $(TYPE) is not arrayed and conflicts with $(PROP) property');
      }
      else if (artifact.elements && !finalType.elements) {
        warning('type-elements-mismatch', [ artifact.type.location, artifact ],
                { type: artifact.type, prop: 'elements' },
                'Used type $(TYPE) is not structured and conflicts with $(PROP) property');
      }
    }
    if (artifact.items)
      checkTypeStructure(artifact.items);
  }

  /**
   * Report issues when an entity overrides structured elements of an included entity
   * with a scalar one or vice versa.
   *
   * NOTE: Relies on element expansion.
   */
  function checkElementIncludeOverride( def ) {
    if (!isBetaEnabled(model.options, 'v4preview'))
      return; // this is a v4 check only

    for (const name in def.elements) {
      const element = def.elements[name];
      // Element is new in `art`, not expanded; we can't check for !element._origin, due
      // to calculated elements such as `a = b`.
      if (element.$inferred !== 'include') {
        for (const include of def.includes) {
          if (include._artifact?.elements?.[name] !== undefined)
            checkElementOverride( element, include._artifact.elements[name]);
        }
      }
    }

    return;

    function checkElementOverride( elem, original ) {
      const xorElements = !elem.elements !== !original.elements;
      if (xorElements) {
        // one of the two elements is not structured
        const prop = !elem.elements ? 'new-not-structured' : 'old-not-structured';
        const name = elem.name.id;
        // Position at type/struct, not name
        const loc = elem.type?.location || elem.elements?.[$location] || elem.location;
        error('ref-invalid-override', [ loc, elem ],
              { '#': prop, art: original._main, name });
        return false;
      }
      else if (original.elements &&
               !checkSubStructureOverride(elem, elem.elements, original.elements)) {
        return false;
      }
      return true;
    }

    /**
     * Ensure the new one has at least as many elements as the original.
     */
    function checkSubStructureOverride( user, elements, originals ) {
      for (const element in originals) {
        const elem = elements[element];
        const orig = originals[element];
        if (elem === undefined) {
          const loc = [ elements[$location], user ];
          error('ref-invalid-override', loc, { '#': 'missing', id: user.name.id, name: element });
          return false; // only report one
        }
        else if (!checkElementOverride(elem, orig)) {
          return false;
        }
      }
      return true;
    }
  }


  // Former checkExpressions.js ----------------------------------------------

  /**
   * Check a generic expression (or condition) for semantic validity.
   *
   * @param {any} xpr The expression to check
   * @param {XSN.Artifact} user User for semantic location
   * @returns {void}
   */
  function checkGenericExpression( xpr, user ) {
    checkExpressionNotVirtual(xpr, user);
    checkExpressionAssociationUsage(xpr, user, false);
  }

  function checkExpressionNotVirtual( xpr, user ) {
    if (xpr._artifact && isVirtualElement(xpr._artifact))
      error('ref-unexpected-virtual', [ xpr.location, user ], { '#': 'expr' });
  }

  function checkOnCondition( elem ) {
    // TODO: Move to checkAssociation
    if (elem.on && !elem.on.$inferred) {
      visitExpression(elem.on, elem, (xpr, user) => {
        checkExpressionNotVirtual(xpr, user);
        checkExpressionAssociationUsage(xpr, user, true);
        if (xpr._artifact?.$syntax === 'calc')
          error( 'ref-unexpected-calculated', [ xpr.location, user ], { '#': 'on' } );
      });
      if (isDollarSelfOrProjectionOperand(elem.on)) {
        // Bare $self usages are not allowed and don't work in A2J.
        error('expr-missing-comparison', [ elem.on.location, elem ], { id: '$self', op: '=' } );
      }
    }
  }

  function checkSelectItemValue( elem ) {
    checkExpressionAssociationUsage(elem.value, elem, false);

    visitSubExpression(elem.value, elem, (xpr) => {
      checkExpressionNotVirtual(xpr, elem);
      checkExpressionAssociationUsage(xpr, elem, false);
    });
  }

  function checkCalculatedElementValue( elem ) {
    visitExpression(elem.value, elem, (xpr, user) => {
      if (xpr._artifact) { // we only need to check artifact references
        checkExpressionNotVirtual(xpr, user);
        if (isStructuredElement(xpr._artifact))
          error('ref-unexpected-structured', [ xpr.location, elem ], { '#': 'expr' } );
        else if (xpr._artifact.target !== undefined)
          error('ref-unexpected-assoc', [ xpr.location, elem ], { '#': 'expr' });
      }
    });
    // Calc elements must not refer to keys, because that may lead to another key
    // in an SQL view, which is missing in OData.
    // Following associations does not lead to this issue.
    if (elem.value.path && isKeyElement(elem.value._artifact) &&
      !followsAnAssociation(elem.value.path)) {
      error('ref-unexpected-key', [ elem.value.location, elem ], {},
            'Calculated elements can\'t refer directly to key elements');
    }
  }

  /**
   * Returns true if any of the path steps follows an association.
   *
   * @param path
   * @return {boolean}
   */
  function followsAnAssociation( path ) {
    for (const step of path) {
      if (step._artifact?.target)
        return true;
    }
    return false;
  }

  function isKeyElement( elem ) {
    let parent = elem;
    while (parent) {
      if (parent.key?.val === true)
        return true;
      parent = parent._parent;
    }
    return false;
  }


  /**
   * Check whether the supplied argument is a virtual element
   *
   * TO CLARIFY: do we want the "no virtual element" check for virtual elements/columns, too?
   *
   * @param {any} elem Element to check (part of an expression)
   * @returns {Boolean}
   */
  function isVirtualElement( elem ) {
    let parent = elem?._origin || elem;
    while (parent) {
      if (parent.virtual?.val === true)
        return true;
      parent = parent._parent;
    }
    return false;
  }

  function isStructuredElement( elem ) {
    // The effective type always points to something with elements _if_ the
    // type is structured.  But `elem` should already have `elements` if its
    // structured due to element expansion.
    return !!(elem?._effectiveType || elem)?.elements;
  }

  /**
   * Check a tree-like expression for semantic validity
   *
   * @param {any} xpr The expression to check
   * @param {XSN.Artifact} user
   * @param {boolean} allowAssocTail
   * @returns {void}
   */
  function checkExpressionAssociationUsage( xpr, user, allowAssocTail ) {
    if (!xpr.args)
      return;

    // Only check associations and $self if this is not a backlink-like
    // expression (a comparison of $self with an assoc).
    // We don't check token-stream-like 'xpr's.
    const isNotSelfComparison = xpr.op?.val !== 'xpr' &&
      !isBinaryDollarSelfComparisonWithAssoc(xpr);
    const args = Array.isArray(xpr.args) ? xpr.args : Object.values(xpr.args);
    const op = getBinaryOp(xpr);

    if (isNotSelfComparison) {
      for (const arg of args) {
        if (op?.val !== '=' && isDollarSelfOrProjectionOperand(arg)) {
          // `nary` operators don't have a "good" location; use $self in that case.
          const loc = (op?.location.endLine ? op : arg).location;
          error('expr-invalid-operator', [ loc, user ], { op: '=', id: '$self' });
        }
        else {
          checkExpressionIsNotAssocOrSelf(arg, user, allowAssocTail);
        }
      }
    }
  }

  function checkExpressionIsNotAssocOrSelf( arg, user, allowAssocTail ) {
    // Arg must not be an association and not $self
    // Only if path is not approved exists path (that is non-query position)
    if (arg.path && arg.$expected !== undefined) { // not 'approved-exists'
      if (arg.$expected === 'exists')
        error('ref-unexpected-assoc', [ arg.location, user ], { '#': 'expr' } );
    }
    else if (!allowAssocTail && isAssociationOperand(arg)) {
      error('ref-unexpected-assoc', [ arg.location, user ], { '#': 'expr' } );
    }

    if (isDollarSelfOrProjectionOperand(arg)) {
      error(null, [ arg.location, user ], { id: arg.path[0].id },
            '$(ID) can only be used as a value in a comparison to an association');
    }
  }

  // Return true if 'arg' is an expression argument of type association or composition
  function isAssociationOperand( arg ) {
    if (!arg.path) {
      // Not a path, hence not an association (literal, expression, function, whatever ...)
      return false;
    }
    // If it has a target, it is an association or composition
    return (arg._artifact && arg._artifact.target) ||
      (arg._artifact && arg._artifact._effectiveType && arg._artifact._effectiveType.target);
  }

  /**
   * Return true if 'arg' is an expression argument denoting "$self" || "$projection"
   */
  function isDollarSelfOrProjectionOperand( arg ) {
    return arg.path?.length === 1 &&
      (arg.path[0].id === '$self' || arg.path[0].id === '$projection');
  }

  /**
   * Return true if 'xpr' is backlink-like expression (a comparison of "$self" with an assoc)
   *
   * @param {any} xpr The expression to check
   * @returns {Boolean}
   */
  function isBinaryDollarSelfComparisonWithAssoc( xpr ) {
    // Must be an expression with arguments
    if (!xpr.op || !xpr.args)
      return false;


    // One argument must be "$self" and the other an assoc
    if (xpr.op.val === '=' && xpr.args.length === 2) {
      // Tree-ish expression from the compiler (not augmented)
      return (isAssociationOperand(xpr.args[0]) && isDollarSelfOrProjectionOperand(xpr.args[1]) ||
              isAssociationOperand(xpr.args[1]) && isDollarSelfOrProjectionOperand(xpr.args[0]));
    }
    else if (xpr.args.length === 3 && xpr.args[1].val === '=') {
      // Tree-ish expression from the compiler (not augmented)
      return (isAssociationOperand(xpr.args[0]) && isDollarSelfOrProjectionOperand(xpr.args[2]) ||
             isAssociationOperand(xpr.args[2]) && isDollarSelfOrProjectionOperand(xpr.args[0]));
    }

    // Nothing else qualifies
    return false;
  }


  // Former checkAnnotationAssignments.js ------------------------------------

  // Check the annotation assignments (if any) of 'annotatable', possibly using annotation
  // definitions from 'model'. Report errors on 'options.messages.
  //
  // TODO: rework completely

  // Has been slightly adapted for model.vocabularies but comments need to be
  // adapted, etc.
  function checkAnnotationAssignment1( art, anno ) {
    // Sanity checks (ignore broken assignments)
    if (!anno.name || !anno.name.path || !anno.name.path.length)
      return;
    // Annotation artifact for longest path step of annotation path
    let fromArtifact = null;
    let pathStepsFound = 0;
    for (let i = anno.name.path.length; i > 0; i--) {
      const absoluteName = anno.name.path.slice(0, i).map(path => path.id).join('.');
      if (model.vocabularies[absoluteName]) {
        fromArtifact = model.vocabularies[absoluteName];
        pathStepsFound = i;
        break;
      }
    }

    if (!fromArtifact) {
      // Unchecked annotation => nothing to check
      return;
    }

    const { artifact, endOfPath } = resolvePathFrom(anno.name.path.slice(pathStepsFound),
                                                    fromArtifact);

    // Check what we actually want to check
    checkAnnotationAssignment( anno, artifact, endOfPath, art );
  }

  // Perform checks for annotation assignment 'anno', using corresponding annotation declaration,
  // made of 'annoDecl' (artifact or undefined) and 'elementDecl' (annotation or element
  // or undefined). Report errors on 'options.messages.
  function checkAnnotationAssignment( anno, annoDecl, elementDecl, art ) {
    // Nothing to check if no actual annotation declaration was found
    if (!annoDecl || annoDecl.artifacts && !elementDecl)
      return;


    // Must be an annotation if found
    if (annoDecl.kind !== 'annotation') // i.e namespace
      return;

    // Element must exist in annotation
    if (!elementDecl) {
      warning(null, anno.location || anno.name.location,
              { name: pathName(anno.name.path), anno: annoDecl.name.absolute },
              'Element $(NAME) not found for annotation $(ANNO)');
      return;
    }

    // Sanity checks
    if (!elementDecl._effectiveType)
      throw new CompilerAssertion(`Expecting annotation declaration to have _finalType: ${ JSON.stringify(annoDecl) }`);


    // Must have literal or path unless it is a boolean
    if (!anno.literal && !anno.path && getFinalTypeNameOf(elementDecl) !== 'cds.Boolean') {
      if (elementDecl.type && elementDecl.type._artifact.name.absolute) {
        warning('anno-expecting-value', anno.location || anno.name.location,
                { '#': 'type', type: elementDecl.type._artifact });
      }
      else {
        warning('anno-expecting-value', anno.location || anno.name.location,
                { '#': 'std', anno: anno.name.absolute });
      }

      return;
    }

    // Value must be assignable to type
    checkValueAssignableTo(anno, elementDecl, art);
  }

  // Check that annotation assignment 'value' (having 'path or 'literal' and
  // 'val') is potentially assignable to element 'element'. Complain on 'loc'
  // if not
  function checkValueAssignableTo( value, elementDecl, art ) {
    // FIXME: We currently do not have any element declaration that could match
    // a 'path' value, so we simply leave those alone
    if (value.path)
      return;


    const loc = [ value.location || value.name.location, art ];

    // Array expected?
    if (elementDecl._effectiveType.items) {
      // Make sure we have an array value
      if (value.literal !== 'array') {
        warning(null, loc, {}, 'An array value is required here');
        return;
      }
      // Check each element
      for (const valueItem of value.val)
        checkValueAssignableTo(valueItem, elementDecl._effectiveType.items, art);

      return;
    }

    // Struct expected (can only happen within arrays)?
    if (elementDecl._effectiveType.elements) {
      if (value.literal !== 'struct') {
        warning(null, loc, {}, 'A struct value is required here');
        return;
      }
      // FIXME: Should check each element
      return;
    }

    // Handle each (primitive) expected element type separately
    const type = getFinalTypeNameOf(elementDecl);
    if (builtins.isStringTypeName(type)) {
      if (value.literal !== 'string' && value.literal !== 'enum' &&
          !elementDecl._effectiveType.enum)
        warning(null, loc, { type }, 'A string value is required for type $(TYPE)');
    }
    else if (builtins.isBinaryTypeName(type)) {
      if (value.literal !== 'string' && value.literal !== 'x')
        warning(null, loc, { type }, 'A hexadecimal string value is required for type $(TYPE)');
    }
    else if (builtins.isNumericTypeName(type)) {
      if (value.literal !== 'number' && value.literal !== 'enum' &&
          !elementDecl._effectiveType.enum)
        warning(null, loc, { type }, 'A numerical value is required for type $(TYPE)');
    }
    else if (builtins.isDateOrTimeTypeName(type)) {
      if (value.literal !== 'date' && value.literal !== 'time' &&
          value.literal !== 'timestamp' && value.literal !== 'string')
        warning(null, loc, { type }, 'A date/time value or a string is required for type $(TYPE)');
    }
    else if (builtins.isBooleanTypeName(type)) {
      if (value.literal && value.literal !== 'boolean')
        warning(null, loc, { type }, 'A boolean value is required for type $(TYPE)');
    }
    else if (builtins.isRelationTypeName(type) || builtins.isGeoTypeName(type)) {
      warning(null, loc, { type }, 'Type $(TYPE) can\'t be assigned a value');
    }
    else if (!elementDecl._effectiveType.enum) {
      throw new CompilerAssertion(`Unknown primitive type name: ${ type }`);
    }

    // Check enums
    const expectedEnum = elementDecl._effectiveType.enum;
    if (value.literal === 'enum') {
      if (expectedEnum) {
        // Enum symbol provided and expected
        if (!expectedEnum[value.sym.id]) {
          // .. but no such constant
          warning(null, loc, { id: `#${ value.sym.id }` }, 'Enum symbol $(ID) not found in enum');
        }
      }
      else {
        // Enum symbol provided but not expected
        warning(null, loc, { id: `#${ value.sym.id }`, type }, 'Can\'t use enum symbol $(ID) for non-enum type $(TYPE)');
      }
    }
    else if (expectedEnum) {
      // Enum symbol not provided but expected
      const hasValidValue = Object.keys(expectedEnum)
        .some(symbol => getEnumValue(expectedEnum[symbol]) === value.val);
      if (!hasValidValue) {
        // ... and none of the valid enum symbols matches the value
        warning(null, loc, {}, 'An enum value is required here');
      }
    }
  }

  function getEnumValue( enumSymbol ) {
    if (enumSymbol.value)
      return enumSymbol.value?.val;
    if (enumSymbol._effectiveType)
      return enumSymbol._effectiveType?.value?.val;
    return null;
  }

  // TODO: remove the following

  // Return the artifact (and possibly, its element) found by following 'path'
  // starting at 'from'.  The return value is an object { artifact, endOfPath }
  // with 'artifact' being the last artifact encountered on 'path' (or
  // 'undefined' if none found), and 'endOfPath' being the element or artifact
  // represented by the full path (or 'undefined' if not found).  Note that
  // only elements and artifacts are considered for path traversal (no actions,
  // functions, parameters etc.)
  function resolvePathFrom( path, from, result = {} ) {
    // Keep last encountered artifacts
    if (from && !from._main)
      result.artifact = from;

    // Always keep current path end
    result.endOfPath = from;
    // Stop if found or failed
    if (path.length === 0 || !from)
      return result;

    // Continue search with next path step
    const nextStepEnv = (from._effectiveType || from).artifacts ||
          from._effectiveType?.elements || [];
    return resolvePathFrom(path.slice(1), nextStepEnv[path[0].id], result);
  }

  // Return the absolute name of the final type of 'node'. May return 'undefined'
  // for anonymous types.  DO NOT USE THIS function, it has several assumptions
  // which are not necessarily true.
  function getFinalTypeNameOf( node ) {
    let type = node._effectiveType;
    if (type.type)
      type = type.type._artifact;
    return type?.name?.absolute;
  }
}

/**
 * Ensure that the `locale` element of sap.common.TextsAspects
 * is a string type.  This is required by CAP runtimes to work properly.
 *
 * @param {XSN.Model} model
 */
function checkSapCommonTextsAspects( model ) {
  const name = 'sap.common.TextsAspect';
  const locale = model.definitions[name]?.elements?.locale;
  if (locale) {
    // `locale` could also be `sap.common.Locale`, which must also be a string.
    const type = locale._effectiveType;
    if (type?.name?.absolute !== 'cds.String') {
      const hasCommonLocale = !!model.definitions['sap.common.Locale'];
      const { error } = model.$messageFunctions;
      error('def-invalid-element-type', [ locale.type.location, locale ], {
        '#': hasCommonLocale ? 'texts-aspect-locale' : 'std',
        art: name,
        elemref: 'locale',
        type: 'cds.String',
        othertype: 'sap.common.Locale',
      });
    }
  }
}

/**
 * Checks that sap.common.Locale is of type cds.String.  This limitation may
 * be lifted later on.
 *
 * @param {XSN.Model} model
 */
function checkSapCommonLocale( model ) {
  const localeArt = model.definitions['sap.common.Locale'];
  if (localeArt) {
    const type = localeArt._effectiveType;
    if (type?.name?.absolute !== 'cds.String') {
      const { message } = model.$messageFunctions;
      message('type-expected-builtin', [ localeArt.name.location, localeArt ],
              { name: 'sap.common.Locale' },
              'Expected $(NAME) to be a string type');
    }
  }
}


/**
 * Visits each expression.
 *
 * TODO: Properly visit expressions; will be improved step by step;
 *       Currently only replaces old foreachPath().
 *
 * @param {any} xpr
 * @param {XSN.Artifact} user
 * @param {(xpr: any, user: any, parentExpr: any) => void} callback
 */
function visitExpression( xpr, user, callback ) {
  callback( xpr, user, null );
  visitSubExpression( xpr, user, callback );
}

/**
 * Visits each sub-expression.
 *
 * @param {any} xpr
 * @param {XSN.Artifact} user
 * @param {(xpr: any, user: any, parentExpr: any) => void} callback
 */
function visitSubExpression( xpr, user, callback ) {
  if (xpr.args) {
    const args = Array.isArray(xpr.args) ? xpr.args : Object.values(xpr.args);
    // Check for illegal argument usage within the expression
    for (const arg of args) {
      callback( arg, user, xpr.args );
      // Recursively traverse the argument expression
      visitSubExpression(arg, user, callback);
    }
  }

  if (xpr.path?.length) {
    for (const arg of xpr.path) {
      if (arg.where) {
        callback( arg.where, user, arg );
        visitSubExpression(arg.where, user, callback);
      }
    }
  }
}


module.exports = check;
