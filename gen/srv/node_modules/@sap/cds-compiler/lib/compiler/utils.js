// Simple compiler utility functions

// This file contains small utility functions which do not access the complete
// XSN or functions instantiated using the XSN.

// Please do not add functions “for completeness”, this is not an API file for
// others but only by the core compiler.

// TODO: probably split this file into utils/….js

'use strict';

const { dictAdd, pushToDict, dictFirst } = require('../base/dictionaries');
const { kindProperties } = require('./base');

// for links, i.e., properties starting with an underscore '_':

function pushLink( obj, prop, value ) {
  const p = obj[prop];
  if (p)
    p.push( value );
  else
    Object.defineProperty( obj, prop, { value: [ value ], configurable: true, writable: true } );
}

// for annotations:

function annotationVal( anno ) {
  return anno && (anno.val === undefined || anno.val); // XSN TODO: set val for anno short form
}
function annotationIsFalse( anno ) {                   // falsy, but not null (unset)
  return anno && (anno.val === false || anno.val === 0 || anno.val === '');
}
function annotationHasEllipsis( anno ) {
  const { val } = anno || {};
  return Array.isArray( val ) && val.find( v => v.literal === 'token' && v.val === '...' );
}
function annotationLocation( anno ) {
  const { name, location } = anno;
  return {
    file: name.location.file,
    line: name.location.line,
    col: name.location.col,
    endLine: location.endLine,
    endCol: location.endCol,
  };
}

/**
 * Set compiler-calculated annotation value.
 *
 * @param {XSN.Artifact} art
 * @param {string} anno
 * @param {XSN.Location} [location]
 * @param {*} [val]
 * @param {string} [literal]
 */
function setAnnotation( art, anno, location = art.location, val = true, literal = 'boolean' ) {
  if (art[anno])  // do not overwrite user-defined including null
    return;
  art[anno] = {
    name: { path: [ { id: anno.slice(1), location } ], location },
    val,
    literal,
    $inferred: '$generated',
    location,
  };
}

// Do not share this function with CSN processors!

// The link (_artifact,_effectiveType,...) usually has the artifact as value.
// Falsy values are:
// - undefined: not computed yet, parse error (TODO: null), no ref
// - null: ref to unknown, param:true if that is not allowed (TODO: false)
// - false (only complete ref): multiple definitions, rejected
// - 0 (for _effectiveType only): circular reference
// - '' (for _origin only): no origin provided
function setLink( obj, prop, value ) {
  Object.defineProperty( obj, prop, { value, configurable: true, writable: true } );
  return value;
}
// And a variant with the most common `prop`:
function setArtifactLink( obj, value ) {
  Object.defineProperty( obj, '_artifact', { value, configurable: true, writable: true } );
  return value;
}

function linkToOrigin( origin, name, parent, prop, location, silentDep ) {
  const elem = {
    name: { location: location || origin.name.location, id: name },
    kind: origin.kind,
    location: location || origin.location,
  };
  if (origin.name.$inferred)
    elem.name.$inferred = origin.name.$inferred;
  if (parent)
    setMemberParent( elem, name, parent, prop ); // TODO: redef in template
  setLink( elem, '_origin', origin );
  // TODO: should we use silent dependencies also for other things, like
  // included elements?  (Currently for $inferred: 'expanded' only)
  if (silentDep)
    dependsOnSilent( elem, origin );
  else
    dependsOn( elem, origin, location );
  return elem;
}

function proxyCopyMembers( art, dictProp, originDict, location, kind ) {
  art[dictProp] = Object.create( null );
  for (const name in originDict) {
    const origin = originDict[name];
    const member = linkToOrigin( origin, name, art, dictProp,
                                 location || origin.location, true );
    member.$inferred = 'expanded';
    if (kind)
      member.kind = kind;
    if (kind && origin.masked)  // TODO: remove!
      member.masked = Object.assign( { $inferred: 'nav' }, origin.masked );
  }
}

/**
 * Set the member `elem` to have a _parent link to `parent` and a corresponding
 * _main link.  Also set the member's name accordingly, where argument `name`
 * is most often the property `elem.name.id`.
 *
 * If argument `prop` is provided, add `elem` to the dictionary of that name,
 * e.g. `elements`.
*/
function setMemberParent( elem, name, parent, prop ) {
  if (prop) {              // extension or structure include
    // TODO: consider nested ARRAY OF and RETURNS, COMPOSITION OF type
    const p = parent.items || parent.targetAspect || parent;
    if (!(prop in p))
      p[prop] = Object.create(null);
    dictAdd( p[prop], name, elem );
  }
  if (parent._outer && parent._outer.items) // TODO: remove for items, too
    parent = parent._outer;
  setLink( elem, '_parent', parent );
  setLink( elem, '_main', parent._main || parent );
  const parentName = parent.name || parent._outer?.name;
  if (parentName) // may not be available in e.g. cast() - TODO recheck (#9503)
    elem.name.absolute = parentName.absolute;
  if (!parentName || name == null)
    return;
  const normalized = kindProperties[elem.kind].normalized || elem.kind;
  [ 'element', 'alias', 'select', 'param', 'action' ].forEach( ( kind ) => {
    if (normalized === kind)
      elem.name[kind] = (parentName[kind] != null && kind !== 'select' && kind !== 'alias') ? `${ parentName[kind] }.${ name }` : name;

    else if (parentName[kind] != null)
      elem.name[kind] = parentName[kind];

    else
      delete elem.name[kind];
  });
  // try { throw new CompilerAssertion('Foo') } catch (e) { elem.name.stack = e; };
}

/**
 * Adds a dependency user -> art with the given location.
 *
 * @param {XSN.Artifact} user
 * @param {XSN.Artifact} art
 * @param {XSN.Location} location
 */
function dependsOn( user, art, location ) {
  if (!user._deps)
    setLink( user, '_deps', [] );
  user._deps.push( { art, location } );
}

/**
 * Same as "dependsOn" but the dependency from user -> art is silent,
 * i.e. not reported to the user.
 *
 * @param {XSN.Artifact} user
 * @param {XSN.Artifact} art
 */
function dependsOnSilent( user, art ) {
  if (!user._deps)
    setLink( user, '_deps', [] );
  user._deps.push( { art } );
}

function storeExtension( elem, name, prop, parent, block ) {
  if (prop === 'enum')
    prop = 'elements';
  setLink( elem, '_block', block );
  const kind = `_${ elem.kind }`; // _extend or _annotate
  if (!parent[kind])
    setLink( parent, kind, {} );
  // if (name === '' && prop === 'params') {
  //   pushToDict( parent[kind], 'returns', elem ); // not really a dict
  //   return;
  // }
  if (!parent[kind][prop])
    parent[kind][prop] = Object.create(null);
  pushToDict( parent[kind][prop], name, elem );
}

/** @type {(a: any, b: any) => boolean} */
const testFunctionPlaceholder = () => true;

// Return path step if the path navigates along an association whose final type
// satisfies function `test`; "navigates along" = last path item not considered
// without truthy optional argument `alsoTestLast`.
function withAssociation( ref, test = testFunctionPlaceholder, alsoTestLast = false ) {
  for (const item of ref.path || []) {
    const art = item && item._artifact; // item can be null with parse error
    if (art && art._effectiveType && art._effectiveType.target && test( art._effectiveType, item ))
      return (alsoTestLast || item !== ref.path[ref.path.length - 1]) && item;
  }
  return false;
}

/**
 * Return string 'A.B.C' for parsed source `A.B.C` (is vector of ids with
 * locations).
 *
 * @param {XSN.Path} path
 */
function pathName( path ) {
  return (path && !path.broken) ? path.map( id => id.id ).join('.') : '';
}

/**
 * Generates an XSN path out of the given name. Path segments are delimited by a dot.
 * Each segment will have the given location assigned.
 *
 * @param {CSN.Location} location
 * @param {string} name
 * @returns {XSN.Path}
 */
function splitIntoPath( location, name ) {
  return name.split('.').map( id => ({ id, location }) );
}

/**
 * @param {CSN.Location} location
 * @param  {...any} args
 */
function augmentPath( location, ...args ) {
  return { path: args.map( id => ({ id, location }) ), location };
}

function copyExpr( expr, location, skipUnderscored, rewritePath ) {
  if (!expr || typeof expr !== 'object')
    return expr;
  else if (Array.isArray(expr))
    return expr.map( e => copyExpr( e, location, skipUnderscored, rewritePath ) );

  const proto = Object.getPrototypeOf( expr );
  if (proto && proto !== Object.prototype) // do not copy object from special classes
    return expr;
  const r = Object.create( proto );
  for (const prop of Object.getOwnPropertyNames( expr )) {
    const pd = Object.getOwnPropertyDescriptor( expr, prop );
    if (!pd.enumerable) { // should include all properties starting with _
      if (!skipUnderscored ||
          prop === '_artifact' || prop === '_navigation' || prop === '_effectiveType')
        Object.defineProperty( r, prop, pd );
    }
    else if (!proto) {
      r[prop] = copyExpr( pd.value, location, skipUnderscored, rewritePath );
    }
    else if (prop === 'location') {
      r[prop] = location || pd.value;
    }
    else if (prop.charAt(0) !== '$' || prop === '$inferred') {
      r[prop] = copyExpr( pd.value, location, skipUnderscored, rewritePath );
    }
    else if (!skipUnderscored) {  // skip $ properties
      Object.defineProperty( r, prop, pd );
    }
  }
  return r;
}

function testExpr( expr, pathTest, queryTest, user ) {
  // TODO: also check path arguments/filters
  if (!expr || typeof expr === 'string') { // parse error or keywords in {xpr:...}
    return false;
  }
  else if (Array.isArray(expr)) {
    return expr.some( e => testExpr( e, pathTest, queryTest, user ) );
  }
  else if (expr.path) {
    return pathTest( expr, user );
  }
  else if (expr.query) {
    return queryTest( expr.query, user );
  }
  else if (expr.op && expr.args) {
    // unnamed args => array
    if (Array.isArray(expr.args))
      return expr.args.some( e => testExpr( e, pathTest, queryTest, user ) );
    // named args => dictionary
    for (const namedArg of Object.keys(expr.args)) {
      if (testExpr(expr.args[namedArg], pathTest, queryTest, user))
        return true;
    }
  }
  return false;
}

// Return true if the path `item` with a final type `assoc` has a max target
// cardinality greater than one - either specified on the path item or assoc type.
function targetMaxNotOne( assoc, item ) {
  // Semantics of associations without provided cardinality: [*,0..1]
  const cardinality = item.cardinality || assoc.cardinality;
  return cardinality && cardinality.targetMax && cardinality.targetMax.val !== 1;
}

// Query tree post-order traversal - called for everything which contributes to the query
// i.e. is necessary to calculate the elements of the query
// except "real ones": operands of UNION etc, JOIN with ON, and sub queries in FROM
// NOTE: does not run on non-referred sub queries!  Consider using ‹main›.$queries instead!
function traverseQueryPost( query, simpleOnly, callback ) {
  if (!query)                   // parser error
    return;
  if (!query.op) {              // in FROM (not JOIN)
    if (query.query)            // subquery
      traverseQueryPost( query.query, simpleOnly, callback );
    return;
  }
  if (simpleOnly) {
    const { from } = query;
    if (!from || from.join)     // parse error or join
      return;                   // ok are: path or simple sub query (!)
  }
  if (query.from) {             // SELECT
    traverseQueryPost( query.from, simpleOnly, callback );
    // console.log('FC:')
    callback( query );
    // console.log('FE:')
  }
  else if (query.args) {             // JOIN, UNION, INTERSECT
    if (!query.join && simpleOnly == null) {
      // enough for elements: traverse only first args for UNION/INTERSECT
      // TODO: we might use this also when we do not rewrite associations
      // in non-referred sub queries
      traverseQueryPost( query.args[0], simpleOnly, callback );
    }
    else {
      for (const q of query.args)
        traverseQueryPost( q, simpleOnly, callback );
      // The ON condition has to be traversed extra, because it must be evaluated
      // after the complete FROM has been traversed.  It is also not necessary to
      // evaluate it in populateQuery().
    }
  }
  // else: with parse error (`select from <EOF>`, `select distinct from;`)
}

// Call callback on all queries in dependency order, i.e. starting with query Q
// 1. sub queries in FROM sources of Q
// 2. Q itself, except if non-referred query, but with right UNION parts
// 3. sub queries in ON in FROM of Q
// 4. sub queries in columns, WHERE, HAVING
function traverseQueryExtra( main, callback ) {
  if (!main.$queries)
    return;
  // with a top-level UNION, $queries[0] is just the left
  traverseQueryPost( main.query, false, (q) => { // also with right of UNION (to be compatible)
    setLink( q, '_status', 'extra' );
    callback( q );
  } );
  for (const query of main.$queries.slice(1)) {
    if (query._status === 'extra' || query._parent.kind === '$tableAlias')
      continue; // if parent is alias, query is FROM source -> run by traverseQueryPost
    // we are now in the top-level (parent is entity) or a non-referred query (parent is query)
    setLink( query, '_status', 'extra' ); // do not call callback() in non-referred query
    // console.log( 'A:', query.name,query._status)
    traverseQueryPost( query, null, (q) => {
      if (q._status !== 'extra') {
        // console.log( 'T:', q.name)
        setLink( q, '_status', 'extra' );
        callback( q );
      }
      // else console.log( 'E:', q.name)
    } );
  }
}

// Returns what was available at view._from[0] before:
// (think first whether to really use this function)
function viewFromPrimary( view ) {
  let query = view.$queries?.[0];
  while (query?._origin?.kind === 'select') // sub query in from
    query = query._origin;
  return dictFirst( query?.$tableAliases );
}

// About Helper property $expand for faster the XSN-to-CSN transformation
// - null/undefined: artifact, member, items does not contain expanded members
// - 'origin': all expanded (sub) elements have no new target/on and no new annotations
//             that value is only on elements, types, and params -> no other members
//             when set, only on elem/art with expanded elements
// - 'target': all expanded (sub) elements might only have new target/on, but
//             no individual annotations on any (sub) member
//             when set, traverse all parents where the value has been 'origin' before
// - 'annotate': at least one inferred (sub) member has an individual annotation,
//               not counting propagated ones; set up to the definition (main artifact)
//               (only set with anno on $inferred elem), annotate “beats” target
// Usage according to CSN flavor:
// - gensrc: do not render inferred elements (including expanded elements),
//           collect annotate statements with value 'annotate'
// - client: do not render expanded sub elements if artifact/member is no type, has a type,
//           has $expand = 'origin', and all its _origin also have $expand = 'origin'
//           (might sometimes render the elements unnecessarily, which is not wrong)
// - universal: do not render expanded sub elements if $expand = 'origin'
function setExpandStatus( elem, status ) {
  // set on element
  while (elem._main) {
    elem = elem._parent;
    if (status === 'annotate' ? elem.$expand === 'annotate' : elem.$expand !== 'origin')
      return;
    elem.$expand = status;    // meaning: expanded, containing assocs
    for (let line = elem.items; line; line = line.items)
      line.$expand = status; // to-csn just uses the innermost $expand
  }
}

function setExpandStatusAnnotate( elem, status ) {
  for (;;) {
    if (elem.$expand === status)
      return;                 // already set
    elem.$expand = status;    // meaning: expanded, containing annos
    for (let line = elem.items; line; line = line.items)
      line.$expand = status; // to-csn just uses the innermost $expand
    if (!elem._main)
      return;
    elem = elem._parent;
  }
}

function isDirectComposition( art ) {
  const type = art.type && art.type.path;
  return type && type[0] && type[0].id === 'cds.Composition';
}

module.exports = {
  pushLink,
  annotationVal,
  annotationIsFalse,
  annotationHasEllipsis,
  annotationLocation,
  setAnnotation,
  setLink,
  setArtifactLink,
  linkToOrigin,
  proxyCopyMembers,
  dependsOn,
  dependsOnSilent,
  setMemberParent,
  storeExtension,
  withAssociation,
  pathName,
  augmentPath,
  splitIntoPath,
  copyExpr,
  testExpr,
  targetMaxNotOne,
  traverseQueryPost,
  traverseQueryExtra,
  viewFromPrimary,
  setExpandStatus,
  setExpandStatusAnnotate,
  isDirectComposition,
};
