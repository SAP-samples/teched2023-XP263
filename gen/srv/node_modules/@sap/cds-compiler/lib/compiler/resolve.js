// Compiler phase "resolve": resolve all references

// The resolve phase tries to find the artifacts (and elements) for all
// references in the augmented CSN.  If there are unresolved references, this
// compiler phase fails with an error containing a vector of corresponding
// messages (alternatively, we could just store this vector in the CSN).

// References are resolved according to the scoping rules of CDS specification.
// That means, the first name of a reference path is not only searched in the
// current environments, but also in the parent environments, with the source
// as second-last, and the environment for builtins as the last search
// environment.

// For all type references, we set the property `type._artifact`, the latter is
// the actual type definition.

// If the referred type definition has a `parameters` property, we use it to
// transform the `$typeArgs` property (sibling to the `type` property`) to
// named properties.  See function `resolveTypeExpr` below for details.

// Example 'file.cds' (see './define.js' for the CSN before "resolve"):
//   type C { elem: String(4); }
//
// The corresponding definition of element "elem" looks as follows:
//   {
//     kind: 'element',
//     name: { id: 'elem', component: 'elem', location: ... }
//     type: { absolute: 'cds.String', _artifact: {...}, path: ...},
//     length: { val: 4, location: <of the number literal> },
//     location: ..., _parent: ...
//   }

// Potential file names:
// lookup-refs / memorize:  main refs loop (phase 2)
// monitor-refs: resolve-refs (not leading to new defs/elems)
// repair-props: rewrite, late extensions
// test-model: cycle detection, late tests (currently in checks)

'use strict';

const {
  forEachDefinition,
  forEachMember,
  forEachGeneric,
  forEachInOrder,
} = require('../base/model');
const { dictAdd } = require('../base/dictionaries');
const { dictLocation } = require('../base/location');
const { weakLocation } = require('../base/messages');
const { combinedLocation } = require('../base/location');
const { typeParameters } = require('./builtins');

const {
  pushLink,
  setLink,
  setArtifactLink,
  setMemberParent,
  withAssociation,
  dependsOn,
  dependsOnSilent,
  testExpr,
  targetMaxNotOne,
  traverseQueryPost,
} = require('./utils');

const detectCycles = require('./cycle-detector');

const $location = Symbol.for('cds.$location');

const $inferred = Symbol.for('cds.$inferred');

// Export function of this file.  Resolve type references in augmented CSN
// `model`.  If the model has a property argument `messages`, do not throw
// exception in case of an error, but push the corresponding error object to
// that property (should be a vector).
function resolve( model ) {
  // const { options } = model;
  // Get shared functionality and the message function:
  const {
    info, warning, error, message,
  } = model.$messageFunctions;
  const {
    resolvePath,
    createRemainingAnnotateStatements,
    effectiveType,
    getOrigin,
    resolveType,
    resolveTypeArgumentsUnchecked,
  } = model.$functions;
  const { environment } = model.$volatileFunctions;
  Object.assign( model.$functions, {
    resolveExpr,
  } );

  /** @type {any} may also be a boolean */

  return doResolve();

  function doResolve() {
    // Phase 1: check paths in usings has been moved to kick-start.js Phase 2:
    // calculate/init view elements & collect views in order:
    // TODO: It might be that we need to call propagateKeyProps() and
    // addImplicitForeignKeys() in populate.js, as we might need to know the
    // foreign keys in populate.js (foreign key access w/o JOINs).

    // Phase 2+3: calculate keys along simple queries in collected views:
    model._entities = Object.values( model.definitions )
      .filter( art => art.$effectiveSeqNo )
      .sort( (x, y) => x.$effectiveSeqNo - y.$effectiveSeqNo );
    model._entities.forEach( setNavigationProjections );
    model._entities.forEach( propagateKeyProps );
    // While most dependencies leading have been added at this point, new
    // cycles could be added later (e.g. via assocs in where conditions),
    // i.e. keep cycle detection with messages at the end (or after phase 4).

    // Phase 4: resolve all artifacts:
    forEachDefinition( model, resolveRefs );
    forEachGeneric( model, 'vocabularies', resolveRefs );
    // create “super” ANNOTATE statements for annotations on unknown artifacts:
    createRemainingAnnotateStatements();
    // report cyclic dependencies:
    detectCycles( model.definitions, ( user, art, location ) => {
      if (location) {
        error( 'ref-cyclic', [ location, user ], { art }, {
          std: 'Illegal circular reference to $(ART)',
          element: 'Illegal circular reference to element $(MEMBER) of $(ART)',
        });
      }
    });
    return model;
  }

  //--------------------------------------------------------------------------
  // Phase 2+3: calculate propagated KEYs
  //--------------------------------------------------------------------------

  function setNavigationProjections( view ) {
    if (!view.$queries)
      return;
    for (const query of view.$queries) {
      forEachGeneric( query, 'elements', ( elem ) => {
        if (!elem._origin || elem.expand || !elem.value)
          return;
        // TODO: what about elements where _origin is set without value?
        // TODO: or should we push elems with `expand` sibling to extra list for
        // better messages?  (Whatever that means exaclty.)
        const nav = pathNavigation( elem.value );
        const { path } = elem.value;
        const item = path[path.length - 1];
        if (nav.navigation && nav.item === item) {
          // sourceElem, alias.sourceElem, mixin:
          // redirectImplicitly( elem, origin );
          pushLink( nav.navigation, '_projections', elem );
        }
        else if (elem._pathHead?.kind === '$inline' && path.length === 1) {
          const hpath = elem._pathHead.value?.path;
          const head = hpath?.length === 1 && hpath[0]._navigation;
          // Alias .{ elem } - but not with Alias.{ $magic }: consider for ON-rewrite
          if (head?.kind === '$tableAlias' && item.id.charAt(0) !== '$')
            pushLink( head.elements[item.id], '_projections', elem );
        }
      } );
    }
  }

  function propagateKeyProps( view ) {
    // Second argument true ensure that `key` is only propagated along simple
    // view, i.e. ref or subquery in FROM, not UNION or JOIN.
    traverseQueryPost( view.query, true, ( query ) => {
      if (!withExplicitKeys( query ) && inheritKeyProp( query ) &&
          withKeyPropagation( query )) // now the part with messages
        inheritKeyProp( query, true );
    } );
  }

  function withExplicitKeys( query ) {
    for (const name in query.elements) {
      const elem = query.elements[name];
      if (elem.key && !elem.$duplicates) // also those from includes
        return true;
    }
    return false;
  }

  function inheritKeyProp( query, doIt ) {
    for (const name in query.elements) {
      const elem = query.elements[name];
      // no key prop for duplicate elements or additional specified elements:
      const key = !elem.$duplicates && !elem.expand && inheritedSourceKeyProp( elem );
      if (key) {
        if (!doIt)
          return true;
        elem.key = { location: elem.value.location, val: key.val, $inferred: 'query' };
      }
    }
    return false;
  }

  function inheritedSourceKeyProp( { value, _pathHead } ) {
    if (!value || !value.path)
      return null;
    const nav = pathNavigation( value );
    const item = value.path[value.path.length - 1];
    if (nav.navigation && nav.item === item)
      return item._artifact?.key;
    if (value.path.length !== 1 || _pathHead?.kind !== '$inline')
      return null;
    const hpath = _pathHead.value?.path;
    const head = hpath?.length === 1 && hpath[0]._navigation;
    return head?.kind === '$tableAlias' && item._artifact?.key;
  }

  function primarySourceNavigation( aliases ) {
    for (const name in aliases)
      return aliases[name].elements;
    return undefined;
  }

  function withKeyPropagation( query ) {
    const { from } = query;
    if (!from)                  // parse error SELECT FROM <EOF>
      return false;

    let propagateKeys = true;   // used instead early RETURN to get more messages
    const toMany = withAssociation( from, targetMaxNotOne, true );
    if (toMany) {
      propagateKeys = false;
      info( 'query-from-many', [ toMany.location, query ], { art: toMany },
            {
              // eslint-disable-next-line max-len
              std: 'Key properties are not propagated because a to-many association $(ART) is selected',
              // eslint-disable-next-line max-len
              element: 'Key properties are not propagated because a to-many association $(MEMBER) of $(ART) is selected',
            } );
    }
    // Check that all keys from the source are projected:
    const notProjected = [];    // we actually push to the array
    const navElems = primarySourceNavigation( query.$tableAliases );
    for (const name in navElems) {
      const nav = navElems[name];
      if (nav.$duplicates)
        continue;
      const { key } = nav._origin;
      if (key && key.val && !(nav._projections && nav._projections.length))
        notProjected.push( nav.name.id );
    }
    if (notProjected.length) {
      propagateKeys = false;
      info( 'query-missing-keys', [ from.location, query ], { names: notProjected },
            {
              std: 'Keys $(NAMES) have not been projected - key properties are not propagated',
              one: 'Key $(NAMES) has not been projected - key properties are not propagated',
            } );
    }
    // Check that there is no to-many assoc used in select item:
    for (const name in query.elements) {
      const elem = query.elements[name];
      if (!elem.$inferred && elem.value &&
          testExpr( elem.value, selectTest, () => false, elem ))
        propagateKeys = false;
    }
    return propagateKeys;

    function selectTest( expr, user ) {
      const art = withAssociation( expr, targetMaxNotOne );
      if (art) {
        // ID published! Used in stakeholder project; if renamed, add to oldMessageIds
        info( 'query-navigate-many', [ art.location, user || query ], { art },
              {
                // eslint-disable-next-line max-len
                std: 'Navigating along to-many association $(ART) - key properties are not propagated',
                // eslint-disable-next-line max-len
                element: 'Navigating along to-many association $(MEMBER) of $(ART) - key properties are not propagated',
                // eslint-disable-next-line max-len
                alias: 'Navigating along to-many mixin association $(MEMBER) - key properties are not propagated',
              } );
      }
      return art;
    }
  }

  //--------------------------------------------------------------------------
  // Phase 4:
  //--------------------------------------------------------------------------

  function adHocOrMainKind( elem ) {
    const main = elem._main;
    if (main) {
      do {
        elem = elem._parent;
        if (elem.targetAspect)
          return 'aspect';        // ad-hoc composition target aspect
      } while (elem !== main);
    }
    return elem.kind;
  }
  // TODO: have $applied/$extension/$status on extension with the following values
  //  - 'unknown': artifact to extend/annotate is not defined or contains unknown member
  //  - 'referred': contains annotation for element of referred type (not yet supported)
  //  - 'inferred': only contains extension for known member, but some inferred ones
  //    (inferred = elements from structure includes, query elements)
  //  - 'original': only contains extensions on non-inferred members

  // Resolve all references in artifact or element `art`.  Do so recursively in
  // all sub elements.
  // TODO: make this function smaller
  function resolveRefs( art ) {
    if (art.builtin)
      return;
    // console.log(info( null, [ art.location, art ], {}, 'REFS').toString());
    // console.log(info( null, [ art.location, art ], { art: art.target || 'none' },
    //   'RR: $(ART)').toString());
    const parent = art._parent;
    const allowedInMain = [ 'entity', 'aspect', 'event' ].includes( adHocOrMainKind( art ) );
    const isTopLevelElement = parent && (parent.kind !== 'element' || parent.targetAspect);
    if (art.key?.val && !art.key.$inferred && !(allowedInMain && isTopLevelElement)) {
      warning( 'unexpected-key', [ art.key.location, art ],
               { '#': allowedInMain ? 'sub' : 'std', keyword: 'key' }, {
                 std: '$(KEYWORD) is only supported for elements in an entity or an aspect',
                 sub: '$(KEYWORD) is only supported for top-level elements',
               });
    }
    if (art.targetAspect && !(allowedInMain && isTopLevelElement)) {
      message( 'type-managed-composition', [ art.targetAspect.location, art ],
               { '#': allowedInMain ? 'sub' : 'std' } );
    }
    if (art.includes && !allowedInMain) {
      for (const include of art.includes) {
        const struct = include._artifact;
        if (struct && struct.kind !== 'type' && struct.elements &&
            Object.values( struct.elements ).some( e => e.targetAspect)) {
          message( 'type-managed-composition', [ include.location, art ],
                   { '#': struct.kind, art: struct } );
        }
      }
    }
    let obj = art;
    if (obj.type)             // TODO: && !obj.type.$inferred ?
      resolveTypeExpr( obj, art );
    const type = effectiveType( obj ); // make sure implicitly redirected target exists
    if (!obj.items && type && type.items) {
      // TODO: shouldn't be this part of populate.js ?
      const items = {
        location: weakLocation( (obj.type || obj).location ),
        $inferred: 'expanded',
      };
      setLink( items, '_outer', obj );
      setLink( items, '_parent', obj._parent );
      setLink( items, '_origin', type.items );
      obj.items = items;
      obj.$expand = 'origin';
    }
    if (obj.items) {            // TODO: make this a while in v2 (also items proxy)
      obj = obj.items || obj; // the object which has type properties
      effectiveType(obj);
    }
    if (obj.type) {             // TODO: && !obj.type.$inferred ?
      if (obj !== (art.returns || art)) // not already checked
        resolveTypeExpr( obj, art );
      // typeOf unmanaged assoc?  TODO: is this the right place to check this?
      // (probably better in rewriteAssociations)
      const elemtype = obj.type._artifact;
      if (elemtype && effectiveType( elemtype )) {
        const assocType = getAssocSpec( elemtype ) || {};
        if (assocType.on && !obj.on)
          obj.on = { $inferred: 'rewrite' }; // TODO: no extra rewrite here
        if (assocType.targetAspect) {
          error( 'composition-as-type-of', [ obj.type.location, art ], {},
                 'A managed aspect composition element can\'t be used as type' );
          return;
        }
        else if (assocType.on) {
          error( 'assoc-as-type-of', [ obj.type.location, art ], {},
                 'An unmanaged association can\'t be used as type' );
          return;
        }

        // Check if relational type is missing its target or if it's used directly.
        if (elemtype.category === 'relation' && obj.type.path.length > 0 &&
          !obj.target && !obj.targetAspect) {
          const isCsn = (obj._block && obj._block.$frontend === 'json');
          error('type-missing-target', [ obj.type.location, obj ],
                { '#': isCsn ? 'csn' : 'std', type: elemtype.name.absolute }, {
                  // We don't say "use 'association to <target>" because the type could be used
                  // in action parameters, etc. as well.
                  std: 'The type $(TYPE) can\'t be used directly because it\'s compiler internal',
                  csn: 'Type $(TYPE) is missing a target',
                });
        }
      }
    }
    if (obj.target) {
      // console.log(obj.name,obj._origin?.name,obj)
      if (obj._origin && obj._origin.$inferred === 'REDIRECTED')
        resolveTarget( art, obj._origin );
      // console.log(error( 'test-target', [ obj.location, obj ],
      //   { target: obj.target, kind: obj.kind }, 'Target: $(TARGET), Kind $(KIND)'));
      if (!obj.target.$inferred || obj.target.$inferred === 'aspect-composition')
        resolveTarget( art, obj );
      else
        // TODO: better write when inferred target must be redirected
        resolveRedirected( obj, obj.target._artifact );
    }
    else if (obj.kind === 'mixin') {
      // TODO: also check that the type is cds.Association or cds.Composition
      error( 'non-assoc-in-mixin', [ (obj.type || obj.name).location, art ], {},
             'Only unmanaged associations are allowed in mixin clauses' );
    }
    if (art.targetElement) {    // in foreign keys
      const target = parent && parent.target;
      if (target && target._artifact) {
        // we just look in target for the path
        // TODO: also check that we do not follow associations? no args, no filter
        resolvePath( art.targetElement, 'targetElement', art,
                     environment( target._artifact ), target._artifact );
      }
    }
    // Resolve projections/views
    // if (art.query)console.log( info( null, [art.query.location,art.query], 'VQ:' ).toString() );

    if (art.$queries)
      art.$queries.forEach( resolveQuery );

    // TODO: or should we set silent dependencies in init()?
    if (obj.elements) {           // silent dependencies
      forEachGeneric( obj, 'elements', elem => dependsOnSilent( art, elem ) );
    }
    else if (obj.targetAspect && obj.targetAspect.elements) { // silent dependencies
      forEachGeneric( obj.targetAspect, 'elements', elem => dependsOnSilent( art, elem ) );
    }
    if (obj.foreignKeys) {       // silent dependencies
      forEachGeneric( obj, 'foreignKeys', (elem) => {
        dependsOnSilent( art, elem );
      } );
      addForeignKeyNavigations( art );
    }

    resolveExpr( art.default, 'default', art );
    resolveExpr( art.value, 'expr', art, undefined, art.expand || art.inline );
    if (art.type?.$inferred === 'cast')
      inferTypePropertiesFromCast( art );
    if (art.value) {
      if (art.$syntax === 'calc')
        checkCalculatedElement(art);
      else if (art.type && !art.$inferred )
        checkStructureCast(art);
    }

    forEachMember( art, resolveRefs, art.targetAspect );

    // Set '@Core.Computed' in the Core Compiler to have it propagated...
    if (art.kind !== 'element' || art['@Core.Computed'])
      return;
    if (art.virtual && art.virtual.val ||
        art.value &&
        (!art.value._artifact || !art.value.path || // in localization view: _artifact, but no path
          art.value._artifact.kind === 'builtin' || art.value._artifact.kind === 'param' )) {
      art['@Core.Computed'] = {
        name: {
          path: [ { id: 'Core.Computed', location: art.location } ],
          location: art.location,
        },
        $inferred: '$generated',
      };
    }
  }

  function checkCalculatedElement( art ) {
    const loc = [ art.value.location, art ];
    if (art._parent.kind === 'element') {
      // TODO: Support calculated elements in structures.
      //       The checks below are already aware of those.
      message( 'def-unsupported-calc-elem', loc, { '#': 'nested' } );
    }

    const allowedInKind = [ 'entity', 'aspect', 'element' ];
    let parent = art._parent;
    while (parent.kind === 'element')
      parent = parent._parent;

    if (!allowedInKind.includes(art._main.kind)) {
      if (art.$inferred === 'include') {
        // even for include-chains, we find the correct ref due to element-expansion.
        const include = art._main.includes.find(i => i._artifact === art._origin._main);
        error('ref-invalid-calc-elem', [ include.location || art.value.location, art ],
              { '#': art._main.kind });
      }
      else {
        error( 'def-invalid-calc-elem', loc, { '#': art._main.kind } );
      }
    }
    else if (!allowedInKind.includes(parent.kind)) {
      error( 'def-invalid-calc-elem', loc, { '#': parent.kind } );
    }
    else if (effectiveType(art)?.elements) {
      if (art.type)
        error( 'type-unexpected-structure', [ art.type.location, art ], { '#': 'calc' } );
      else
        error( 'ref-unexpected-structured', [ art.value.location, art ], { '#': 'expr' } );
    }
    else {
      const noTruthyAllowed = [ 'localized', 'key', 'virtual' ];
      for (const prop of noTruthyAllowed) {
        if (art[prop]?.val) {
          // probably better than a parse error (which is good for DEFAULT vs calc),
          // also appears with parse-cdl:
          error('def-invalid-calc-elem', loc, { '#': prop });
          return; // one error is enough
        }
      }
    }
  }

  function checkStructureCast( art ) {
    const elem = (art.value.op?.val === 'cast')
      ? art.value.args[0]?._artifact
      : art.value._artifact;
    if (elem && art.type) { // has explicit type
      if (art.type._artifact?.elements) {
        error('type-cast-to-structured', [ art.type.location, art ], {},
              'Can\'t cast to structured element');
      }
      else if (elem.elements) { // TODO: calc elements
        error('type-cast-structured', [ art.type.location, art ], {},
              'Structured elements can\'t be cast to a different type');
      }
    }
  }

  // Return type containing the assoc spec (keys, on); note that no
  // propagation/rewrite has been done yet, cyclic dependency must have been
  // checked before!
  function getAssocSpec( type ) {
    // only to be called without cycles
    let unmanaged = null;
    while (type) {
      if (type.on)              // if unmanaged, continue trying to find targetAspect
        unmanaged = type;
      else if (type.foreignKeys || type.targetAspect)
        return type;
      type = getOrigin( type );
    }
    return unmanaged;
  }

  function inferTypePropertiesFromCast( elem ) {
    for (const prop of typeParameters.list) {
      if (elem.value[prop])
        elem[prop] = { ...elem.value[prop], $inferred: 'cast' };
    }
  }

  // Phase 4 - queries and associations --------------------------------------

  function resolveQuery( query ) {
    if (!query._main || !query._effectiveType) // parse error
      return;
    // TODO: or set silent dependencies in init?
    forEachGeneric( query, 'elements', elem => dependsOnSilent( query, elem ) );
    forEachGeneric( query, '$tableAliases', ( alias ) => {
      // console.log( info( null, [alias.location,alias], 'SQA:' ).toString() );
      if (alias.kind === 'mixin')
        resolveRefs( alias );   // mixin element
      else if (alias.kind !== '$self')
        // pure path has been resolved, resolve args and filter now:
        resolveExpr( alias, 'from', query._parent );
    } );
    // if (!query.$inlines) console.log('RQ:',query)
    for (const col of query.$inlines)
      resolveExpr( col.value, 'expr', col, undefined, true );
    // for (const col of query.$inlines)
    //   if (!col.value.path) throw new CompilerAssertion(col.name.element)
    if (query !== query._main._leadingQuery) // will be done later
      forEachGeneric( query, 'elements', resolveRefs );
    if (query.from)
      resolveJoinOn( query.from );
    if (query.where)
      resolveExpr( query.where, 'expr', query, query._combined );
    if (query.groupBy)
      resolveBy( query.groupBy, 'expr' );
    resolveExpr( query.having, 'expr', query, query._combined );
    if (query.$orderBy)       // ORDER BY from UNION:
      // TODO clarify: can I access the tab alias of outer queries?  If not:
      // 4th arg query._main instead query._parent.
      resolveBy( query.$orderBy, 'order-by-union', query.elements, query._parent );
    if (query.orderBy) {       // ORDER BY
    // search in `query.elements` after having checked table aliases of the current query
      resolveBy( query.orderBy, 'order-by', query.elements );
      // TODO: disallow resulting element ref if in expression!
      // Necessary to check it in the compiler as it might work with other semantics on DB!
      // (we could downgrade it to a warning if name is equal to unique source element name)
      // TODO: Some helping text mentioning an alias name would be useful
    }
    return;

    function resolveJoinOn( join ) {
      if (join && join.args) {  // JOIN
        for (const j of join.args)
          resolveJoinOn( j );
        if (join.on)
          resolveExpr( join.on, 'expr', query, query._combined );
          // TODO: check restrictions according to join "query"
      }
    }

    // Note the strange name resolution (dynamic part) for ORDER BY: the same
    // as for select items if it is an expression, but first look at select
    // item alias (i.e. like `$projection.NAME` if it is a path.  If it is an
    // ORDER BY of an UNION, do not allow any dynamic path in an expression,
    // and only allow the elements of the leading query if it is a path.
    //
    // This seem to be similar, but different in SQLite 3.22.0: ORDER BY seems
    // to bind stronger than UNION (see <SQLite>/src/parse.y), and the name
    // resolution seems to use select item aliases from all SELECTs of the
    // UNION (see <SQLite>/test/tkt2822.test).
    function resolveBy( array, mode, pathDict, q ) {
      for (const value of array ) {
        if (value)
          resolveExpr( value, mode, q || query, value.path && pathDict );
      }
    }
  }

  function resolveTarget( art, obj ) {
    if (art !== obj && obj.on && obj.$inferred !== 'REDIRECTED') {
      message( 'assoc-in-array', [ obj.on.location, art ], {},
               // TODO: also check parameter parent, two messages?
               'An association can\'t be used for arrays or parameters' );
      setArtifactLink( obj.target, undefined );
      return;
    }
    const target = resolvePath( obj.target, 'target', art );

    if (obj._pathHead && obj.type && !obj.type.$inferred && art._main && art._main.query) {
      // New association inside expand/inline: The on-condition can't be properly checked,
      // so abort early. See #8797
      error( 'query-unexpected-assoc', [ obj.name.location, art ], {},
             'Unexpected new association in expand/inline' );
      return; // avoid subsequent errors
    }

    if (obj.on) {
      if (!art._main || !art._parent.elements && !art._parent.items && !art._parent.targetAspect) {
        // TODO: test of .items a bit unclear - we should somehow restrict the
        // use of unmanaged assocs in MANY, at least with $self
        // TODO: $self usage in anonymous aspects to be corrected in Core Compiler
        const isComposition = obj.type && obj.type.path && obj.type.path[0] &&
                              obj.type.path[0].id === 'cds.Composition';
        message( 'assoc-as-type', [ obj.on.location, art ],
                 { '#': isComposition ? 'comp' : 'std' }, {
                   std: 'An unmanaged association can\'t be defined as type',
                   comp: 'An unmanaged composition can\'t be defined as type',
                 });
        // TODO: also warning if inside structure
      }
      else if (obj.$inferred !== 'REDIRECTED') {
        // TODO: extra with $inferred (to avoid messages)?
        // TODO: in the ON condition of an explicitly provided model entity
        // which is going to be implicitly redirected, we can never navigate
        // along associations, even not to the foreign keys (at least if they
        // are renamed) - introduce extra 'expected' which inspects REDIRECTED
        resolveExpr( obj.on, art.kind === 'mixin' ? 'mixin-on' : 'on', art );
      }
      else {
        const elements = Object.create( art._parent.elements );
        elements[art.name.id] = obj;
        resolveExpr( obj.on, art.kind === 'mixin' ? 'mixin-on' : 'on', art, elements );
      }
    }
    else if (art.kind === 'mixin') {
      error( 'assoc-in-mixin', [ obj.target.location, art ], {},
             'Managed associations are not allowed for MIXIN elements' );
      return; // avoid subsequent errors
    }
    else if (obj.type && !obj.type.$inferred && art._parent && art._parent.kind === 'select') {
      // New association in views, i.e. parent is a query.
      error( 'query-expected-on-condition', [ obj.target.location, art ], {},
             'Expected ON-condition for published association' );
      return; // avoid subsequent errors
    }
    else if (target && !obj.foreignKeys && target.kind === 'entity') {
      // redirected or explicit type cds.Association, ...
      if (obj.$inferred === 'REDIRECTED' || obj.type?._artifact?.internal)
        addImplicitForeignKeys( art, obj, target );
    }

    if (target && !target.$inferred) {
      if (!obj.type || obj.type.$inferred || obj.target.$inferred) { // REDIRECTED
        resolveRedirected( art, target );
      }
    }
  }

  function addImplicitForeignKeys( art, obj, target ) {
    obj.foreignKeys = Object.create(null);
    forEachInOrder( target, 'elements', ( elem, name ) => {
      if (elem.key && elem.key.val) {
        const { location } = art.target;
        const key = {
          name: { location, id: elem.name.id, $inferred: 'keys' }, // more by setMemberParent()
          kind: 'key',
          targetElement: { path: [ { id: elem.name.id, location } ], location },
          location,
          $inferred: 'keys',
        };
        setMemberParent( key, name, art );
        dictAdd( obj.foreignKeys, name, key );
        setArtifactLink( key.targetElement, elem );
        setArtifactLink( key.targetElement.path[0], elem );
        setLink( key, '_effectiveType', effectiveType(elem) );
        dependsOn(key, elem, location);
        dependsOnSilent(art, key);
      }
    });
    obj.foreignKeys[$inferred] = 'keys';
  }

  function addForeignKeyNavigations( art ) {
    art.$keysNavigation = Object.create(null);
    forEachGeneric( art, 'foreignKeys', ( key ) => {
      if (!key.targetElement || !key.targetElement.path)
        return;
      let dict = art.$keysNavigation;
      const last = key.targetElement.path[key.targetElement.path.length - 1];
      for (const item of key.targetElement.path) {
        let nav = dict[item.id];
        if (!nav) {
          nav = {};
          dict[item.id] = nav;
          if (item === last)
            setArtifactLink( nav, key );
          else
            nav.$keysNavigation = Object.create(null);
        }
        else if (item === last || nav._artifact) {
          error( 'duplicate-key-ref', [ item.location, key ], {},
                 'The same target reference has already been used in a key definition' );
          return;
        }
        dict = nav.$keysNavigation;
      }
    } );
  }

  // TODO: add this somehow to tweak-assocs.js ?
  function resolveRedirected( elem, target ) {
    setLink( elem, '_redirected', null ); // null = do not touch path steps after assoc
    const assoc = getOrigin( elem );
    const origType = assoc && effectiveType( assoc );
    if (origType === 0)
      return;
    if (!origType || !origType.target) {
      const path = (elem.value && elem.value.path);
      const loc = (path && path[path.length - 1] || elem.value || elem).location;
      error( 'redirected-no-assoc', [ loc, elem ], {},
             'Only an association can be redirected' );
      return;
    }
    else if ((elem.value || elem.expand) && elem.type && !elem.type.$inferred) {
      error( 'ref-unexpected-assoc', [ elem.type.location, elem ], { '#': 'cast' } );
      return;
    }
    // console.log(message( null, elem.location, elem, {target,art:assoc}, 'Info','RE')
    //             .toString(), elem.value)
    const nav = elem._main && elem._main.query && elem.value && pathNavigation( elem.value );
    if (nav && nav.item !== elem.value.path[elem.value.path.length - 1]) {
      if (!elem.on && origType.on) {
        error( 'rewrite-not-supported', [ elem.target.location, elem ], {},
               // TODO: Better text ?
               'The ON-condition is not rewritten here - provide an explicit ON-condition' );
        return;
      }
    }
    const origTarget = origType.target._artifact;
    if (!origTarget || !target)
      return;

    const chain = [];
    if (target === origTarget) {
      if (!elem.target.$inferred && !elem.on && !elem.foreignKeys) {
        // Only a managed redirection gets this info message.  Because otherwise
        // we'd have to check whether on-condition/foreignKeys are the same.
        // ID published! Used in stakeholder project; if renamed, add to oldMessageIds
        info( 'redirected-to-same', [ elem.target.location, elem ], { art: target },
              'The redirected target is the original $(ART)' );
      }
      setLink( elem, '_redirected', chain ); // store the chain
      return;
    }
    if (elem.foreignKeys || elem.on)
      return;          // TODO: or should we still bring an msg if nothing in common?
    // now check whether target and origTarget are "related"
    while (target.query) {
      const from = target.query.args ? {} : target.query.from;
      if (!from)
        return;                 // parse error - TODO: or UNION?
      if (!from.path) {
        const isTarget = target === elem.target._artifact;
        const op = from.op?.val || target.query.op?.val;
        const variant = (!isTarget && 'std') || (op && 'targetOp') || 'target';
        // ID published! Used in stakeholder project; if renamed, add to oldMessageIds
        info( 'redirected-to-complex', [ elem.target.location, elem ],
              { art: target, '#': variant, keyword: op || '' }, {
                std: 'Redirection involves the complex view $(ART)',
                target: 'The redirected target $(ART) is a complex view',
                // eslint-disable-next-line max-len
                targetOp: 'The redirected target $(ART) is a complex view with $(KEYWORD)',
              });
        break;
      }
      target = from._artifact;
      if (!target)
        return;
      chain.push( from );
      if (target === origTarget) {
        chain.reverse();
        setLink( elem, '_redirected', chain );
        return;
      }
    }
    let redirected = null;
    chain.reverse();
    let news = [ { chain, sources: [ target ] } ];
    const dict = Object.create(null);
    while (news.length) {
      const outer = news;
      news = [];
      for (const o of outer) {
        for (const s of o.sources) {
          const art = (s.kind === '$tableAlias') ? s._origin : s;
          if (art !== origTarget) {
            if (findOrig( o.chain, s, art ) && !redirected) // adds to news []
              redirected = false;   // do not report further error
          }
          else if (!redirected) {
            redirected = (s.kind === '$tableAlias') ? [ s, ...o.chain ] : o.chain;
          }
          else {
            error( 'redirected-to-ambiguous', [ elem.target.location, elem ], { art: origTarget },
                   'The redirected target originates more than once from $(ART)' );
            return;
          }
        }
      }
    }
    if (redirected) {
      setLink( elem, '_redirected', redirected );
    }
    else if (redirected == null) {
      error( 'redirected-to-unrelated', [ elem.target.location, elem ], { art: origTarget },
             'The redirected target does not originate from $(ART)' );
    }
    return;

    // B = proj on A, C = A x B, X = { a: assoc to A on a.Q1 = ...}, Y = X.{ a: redirected to C }
    // what does a: redirected to C means?
    // -> collect all elements Qi used in ON (corr: foreign keys)
    // -> only use an tableAlias which has propagation for all elements
    // no - error if the original target can be reached twice
    // even better: disallow complex view (try as error first)

    // eslint-disable-next-line no-shadow
    function findOrig( chain, alias, art ) {
      if (!art || dict[art.name.absolute])
        // some include ref or query source cannot be found, or cyclic ref
        return true;
      dict[art.name.absolute] = true;

      if (art.includes) {
        news.push( {
          chain: [ art, ...chain ],
          sources: art.includes
            .map( r => r._artifact )
            .filter( i => i ),  // _artifact may be `null` if the include cannot be found
        } );
      }
      const query = art._leadingQuery;
      if (!query)
        return false;           // non-query entity
      if (!query.$tableAliases) // previous error in query definition
        return true;
      const sources = [];
      for (const n in query.$tableAliases) {
        const a = query.$tableAliases[n];
        if (a.path && a.kind !== '$self' && a.kind !== 'mixin')
          sources.push( a );
      }
      if (alias.kind === '$tablealias')
        news.push( { chain: [ alias, ...chain ], sources } );
      else
        news.push( { chain, sources } );
      return false;
    }
  }

  //--------------------------------------------------------------------------
  // General resolver functions
  //--------------------------------------------------------------------------

  // Resolve the type and its arguments if applicable.
  function resolveTypeExpr( art, user ) {
    const typeArt = resolveType( art.type, user );
    if (typeArt) {
      resolveTypeArgumentsUnchecked( art, typeArt, user );
      checkTypeArguments( art, typeArt );
    }
  }

  /**
   * Check the type arguments on `artWithType`.
   * If the effective type is an array or structured type, an error is emitted.
   */
  function checkTypeArguments( artWithType, typeArt ) {
    // Note: `_effectiveType` may point to `artWithType` itself, if the type is structured.
    //       Also: For enums, it points to the enum type, which is why this trick is needed.
    // TODO(#8942): May not be necessary if effectiveType() is adapted.  Furthermore, the enum
    //              trick may be removed if effectiveType() does not stop at enums.
    // TODO: this is wrong - we must check typeArt.enum, not its effectiveType
    // TODO: this function is not complete(!): parallel `elements` and `length`, … - rework function
    const cyclic = new Set();
    let effectiveTypeArt = effectiveType( typeArt );
    while (effectiveTypeArt && effectiveTypeArt.enum && !cyclic.has(effectiveTypeArt)) {
      cyclic.add(effectiveTypeArt);
      const underlyingEnumType = getOrigin(effectiveTypeArt);
      if (underlyingEnumType)
        effectiveTypeArt = effectiveType(underlyingEnumType);
      else
        break;
    }

    if (!effectiveTypeArt)
      return; // e.g. illegal definition references

    const params = effectiveTypeArt.parameters &&
      effectiveTypeArt.parameters.map(p => p.name || p) || [];

    for (const param of typeParameters.list) {
      if (artWithType[param] !== undefined) {
        if (!params.includes(param)) {
          // Whether the type ref itself is a builtin or a custom type with a builtin as base.
          const type = getOrigin(artWithType);

          let variant;
          if (type.builtin)
            // `.type` is already a builtin: use a nicer message.
            variant = 'builtin';
          else if (effectiveTypeArt.builtin)
            // base type is a builtin, i.e. a scalar
            variant = 'type';
          else
            // effectiveType is not a builtin -> array or structured
            variant = 'non-scalar';

          // console.log(typeArt.name,artWithType.name,effectiveTypeArt.name)
          error('type-unexpected-argument', [ artWithType[param].location, artWithType ], {
            '#': variant, prop: param, art: artWithType.type, type: effectiveTypeArt,
          });
          break; // Avoid spam: Only emit the first error.
        }
        else if (!typeParameters.expectedLiteralsFor[param].includes(artWithType[param].literal)) {
          error('type-unexpected-argument', [ artWithType[param].location, artWithType ], {
            '#': 'incorrect-type',
            prop: param,
            code: artWithType[param].literal,
            names: typeParameters.expectedLiteralsFor[param],
          });
          break; // Avoid spam: Only emit the first error.
        }
      }
    }
  }

  function resolveExpr( expr, expected, user, extDict, expandOrInline ) {
    // TODO: when we have rewritten the resolvePath functions,
    // define a traverseExpr() in ./utils.js
    // TODO: extra "expected" 'expand'/'inline' instead o param `expandOrInline`
    if (!expr || typeof expr === 'string') // parse error or keywords in {xpr:...}
      return;
    if (Array.isArray(expr)) {
      expr.forEach( e => resolveExpr( e, expected, user, extDict ) );
      return;
    }

    if (expr.type) // e.g. cast( a as Integer )
      resolveTypeExpr( expr, user );

    if (expr.path) {
      if (expr.$expected === 'exists') {
        error( 'expr-unexpected-exists', [ expr.location, user ], {},
               'An EXISTS predicate is not expected here' );
        // We complain about the EXISTS before, as EXISTS subquery is also not
        // supported (avoid that word if you do not want to get tickets when it
        // will be supported), TODO: location of EXISTS
        expr.$expected = 'approved-exists'; // only complain once
      }
      if (expected instanceof Function) {
        expected( expr, user, extDict );
        return;
      }
      resolvePath( expr, expected, user, extDict );

      const last = !expandOrInline && expr.path[expr.path.length - 1];
      for (const step of expr.path) {
        if (step && (step.args || step.where || step.cardinality) &&
            step._artifact && !Array.isArray( step._artifact ) )
          resolveParamsAndWhere( step, expected, user, extDict, step === last );
      }
    }
    else if (expr.query) {
      const { query } = expr;
      if (query.kind || query._leadingQuery) { // UNION has _leadingQuery
        // traverseQueryPost( query, false, resolveQuery );
      }
      else {
        error( 'expr-no-subquery', [ expr.location, user ], {},
               'Subqueries are not supported here' );
      }
    }
    else if (expr.op && expr.args) {
      const args = Array.isArray(expr.args) ? expr.args : Object.values( expr.args );
      args.forEach( e => e && resolveExpr( e, e.$expected || expected, user, extDict ) );
    }
    if (expr.suffix)
      expr.suffix.forEach( s => s && resolveExpr( s, expected, user, extDict ) );
  }

  function resolveParamsAndWhere( step, expected, user, extDict, isLast ) {
    const alias = (step._navigation?.kind === '$tableAlias') ? step._navigation : null;
    const type = alias || effectiveType( step._artifact );
    const art = (type && type.target) ? type.target._artifact : type;
    if (!art)
      return;
    const entity = (art.kind === 'entity') &&
      (!isLast || [ 'from', 'exists', 'approved-exists' ].includes( expected )) && art;
    if (step.args)
      resolveParams( step.args, art, entity, expected, user, extDict, step.location );
    if (entity) {
      if (step.where)
        resolveExpr( step.where, 'filter', user, environment( type ) );
    }
    else if (step.where?.location || step.cardinality ) {
      const location = combinedLocation( step.where, step.cardinality );
      let variant = alias ? 'tableAlias' : 'std';
      if (expected === 'from')
        variant = 'from';
      // XSN TODO: filter$location including […]
      message( 'expr-no-filter', [ location, user ], { '#': variant }, {
        std: 'A filter can only be provided when navigating along associations',
        // to help users for `… from E:toF { toF[…].x }`
        // eslint-disable-next-line max-len
        tableAlias: 'A filter can only be provided when navigating along associations, but found table alias',
        from: 'A filter can only be provided for the source entity or associations',
      } );
    }
  }

  function resolveParams( dict, art, entity, expected, user, extDict, stepLocation ) {
    if (!entity || !entity.params) {
      let first = dict[Object.keys(dict)[0]];
      if (Array.isArray(first))
        first = first[0];
      message( 'args-no-params',
               [ dict[$location] ||
                 dictLocation( dict, first && first.name && first.name.location || stepLocation),
               user ],
               { art, '#': (entity ? 'entity' : expected ) },
               {
                 std: 'Parameters can only be provided when navigating along associations',
                 from: 'Parameters can only be provided for the source entity or associations',
                 // or extra message id for entity?
                 entity: 'Entity $(ART) has no parameters',
               } );
      return;
    }
    const exp = (expected === 'from') ? 'expr' : expected;
    if (Array.isArray(dict)) {
      message( 'args-expected-named', [ dict[0] && dict[0].location || stepLocation, user ], {},
               'Named parameters must be provided for the entity' );
      for (const a of dict)
        resolveExpr( a, exp, user, extDict );
      return;
    }
    // TODO: allow to specify expected for arguments in in specExpected
    for (const name in dict) {
      const param = art.params[name];
      const arg = dict[name];
      for (const a of Array.isArray(arg) ? arg : [ arg ]) {
        setArtifactLink( a.name, param );
        if (!param) {
          message( 'args-undefined-param', [ a.name.location, user ], { art, id: name },
                   'Entity $(ART) has no parameter $(ID)' );
        }
        resolveExpr( a, exp, user, extDict );
      }
    }
  }
}

// Return condensed info about reference in select item
// - tableAlias.elem       -> { navigation: navElem, item: path[1], tableAlias }
// - sourceElem (in query) -> { navigation: navElem, item: path[0], tableAlias }
// - mixinElem             -> { navigation: mixinElement, item: path[0] }
// - $projection.elem      -> also $self.item -> { item: path[1], tableAlias: $self }
// - $self                 -> { item: undefined, tableAlias: $self }
// - $parameters.P, :P     -> {}
// - $now, current_date    -> {}
// - undef, redef          -> {}
// With 'navigation': store that navigation._artifact is projected
// With 'navigation': rewrite its ON condition
// With navigation: Do KEY propagation
//
// TODO: re-think this function, copied in populate.js and tweak-assocs.js
function pathNavigation( ref ) {
  // currently, indirectly projectable elements are not included - we might
  // keep it this way!  If we want them to be included - be aware: cycles
  if (!ref._artifact)
    return {};
  let item = ref.path && ref.path[0];
  const root = item && item._navigation;
  if (!root)
    return {};
  if (root.kind === '$navElement')
    return { navigation: root, item, tableAlias: root._parent };
  if (root.kind === 'mixin')
    return { navigation: root, item };
  item = ref.path[1];
  if (root.kind === '$self')
    return { item, tableAlias: root };
  if (root.kind !== '$tableAlias' || ref.path.length < 2)
    return {};                // should not happen
  return { navigation: root.elements?.[item.id], item, tableAlias: root };
}

module.exports = resolve;
