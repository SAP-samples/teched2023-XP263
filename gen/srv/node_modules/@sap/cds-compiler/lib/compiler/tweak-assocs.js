// Tweak associations: rewrite keys and on conditions

'use strict';

const {
  forEachGeneric,
  forEachInOrder,
} = require('../base/model');
const { dictLocation } = require('../base/location');
const { weakLocation } = require('../base/messages');

const {
  setLink,
  setArtifactLink,
  linkToOrigin,
  copyExpr,
  traverseQueryPost,
  traverseQueryExtra,
  setExpandStatus,
} = require('./utils');

const $location = Symbol.for('cds.$location');
const $inferred = Symbol.for('cds.$inferred');

// Export function of this file.
function tweakAssocs( model ) {
  // Get shared functionality and the message function:
  const {
    info, warning, error,
  } = model.$messageFunctions;
  const {
    effectiveType,
    getOrigin,
    resolveExpr,
  } = model.$functions;
  const { environment } = model.$volatileFunctions;

  // Phase 5: rewrite associations
  model._entities.forEach( rewriteArtifact );
  // Think hard whether an on condition rewrite can lead to a new cylcic
  // dependency.  If so, we need other messages anyway.  TODO: probably do
  // another cyclic check with testMode.js
  return;


  //--------------------------------------------------------------------------
  // Phase 5: rewrite associations
  //--------------------------------------------------------------------------
  // Only top-level queries and sub queries in FROM

  function rewriteArtifact( art ) {
    // return;
    if (!art.query) {
      // console.log(message( null, art.location, art, {target:art._target},
      //   'Info','RAS').toString())
      rewriteAssociation( art );
      forEachGeneric( art, 'elements', rewriteAssociation );
    }
    else {
      traverseQueryExtra( art, ( query ) => {
        forEachGeneric( query, 'elements', rewriteAssociation );
      } );
    }
    if (art._service)
      forEachGeneric( art, 'elements', excludeAssociation );

    traverseQueryPost( art.query, false, ( query ) => {
      forEachGeneric( query, 'elements', rewriteAssociationCheck );
    } );
  }

  // function rewriteView( view ) {
  //   // TODO: we could sort according to the $effectiveSeqNo instead
  //   // (and then remove traverseQueryExtra)
  //   if (view.includes)          // entities with structure includes:
  //     forEachGeneric( view, 'elements', rewriteAssociation );
  // }

  // Check explicit ON / keys with REDIRECTED TO
  // TODO: run on all queries, but this is potentially incompatible
  // function rewriteViewCheck( view ) {
  //   traverseQueryPost( view.query, false, ( query ) => {
  //     forEachGeneric( query, 'elements', rewriteAssociationCheck );
  //   } );
  // }

  function excludeAssociation( elem ) {
    const target = elem.target && elem.target._artifact;
    if (!target || target._service) // assoc to other service is OK
      return;
    if (!elem.$inferred) {      // && !elem.target.$inferred
      info( 'assoc-target-not-in-service', [ elem.target.location, elem ],
            { target, '#': (elem._main.query ? 'select' : 'define') }, {
              std: 'Target $(TARGET) of association is outside any service', // not used
              // eslint-disable-next-line max-len
              define: 'Target $(TARGET) of explicitly defined association is outside any service',
              // eslint-disable-next-line max-len
              select: 'Target $(TARGET) of explicitly selected association is outside any service',
            } );
    }
    else {
      // ID published! Used in stakeholder project; if renamed, add to oldMessageIds
      info( 'assoc-outside-service', [ elem.target.location, elem ],
            { target },
            'Association target $(TARGET) is outside any service' );
    }
  }

  function rewriteAssociationCheck( element ) {
    const elem = element.items || element; // TODO v2: nested items
    if (elem.elements)
      forEachGeneric( elem, 'elements', rewriteAssociationCheck );
    if (!elem.target)
      return;
    if (elem.on && !elem.on.$inferred) {
      const assoc = getOrigin( elem );
      if (assoc && assoc.foreignKeys) {
        error( 'rewrite-key-for-unmanaged', [ elem.on.location, elem ],
               { keyword: 'on', art: assocWithExplicitSpec( assoc ) },
               // eslint-disable-next-line max-len
               'Do not specify an $(KEYWORD) condition when redirecting the managed association $(ART)' );
      }
    }
    else if (elem.foreignKeys && !inferredForeignKeys( elem.foreignKeys )) {
      const assoc = getOrigin( elem );
      if (assoc && assoc.on) {
        error( 'rewrite-on-for-managed',
               [ elem.foreignKeys[$location] || dictLocation( elem.foreignKeys ), elem ],
               { art: assocWithExplicitSpec( assoc ) },
               'Do not specify foreign keys when redirecting the unmanaged association $(ART)' );
      }
      else if (assoc && assoc.foreignKeys) {
        // same sequence is not checked
        rewriteKeysMatch( elem, assoc );
        rewriteKeysCovered( assoc, elem );
      }
    }
  }

  function rewriteKeysMatch( thisAssoc, otherAssoc ) {
    const { foreignKeys } = thisAssoc;
    for (const name in foreignKeys) {
      if (otherAssoc.foreignKeys[name])
        continue;               // we would do a basic type check later
      const key = foreignKeys[name];
      const baseAssoc = assocWithExplicitSpec( otherAssoc );
      if (inferredForeignKeys( baseAssoc.foreignKeys )) { // still inferred = via target keys
        error( 'rewrite-key-not-matched-implicit', [ key.name.location, key ],
               { name, target: baseAssoc.target },
               'No key $(NAME) is defined in original target $(TARGET)' );
      }
      else {
        error( 'rewrite-key-not-matched-explicit', [ key.name.location, key ],
               { name, art: baseAssoc },
               'No foreign key $(NAME) is specified in association $(ART)' );
      }
    }
  }

  function rewriteKeysCovered( thisAssoc, otherAssoc ) {
    const names = [];
    const { foreignKeys } = thisAssoc;
    for (const name in foreignKeys) {
      if (!otherAssoc.foreignKeys[name])
        names.push( name );
    }
    if (names.length) {
      const loc = otherAssoc.foreignKeys[$location] || dictLocation( otherAssoc.foreignKeys );
      const location = loc && (!loc.endCol ? loc : {
        file: loc.file,
        line: loc.endLine,
        col: loc.endCol - 1,
        endLine: loc.endLine,
        endCol: loc.endCol,
      } );
      const baseAssoc = assocWithExplicitSpec( thisAssoc );
      if (inferredForeignKeys( baseAssoc.foreignKeys )) { // still inferred = via target keys
        error( 'rewrite-key-not-covered-implicit', [ location, otherAssoc ],
               { names, target: baseAssoc.target },
               {
                 std: 'Specify keys $(NAMES) of original target $(TARGET) as foreign keys',
                 one: 'Specify key $(NAMES) of original target $(TARGET) as foreign key',
               } );
      }
      else {
        error( 'rewrite-key-not-covered-explicit', [ location, otherAssoc ],
               { names, art: otherAssoc },
               {
                 std: 'Specify foreign keys $(NAMES) of association $(ART)',
                 one: 'Specify foreign key $(NAMES) of association $(ART)',
               } );
      }
    }
  }

  function assocWithExplicitSpec( assoc ) {
    while (assoc.foreignKeys && inferredForeignKeys( assoc.foreignKeys, 'keys') ||
           assoc.on && assoc.on.$inferred)
      assoc = getOrigin( assoc );
    return assoc;
  }

  function rewriteAssociation( element ) {
    let elem = element.items || element; // TODO v2: nested items
    if (elem.elements)
      forEachGeneric( elem, 'elements', rewriteAssociation );
    if (!originTarget( elem ))
      return;
    // console.log(message( null, elem.location, elem,
    // {art:assoc,target,ftype:JSON.stringify(ftype)}, 'Info','RA').toString())

    // With cyclic dependencies on select items, testing for the _effectiveType to
    // be 0 (test above) is not enough if we we have an explicit redirection
    // target -> avoid infloop ourselves with _status.
    // TODO: this should be good now
    const chain = [];
    while (!elem.on && !elem.foreignKeys) {
      chain.push( elem );
      if (elem._status === 'rewrite') { // circular dependency (already reported)
        for (const e of chain)
          setLink( e, '_status', null ); // XSN TODO: nonenum _status -> enum $status
        return;
      }
      setLink( elem, '_status', 'rewrite' );
      elem = getOrigin( elem );
      if (!elem || elem.builtin) // safety
        return;
    }
    chain.reverse();
    for (const art of chain) {
      setLink( elem, '_status', null );
      if (elem.on)
        rewriteCondition( art, elem );
      else if (elem.foreignKeys)
        rewriteKeys( art, elem );
      elem = art;
    }
  }

  function originTarget( elem ) {
    const assoc = !elem.expand && getOrigin( elem );
    const ftype = assoc && effectiveType( assoc );
    return ftype && ftype.target && ftype.target._artifact;
  }

  function inferredForeignKeys( foreignKeys, ignore ) {
    return foreignKeys[$inferred] && foreignKeys[$inferred] !== ignore;
  }

  function rewriteKeys( elem, assoc ) {
    // TODO: split this function: create foreign keys without `targetElement`
    // already in Phase 2: redirectImplicitly()
    // console.log(message( null, elem.location, elem, {art:assoc,target:assoc.target},
    //  'Info','FK').toString())
    forEachInOrder( assoc, 'foreignKeys', ( orig, name ) => {
      const fk = linkToOrigin( orig, name, elem, 'foreignKeys', elem.location );
      fk.$inferred = 'rewrite'; // Override existing value; TODO: other $inferred value?
      // TODO: re-check for case that foreign key is managed association
      if (orig._effectiveType !== undefined)
        setLink( fk, '_effectiveType', orig._effectiveType);
      const te = copyExpr( orig.targetElement, elem.location );
      if (elem._redirected) {
        const i = te.path[0];   // TODO: or also follow path like for ON?
        const state = rewriteItem( elem, i, i.id, elem, true );
        if (state && state !== true && te.path.length === 1)
          setArtifactLink( te, state );
      }
      fk.targetElement = te;
    });
    if (elem.foreignKeys) // Possibly no fk was set
      elem.foreignKeys[$inferred] = 'rewrite';
  }

  // TODO: there is no need to rewrite the on condition of non-leading queries,
  // i.e. we could just have on = {…}
  // TODO: re-check $self rewrite (with managed composition of aspects),
  // and actually also $self inside anonymous aspect definitions
  // (not entirely urgent as we do not analyse it further, at least sole "$self")
  function rewriteCondition( elem, assoc ) {
    // the ON condition might need to be rewritten even if the target stays the
    // same (TODO later: set status whether rewrite changes anything),
    // especially problematic are refs starting with $self:
    setExpandStatus( elem, 'target' );
    if (elem._parent && elem._parent.kind === 'element') {
      // managed association as sub element not supported yet
      error( null, [ elem.location, elem ], {},
        // eslint-disable-next-line max-len
             'Rewriting the ON-condition of unmanaged association in sub element is not supported' );
      return;
    }
    const nav = (elem._main && elem._main.query && elem.value)
      ? pathNavigation( elem.value ) // redirected source elem or mixin
      : { navigation: assoc };       // redirected user-provided
    const cond = copyExpr( assoc.on,
      // replace location in ON except if from mixin element
                           nav.tableAlias && elem.name.location );
    cond.$inferred = 'copy';
    elem.on = cond;
    // console.log(message( null, elem.location, elem, {art:assoc,target:assoc.target},
    //   'Info','ON').toString(), nav)
    const { navigation } = nav;
    if (!navigation) // TODO: what about $projection.assoc as myAssoc ?
      return;                 // should not happen: $projection, $magic, or ref to const
    // console.log(message( null, elem.location, elem, {art:assoc}, 'Info','D').toString())
    // Currently, having an unmanaged association inside a struct is not
    // supported by this function:
    if (navigation !== assoc && navigation._origin !== assoc) { // TODO: re-check
      // For "assoc1.assoc2" and "structelem1.assoc2"
      if (elem._redirected !== null) { // null = already reported
        error( 'rewrite-not-supported', [ elem.target.location, elem ], {},
               'The ON-condition is not rewritten here - provide an explicit ON-condition' );
      }
      return;
    }
    if (!nav.tableAlias || nav.tableAlias.path) {
      resolveExpr( cond, rewriteExpr, elem, nav.tableAlias );
    }
    else {
      // TODO: support that, now that the ON condition is rewritten in the right order
      error( null, [ elem.value.location, elem ], {},
             'Selecting unmanaged associations from a sub query is not supported' );
    }
    cond.$inferred = 'rewrite';
  }

  function rewriteExpr( expr, assoc, tableAlias ) {
    // Rewrite ON condition (resulting in outside perspective) for association
    // 'assoc' in query or including entity from ON cond of mixin element /
    // element in included structure / element in source ref/d by table alias.

    // TODO: complain about $self (unclear semantics)
    // console.log( info(null, [assoc.name.location, assoc],
    //       { art: expr._artifact, names: expr.path.map(i=>i.id) }, 'A').toString(), expr.path)

    if (!expr.path || !expr._artifact)
      return;
    if (!assoc._main)
      return;
    if (tableAlias) { // from ON cond of element in source ref/d by table alias
      const source = tableAlias._origin;
      const root = expr.path[0]._navigation || expr.path[0]._artifact;
      // console.log( info(null, [assoc.name.location, assoc],
      //                   { names: expr.path.map(i=>i.id), art: root }, 'TA').toString())
      if (!root || root._main !== source)
        return;                 // not $self or source element
      if (expr.scope === 'param' || root.kind === '$parameters')
        return;                 // are not allowed anyway - there was an error before
      const item = expr.path[root.kind === '$self' ? 1 : 0];
      // console.log('YE', assoc.name, item, root.name, expr.path)
      const elem = navProjection( item && tableAlias.elements[item.id], assoc );
      rewritePath( expr, item, assoc, elem, assoc.value.location );
    }
    else if (assoc._main.query) { // from ON cond of mixin element in query
      const root = expr.path[0]._navigation || expr.path[0]._artifact;
      if (expr.scope === 'param' || root?.kind === '$parameters') {
        if (assoc.$errorReported !== 'assoc-unexpected-scope') {
          error( 'assoc-unexpected-scope', [ assoc.value.location, assoc ],
                 { id: assoc.value._artifact.name.id },
                 // eslint-disable-next-line max-len
                 'Association $(ID) can\'t be projected because its ON-condition refers to a parameter' );
          assoc.$errorReported = 'assoc-unexpected-scope';
        }
        return;
      }
      const nav = pathNavigation( expr );
      if (nav.navigation || nav.tableAlias) { // rewrite src elem, mixin, $self[.elem]
        rewritePath( expr, nav.item, assoc,
                     navProjection( nav.navigation, assoc ),
                     nav.item ? nav.item.location : expr.path[0].location );
      }
    }
    else {                     // from ON cond of element in included structure
      const root = expr.path[0]._navigation || expr.path[0]._artifact;
      if (root.builtin || root.kind !== '$self' && root.kind !== 'element')
        return;
      const item = expr.path[root.kind === '$self' ? 1 : 0];
      if (!item)
        return;                                   // just $self
      // corresponding elem in including structure
      const elem = (assoc._main.items || assoc._main).elements[item.id];
      if (!(Array.isArray(elem) ||              // no msg for redefs
            elem === item._artifact ||          // redirection for explicit def
            elem._origin === item._artifact)) {
        const art = assoc._origin;
        warning( 'rewrite-shadowed', [ elem.name.location, elem ],
                 { art: art && effectiveType( art ) },
                 {
                   // eslint-disable-next-line max-len
                   std: 'This element is not originally referred to in the ON-condition of association $(ART)',
                   // eslint-disable-next-line max-len
                   element: 'This element is not originally referred to in the ON-condition of association $(MEMBER) of $(ART)',
                 } );
      }
      rewritePath( expr, item, assoc, (Array.isArray(elem) ? false : elem), null );
    }
  }

  function rewritePath( ref, item, assoc, elem, location ) {
    const { path } = ref;
    let root = path[0];
    if (!elem) {
      if (location) {
        error( 'rewrite-not-projected', [ location, assoc ],
               { name: assoc.name.id, art: item._artifact }, {
                 // eslint-disable-next-line max-len
                 std: 'Projected association $(NAME) uses non-projected element $(ART)',
                 // eslint-disable-next-line max-len
                 element: 'Projected association $(NAME) uses non-projected element $(MEMBER) of $(ART)',
               } );
      }
      delete root._navigation;
      setArtifactLink( root, elem );
      setArtifactLink( ref, elem );
      return;
    }
    if (item !== root) {
      root.id = '$self';
      setLink( root, '_navigation', assoc._parent.$tableAliases.$self );
      setArtifactLink( root, assoc._parent );
    }
    else if (elem.name.id.charAt(0) === '$') {
      root = { id: '$self', location: item.location };
      path.unshift( root );
      setLink( root, '_navigation', assoc._parent.$tableAliases.$self );
      setArtifactLink( root, assoc._parent );
    }
    else {
      setLink( root, '_navigation', elem );
    }
    if (!elem.name)      // nothing to do for own $projection, $projection.elem
      return;            // (except having it renamed to $self)
    item.id = elem.name.id;
    let state = null;
    for (const i of path) {
      if (!state) {
        if (i === item)
          state = setArtifactLink( i, elem );
      }
      else if (i) {
        state = rewriteItem( state, i, i.id, assoc );
        if (!state || state === true)
          break;
      }
      else {
        return;
      }
    }
    if (state !== true)
      setArtifactLink( ref, state );
  }

  function rewriteItem( elem, item, name, assoc, forKeys ) {
    // TODO: for rewriting ON conditions of explicitly provided model targets,
    // we need to only rewrite the current element, not all sibling elements
    if (!elem._redirected)
      return true;
    for (const alias of elem._redirected) {
      // TODO: a message for the same situation as msg 'rewrite-shadowed'?
      if (alias.kind === '$tableAlias') { // _redirected also contains structures for includes
        // TODO: if there is a "multi-step" redirection, we should probably
        // consider intermediate "preferred" elements - not just `assoc`,
        // but its origins, too.
        const proj = navProjection( alias.elements[name], assoc );
        name = proj && proj.name && proj.name.id;
        if (!name) {
          if (!forKeys)
            break;
          setArtifactLink( item, null );
          const culprit = elem.target && !elem.target.$inferred && elem.target ||
                          (elem.value && elem.value.path &&
                           elem.value.path[elem.value.path.length - 1]) ||
                          elem;
          // TODO: probably better to collect the non-projected foreign keys
          // and have one message for all
          error( 'rewrite-undefined-key', [ weakLocation( culprit.location ), assoc ],
                 { id: item.id, art: alias._main },
                 'Foreign key $(ID) has not been found in target $(ART)' );
          return null;
        }
        item.id = name;
      }
    }
    const env = name && environment(elem);
    elem = setArtifactLink( item, env && env[name] );
    if (elem && !Array.isArray(elem))
      return elem;
    // TODO: better (extra message), TODO: do it
    error( 'query-undefined-element', [ item.location, assoc ],
           { id: name || item.id, '#': 'redirected' } );
    return (elem) ? false : null;
  }
}

function navProjection( navigation, preferred ) {
  // TODO: Info if more than one possibility?
  // console.log(navigation,navigation._projections)
  if (!navigation)
    return {};
  else if (!navigation._projections)
    return null;
  return (preferred && navigation._projections.includes( preferred ))
    ? preferred
    : navigation._projections[0] || null;
}

// Return condensed info about reference in select item
// - tableAlias.elem       -> { navigation: navElem, item: path[1], tableAlias }
// - sourceElem (in query) -> { navigation: navElem, item: path[0], tableAlias }
// - mixinElem             -> { navigation: mixinElement, item: path[0] }
// - $projection.elem      -> also $self.item -> { item: path[1], tableAlias: $self }
// - $self                 -> { item: undefined, tableAlias: $self }
// - $parameters.P, :P     -> {}
// - $now, current_date    -> {}
// - undef, redef          -> {}
// With 'navigation': store that navigation._artifact is projected
// With 'navigation': rewrite its ON condition
// With navigation: Do KEY propagation
//
// TODO: re-think this function, copied in populate.js and tweak-assocs.js
function pathNavigation( ref ) {
  // currently, indirectly projectable elements are not included - we might
  // keep it this way!  If we want them to be included - be aware: cycles
  if (!ref._artifact)
    return {};
  let item = ref.path && ref.path[0];
  const root = item && item._navigation;
  if (!root)
    return {};
  if (root.kind === '$navElement')
    return { navigation: root, item, tableAlias: root._parent };
  if (root.kind === 'mixin')
    return { navigation: root, item };
  item = ref.path[1];
  if (root.kind === '$self')
    return { item, tableAlias: root };
  if (root.kind !== '$tableAlias' || ref.path.length < 2)
    return {};                // should not happen
  return { navigation: root.elements[item.id], item, tableAlias: root };
}

module.exports = tweakAssocs;
