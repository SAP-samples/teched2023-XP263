// Populate views with elements, elements with association targets, ...

// The functionality in this file is the heart of the Core Compiler and the
// most complex part.  It essentially implements the function `environment`
// used when resolving element references: when starting a references at a
// certain definition or element, which names are allowed next?
//
// To calculate that info, the compiler might need the same info for other
// definitions.  In other words: it calls itself recursively (using an iterative
// algorithm where appropriate).  To be able to calculate that info on demand,
// the definitions need to have enough information, which must have been set in
// an earlier compiler phase.  It is essential to do things in the right order.

// TODO: It might be that we need to call propagateKeyProps() and
// addImplicitForeignKeys() in populate.js, as we might need to know the
// foreign keys in populate.js (foreign key access w/o JOINs).

'use strict';

const {
  isDeprecatedEnabled,
  forEachDefinition,
  forEachMember,
  forEachGeneric,
} = require('../base/model');
const {
  dictAdd, dictAddArray, dictFirst, dictForEach,
} = require('../base/dictionaries');
const { weakLocation } = require('../base/messages');
const { CompilerAssertion } = require('../base/error');

const { kindProperties } = require('./base');
const {
  setLink,
  setArtifactLink,
  annotationVal,
  annotationIsFalse,
  annotationLocation,
  augmentPath,
  splitIntoPath,
  linkToOrigin,
  setMemberParent,
  proxyCopyMembers,
  dependsOn,
  setExpandStatus,
  setExpandStatusAnnotate,
} = require('./utils');

const $inferred = Symbol.for('cds.$inferred');
const $location = Symbol.for('cds.$location');


// Export function of this file.
function populate( model ) {
  const { options } = model;
  // Get shared functionality and the message function:
  const {
    info, warning, error, message,
  } = model.$messageFunctions;
  const {
    resolvePath,
    attachAndEmitValidNames,
    initArtifact,
    extendArtifactBefore,
    extendArtifactAfter,
  } = model.$functions;
  model.$volatileFunctions.environment = environment;
  Object.assign( model.$functions, {
    effectiveType,
    getOrigin,
    resolveType,
  } );
  // let depth = 100;

  let effectiveSeqNo = 0;   // artifact number set after having set _effectiveType
  /** @type {any} may also be a boolean */
  let newAutoExposed = [];

  const scopedRedirections
        = !isDeprecatedEnabled( options, '_shortAutoexposed' ) &&
          !isDeprecatedEnabled( options, '_longAutoexposed' ) &&
          !isDeprecatedEnabled( options, '_noInheritedAutoexposeViaComposition' ) &&
          !isDeprecatedEnabled( options, '_noScopedRedirections' );
  const autoexposeViaComposition
        = (isDeprecatedEnabled( options, '_noInheritedAutoexposeViaComposition' ))
          ? 'Composition'
          : true;
  const redirectInSubQueries = isDeprecatedEnabled( options, '_redirectInSubQueries' );

  forEachDefinition( model, traverseElementEnvironments );
  while (newAutoExposed.length) {
    // console.log( newAutoExposed.map( a => a.name.absolute ) )
    const all = newAutoExposed;
    newAutoExposed = [];
    all.forEach( traverseElementEnvironments );
  }
  newAutoExposed = true;      // internal error if auto-expose after here
  return;

  function traverseElementEnvironments( art ) {
    navigationEnv( art );
    if (art.$queries)
      art.$queries.forEach( traverseElementEnvironments );
    if (art.mixin)
      dictForEach( art.mixin, navigationEnv );
    if (art !== art._main?._leadingQuery) // already done
      forEachMember( art, traverseElementEnvironments );
  }


  //--------------------------------------------------------------------------
  // The central functions for path resolution - must work on-demand
  //--------------------------------------------------------------------------
  // Phase 2: call effectiveType() on-demand, which also calculates view elems

  // Return effective search environment provided by artifact `art`, i.e. the
  // `artifacts` or `elements` dictionary.  For the latter, follow the `type`
  // chain and resolve the association `target`.  View elements are calculated
  // on demand.
  function environment( art, location, user, assocSpec ) {
    const env = navigationEnv( art, location, user, assocSpec );
    if (env === 0)
      return 0;
    return env && env.elements || Object.create(null);
  }

  function navigationEnv( art, location, user, assocSpec ) {
    // = effectiveType() on from-path, TODO: should actually already part of
    // resolvePath() on FROM
    if (!art)
      return undefined;
    let type = effectiveType( art );
    while (type?.items)          // TODO: disallow navigation to many sometimes
      type = effectiveType( type.items );
    if (!type?.target)
      return type;

    if (assocSpec === false) {
      // TODO: combine this with setTargetReferenceKey&Co in getPathItem?
      error( null, [ location, user ], {},
             'Following an association is not allowed in an association key definition' );
    }                   // TODO: else warning for assoc usage with falsy assocSpec
    const target = resolvePath( type.target, 'target', type );
    if (!target)
      return target;
    if (target && assocSpec && user)
      dependsOn( user, target, location || user.location );
    const effectiveTarget = effectiveType( target );
    if (effectiveTarget === 0 && location)
      dependsOn( user, user, (user.target || user.type || user.value || user).location );
    // console.log('NT:',assocSpec,!!user,target)
    return effectiveTarget;
  }

  /**
   * Return the artifact having properties which are relevant for further name
   * resolution on `art`: `target`, `elements`, `items`, also `enum`.  Make sure
   * that these properties actually exist, are complete and auto-corrected.  Cache
   * the result in property `_effectiveType`.
   *
   * - actions, functions: returns `art`, might have expanded `params`/`returns`
   * - artifacts with direct or inherited `target`, `elements`, `items`, `enum`:
   *   returns `art`, these properties might have been auto-redirected / expanded
   * - artifacts with direct or inherited scalar type: the built-in type
   * - other artifacts: the last artifact in the origin-chain, i.e. the one which
   *   has neither a type nor some value path.
   * - returns 0 with cyclic dependencies (with recursive element expansions, we
   *   have `elements: 0` instead).
   * - returns null if a relevant reference points to nothing or is corrupted
   * - returns false if a relevant reference points to a duplicate definition
   *
   * This function also infers type relevant properties:
   *
   * - views and queries: returns `art` with inferred query `elements`
   * - column with `expand`: returns `art`, usually with inferred `elements`/`items`
   * - more to come
   *
   * At the moment, it is assumed that includes, expansions, and localized has
   * been applied earlier.
   *
   * Properties which are (usually) not relevant for the name resolution, like
   * `length` and `cardinality`, cannot be simply accessed on the effective
   * artifact.  The effective artifact alone is not enough to check whether an
   * artifact is an association or composition; it also does not give you the
   * information about the technical base type of an enum.
   *
   * Calculating an effective association/composition does not imply calculating
   * its effective target.  Calculating an effective structure (entities, …)
   * does not imply calculating the effective types of its elements.  Calculating
   * an effective array does not imply calculating its effective line type.
   */
  function effectiveType( art ) {
    if (!art)
      return art;
    // if (--depth) throw Error(`ET: ${ Object.keys(art) }`)
    if (art._effectiveType !== undefined)
      return art._effectiveType;

    // console.log(message( null, art.location, art, {}, 'Info','FT').toString())
    const chain = [];
    // console.log( 'ET-START:', art.kind, art.name )
    while (art && art._effectiveType === undefined) {
      setLink( art, '_effectiveType', 0 ); // initial setting in case of cycles
      chain.push( art );
      art = getOrigin( art );
      // console.log( 'ET-GO:', art?.name )
    }
    if (art)
      art = art._effectiveType;
    if (art === 0)
      return art;

    chain.reverse();
    for (const a of chain) {
      // Without type, value.path or _origin at beginning, link to itself:
      extendArtifactBefore( a );
      art = populateArtifact( a, art ) || a;
      if (a.elements$ || a.enum$)
        mergeSpecifiedElementsOrEnum( a );
      setLink( a, '_effectiveType', art );
      a.$effectiveSeqNo = ++effectiveSeqNo;
      // console.log( 'ET-DO:', effectiveSeqNo, a?.kind, a?.name, a._extensions?.elements?.length )
      extendArtifactAfter( a ); // after setting _effectiveType (for messages)
    }
    // console.log( 'ET-END:', art?.kind, art?.name )
    return art;
  }

  function populateArtifact( art, origEffective ) {
    // Name-resolution relevant properties directly at artifact:
    // ‹view›.elements of input must have been moved (to elements$) before!
    // console.log('Q:',art.elements,art.enum,art.items,!!art.query)
    if (art.includes)           // first version of includes via effectiveTpe()
      art.includes.forEach( i => effectiveType( i._artifact ) );
    if (art.elements != null || art.enum != null || art.items != null)
      return art;
    if (art.target) {
      // try to implicitly redirect explicitly provided target:
      if (!origEffective?.target && art.kind !== 'mixin')
        redirectImplicitly( art, art );
      if (!art.expand)
        return art;
    }

    // With properties to be calculated: ----------------------------------------
    if (art.query && art.kind !== '$tableAlias') { // query entity
      const leading = art.$queries[0];
      if (!leading)             // parse error
        return null;
      // assert that there is no _effectiveType on leading (should be the case, as
      // you cannot refer to a query of another artifact)
      populateQuery( leading );
      setLink( leading, '_effectiveType', leading );
      leading.$effectiveSeqNo = ++effectiveSeqNo;
      return art;
    }
    if (art.from)
      return populateQuery( art );

    if (art.expand) {
      // TODO: test that there is no CDL-style cast with expand
      // (we could allow that later: then some basic structural check is needed)
      if (!art.value) {
        initFromColumns( art, art.expand );
        if (origEffective?.target) // consider `{ … } as x: AssocType
          redirectImplicitly( art, origEffective );
      }
      else if (art.value.path) {
        expandFromColumns( art );
      }
      // TODO: if we allow CDL-style cast with expand in the future, we need to
      // redirectImplicitly when casting to assoc type
      return art;
    }
    if (!origEffective || origEffective.builtin) // TODO: builtin test needed?
      return origEffective;

    // With inherited auto-corrected name-resolution-relevant properties: -------
    if (origEffective.target)
      return redirectImplicitly( art, origEffective ) ? art : origEffective;
    if (origEffective.elements)
      return expandElements( art, origEffective ) ? art : origEffective;
    if (origEffective.enum)
      return expandEnum( art, origEffective ) ? art : origEffective;
    if (origEffective.items)
      return expandItems( art, origEffective ) ? art : origEffective;
    if (origEffective.params || origEffective.returns)
      return expandParams( art, origEffective );
    return origEffective;
  }

  // TODO: test it in combination with top-level CAST function
  // TODO: we could probably "extend" this function to all other cases where we
  // set an _origin in Universal CSN

  // TODO: add 2nd arg `considerSecondary` used in effectiveType(): prefers a
  // predecessor without _effectiveType (includes, joins)
  function getOrigin( art ) {
    // Be careful when using it with art.target or art.enum or art.elements
    if (!art)
      return undefined;         // TODO: null?
    // if (--depth) throw Error(`GOR: ${ Object.keys(art) }`)
    if (art._origin !== undefined)
      return art._origin;
    if (art.type)               // not stored in _origin
      return resolveType( art.type, art );
    return setLink( art, '_origin', getOriginRaw( art ) );
  }

  function getOriginRaw( art ) {
    if (!art._main) {
      if (art.query)
        return getOrigin( art.$queries?.[0] );
    }
    else {
      if (art.value?.path)
        return resolvePath( art.value, 'expr', art, null );
      if (art.kind === 'select')
        return getOrigin( dictFirst( art.$tableAliases ) );
      // init sets _origin for alias to sub query, only need to handle ref here:
      if (art.kind === '$tableAlias') {
        // do not use navigationEnv(): it would always call effectiveType() on the
        // source → we would would have a deeper callstack
        const source = resolvePath( art, 'from', art._parent );
        if (!source?._main)
          return source;        // direct entity (or undefined)
        // Before having done the resolvePath cleanup, do not rely on resolvePath
        // to call effectiveType() on the last assoc of a from ref:
        const assoc = effectiveType( source );
        return resolvePath( assoc?.target, 'target', assoc );
      }
    }
    return '';
  }

  function resolveType( ref, user ) {
    if (ref._artifact !== undefined)
      return ref._artifact;
    while (user._outer)         // in items
      user = user._outer;
    if (ref.scope === 'typeOf') {
      let struct = user;
      while (struct.kind === 'element')
        struct = struct._parent;
      if (struct.kind === 'select' || struct.kind === 'annotation') {
        // `type of` in annotation definitions can't work, because csn type refs
        // always refer to definitions.
        message( 'type-unexpected-typeof', [ ref.location, user ],
                 { keyword: 'type of', '#': struct.kind } );
        // we actually refer to an element in _combined; TODO: return null if
        // not configurable; would produce illegal CSN with sub queries in FROM
      }
      else if (struct !== user._main) {
        message( 'type-unexpected-typeof', [ ref.location, user ],
                 { keyword: 'type of', '#': struct.kind } );
        return setArtifactLink( ref, null );
      }
      return resolvePath( ref, 'typeOf', user );
    }
    if (user.kind === 'event')
      return resolvePath( ref, 'eventType', user );
    if (user.kind === 'param' && user._parent &&
      (user._parent.kind === 'action' || user._parent.kind === 'function'))
      return resolvePath( ref, 'actionParamType', user );
    return resolvePath( ref, 'type', user );
  }

  function getCardinality( assoc ) {
    while (assoc?._effectiveType) {
      // if (--depth) throw Error(`GCARD: ${ Object.keys(art) }`)
      if (assoc.cardinality)
        return assoc.cardinality;
      assoc = getOrigin( assoc );
    }
    return {};
  }

  function userQuery( user ) {
    // TODO: should we set _query links in define.js?
    while (user._main) {
      if (user.kind === 'select' || user.kind === '$join')
        return user;
      user = user._parent;
    }
    return null;
  }

  // Expansions --------------------------------------------------------------


  function expandItems( art, origin ) {
    if (art.items)
      return false;
    if (origin.items === 0 || art.$inferred === 'expanded' && isInRecursiveExpansion( art )) {
      art.items = 0;            // circular
      return true;
    }
    const ref = art.type || art.value || art.name;
    const location = ref && ref.location || art.location;
    art.items = { $inferred: 'expanded', location };
    setLink( art.items, '_outer', art );
    setLink( art.items, '_parent', art._parent );
    setLink( art.items, '_origin', origin.items );
    if (!art.$expand)
      art.$expand = 'origin';   // if value stays, elements won't appear in CSN
    return true;
  }

  function expandElements( art, struct ) {
    if (art.kind === '$tableAlias') {
      proxyCopyMembers( art, 'elements', struct.elements, art.path?.location, '$navElement' );
      return true;
    }
    if (art.elements || art.kind === '$tableAlias' || art.kind === '$inline' ||
        // no element expansions for "non-proper" types like
        // entities (as parameter types) etc:
        struct.kind !== 'type' && struct.kind !== 'element' && struct.kind !== 'param' &&
        !struct._outer)
      return false;
    if (struct.elements === 0 || art.$inferred === 'expanded' && isInRecursiveExpansion( art )) {
      art.elements = 0;         // circular
      return true;
    }
    const ref = art.type || art.value || art.name;
    const location = ref && ref.location || art.location;
    // console.log( message( null, location, art, {target:struct,art}, 'Info','EXPAND-ELEM')
    //              .toString(), Object.keys(struct.elements))
    proxyCopyMembers( art, 'elements', struct.elements, weakLocation( location ) );
    // Set elements expansion status (the if condition is always true, as no
    // elements expansion will take place on artifact with existing other
    // member property):
    if (!art.$expand)
      art.$expand = 'origin';   // if value stays, elements won't appear in CSN
    // TODO: have some art.elements[SYM.$inferred] = 'expanded';
    return true;
  }

  function expandEnum( art, origin ) {
    if (art.enum)
      return false;
    const ref = art.type || art.value || art.name;
    const location = weakLocation( ref && ref.location || art.location );
    proxyCopyMembers( art, 'enum', origin.enum, weakLocation( location ) );
    // Set elements expansion status (the if condition is always true, as no
    // elements expansion will take place on artifact with existing other
    // member property):
    if (!art.$expand)
      art.$expand = 'origin';   // if value stays, elements won't appear in CSN
    art.enum[$inferred] = 'expanded';
    return true;
  }

  function expandParams( art, origin ) {
    if (!origin._main)
      return origin;            // not with entity (should not happen)
    if (origin.params)
      proxyCopyMembers( art, 'params', origin.params, null );

    if (origin.returns) {
      // TODO: make linkToOrigin() work for returns, kind/name?
      const location = weakLocation( origin.returns.location );
      art.returns = {
        name: Object.assign( {}, art.name, { id: '', param: '', location } ),
        kind: 'param',
        location,
        $inferred: 'expanded',
      };
      setLink( art.returns, '_parent', art );
      setLink( art.returns, '_main', art._main || art );
      setLink( art.returns, '_origin', origin.returns );
    }
    if (!art.$expand)
      art.$expand = 'origin';   // if value stays, elements won't appear in CSN
    return art;
  }

  /**
   * Return true iff `art` is from a recursive expansion, i.e.  if any of its
   * expanded parents (including _outer) has the same non-expansion-origin.
   */
  function isInRecursiveExpansion( art ) {
    const current = nonExpandedArtifact( art );
    if (current.$inCycle)
      return true;
    const cycle = [ current ];
    while (art.$inferred === 'expanded') {
      art = outerOrParent( art );
      const origin = nonExpandedArtifact( art );
      cycle.push( origin );
      if (origin.$inCycle || origin === current) {
        for (const a of cycle)
          a.$inCycle = true;
        return true;
      }
    }
    return false;
  }

  function outerOrParent( art ) {
    if (art._outer)
      return art._outer;
    art = art._parent;
    // TODO: think about setting _parent of elements in `items` object holding
    // `elements`, not the most outer `items` -> return art._outer || art._parent
    while (art.items)
      art = art.items;
    return art;
  }

  function nonExpandedArtifact( art ) {
    while (art.$inferred === 'expanded')
      art = art._origin;
    return art;
  }

  //--------------------------------------------------------------------------
  // Views
  //--------------------------------------------------------------------------

  // TODO: delete XSN._entities
  // TODO: delete ENTITY._from
  // TODO (after on-demand ext): delete XSN.$entity

  /**
   * Merge _specified_ elements with _inferred_ elements in the given view/element,
   * where specified elements can appear through CSN.
   *
   * We only copy annotations, since they are not part of `columns`,
   * but only appear in `elements` in CSN.
   *
   * This is important to ensure re-compilability.
   *
   * TODO: make this part of a revamped on-demand 'extend' functionality.
   *
   * @param art
   */
  function mergeSpecifiedElementsOrEnum( art ) {
    for (const id in (art.elements || art.enum)) {
      const ielem = art.elements ? art.elements[id] : art.enum[id];  // inferred element
      const selem = art.elements$ ? art.elements$[id] : art.enum$[id]; // specified element
      if (!selem) {
        info( 'query-missing-element', [ ielem.name.location, art ], { id },
              'Element $(ID) is missing in specified elements' );
      }
      else {
        let wasAnnotated = false;
        for (const prop in selem) {
          // just annotation assignments and doc comments for the moment
          if (prop.charAt(0) === '@' || prop === 'doc') {
            ielem[prop] = selem[prop];
            // required for gensrc mode of to-csn.js, otherwise the annotation
            // may be lost during recompilation.
            ielem[prop].$priority = 'annotate';
            wasAnnotated = true;
          }
        }

        if (wasAnnotated)
          setExpandStatusAnnotate(art, 'annotate');

        selem.$replacement = true;
        if (selem.elements) {
          setLink(ielem, 'elements$', selem.elements);
          delete selem.elements;
        }
        if (selem.enum) {
          setLink(ielem, 'enum$', selem.enum);
          delete selem.enum;
        }
      }
    }
    // TODO: We don't check enum$, yet! We first need to fix expansion for
    //       `cast(elem as EnumType)` (see #9421)
    for (const id in art.elements$) {
      const selem = art.elements$[id]; // specified element
      if (!selem.$replacement) {
        // console.log( 'QED:', art.name, art.kind, art.elements )
        error( 'query-unspecified-element', [ selem.name.location, selem ], { id },
               'Element $(ID) does not result from the query' );
      }
    }
  }

  function populateQuery( query ) {
    if (query._combined || !query.from || !query.$tableAliases)
      // already done or $join query or parse error
      return query;
    setLink( query, '_combined', Object.create(null) );
    query.$inlines = [];
    forEachGeneric( query, '$tableAliases', resolveTabRef );

    initFromColumns( query, query.columns );
    if (query.excludingDict) {
      for (const name in query.excludingDict)
        resolveExcluding( name, query._combined, query.excludingDict, query );
    }
    return query;

    function resolveTabRef( alias ) {
      // effectiveType() must not be called on $self, is unnecessary for mixins:
      // TODO: have a test for `select from E { a, $self.a as b, $self.{ b as c } }`
      // TODO: have a negative test for `select from E { $self.*, assoc.* }`
      // (we might have those already)
      if (alias.kind === 'mixin' || alias.kind === '$self')
        return;
      if (!alias.elements) // could be false in hierarchical JOIN - TODO: necessary?
        effectiveType( alias ); // element → $navElement expansion for $tableAlias

      forEachGeneric( { elements: alias.elements }, 'elements', ( elem, name ) => {
        if (elem.$duplicates !== true)
          dictAddArray( query._combined, name, elem, null ); // not dictAdd()
      });
    }
  }

  function resolveExcluding( name, env, excludingDict, user ) {
    if (env[name])
      return;
    /** @type {object} */
    // console.log(name,Object.keys(env),Object.keys(excludingDict))
    const compileMessageRef = info(
      'ref-undefined-excluding', [ excludingDict[name].location, user ], { name },
      'Element $(NAME) has not been found'
    );
    attachAndEmitValidNames( compileMessageRef, env );
  }

  // query columns -----------------------------------------------------------

  function expandFromColumns( elem ) {
    const path = elem.value?.path;
    if (!path || path.broken)
      return null;
    // If we allow CDL-style casts of `expand`s to associations in the future, we
    // need to ignore an explicit type, i.e. not getOrigin():
    const assoc = resolvePath( elem.value, 'expr', elem, null );
    if (!effectiveType( assoc )?.target)
      return initFromColumns( elem, elem.expand );
    const { targetMax } = path[path.length - 1].cardinality || getCardinality( assoc );
    if (targetMax && (targetMax.val === '*' || targetMax.val > 1)) {
      elem.items = { location: elem.expand[$location] };
      setLink( elem.items, '_outer', elem );
    }
    return initFromColumns( elem, elem.expand );
  }

  // TODO: make this function shorter - make part of this (e.g. setting
  // parent/name) also be part of definer.js
  // TODO: query is actually the elemParent, where the new elements are added to
  // top-level: just query, columns
  // inline: + elements (TODO: remove), colParent
  // expand: just query (which is a column/element), columns=array of expand
  function initFromColumns( query, columns, inlineHead = undefined ) {
    const elemsParent = query.items || query;
    if (!inlineHead) {
      elemsParent.elements = Object.create(null);
      if (query._main._leadingQuery === query) // never the case for 'expand'
        query._main.elements = elemsParent.elements;
    }

    for (const col of columns || [ { val: '*' } ]) {
      if (col.val === '*') {
        const siblings = wildcardSiblings( columns, query );
        expandWildcard( col, siblings, inlineHead, query );
      }
      // If neither expression (value), expand nor new association.
      if (!col.value && !col.expand && !(col.target && col.type))
        continue;             // error should have been reported by parser
      if (col.inline) {
        col.kind = '$inline';
        col.name = {};
        // a name for this internal symtab entry (e.g. '.2' to avoid clashes
        // with real elements) is only relevant for for `cdsc -R`/debugging
        const q = userQuery( query );
        q.$inlines.push( col );
        // or use userQuery( query ) in the following, too?
        setMemberParent( col, `.${ q.$inlines.length }`, query );
        initFromColumns( query, col.inline, col );
      }
      else if (!col.$replacement) {
        const id = ensureColumnName( col, query );
        col.kind = 'element';
        dictAdd( elemsParent.elements, id, col, ( name, location ) => {
          error( 'duplicate-definition', [ location, query ], { name, '#': 'element' } );
        });
        setMemberParent( col, id, query );
      }
    }
    forEachGeneric( query, 'elements', initElem );
    return true;
  }

  // TODO: probably do this already in definer.js
  function ensureColumnName( col, query ) {
    if (col.name)
      return col.name.id;
    if (col.inline || col.val === '*')
      return '';
    const path = col.value &&
        (col.value.path || !col.value.args && col.value.func && col.value.func.path);
    if (path && path.length) {
      const last = !path.broken && path.length && path[path.length - 1];
      if (last) {
        col.name = { id: last.id || '', location: last.location, $inferred: 'as' };
        return col.name.id;
      }
    }
    else if (col.value || col.expand) {
      error( 'query-req-name', [ col.value && col.value.location || col.location, query ], {},
             'Alias name is required for this select item' );
    }
    // invent a name for code completion in expression
    col.name = {
      id: '',
      location: col.value && col.value.location || col.location,
      $inferred: 'none',
    };
    return '';
  }

  function initElem( elem ) {
    // TODO: we could share code with initMembers/init() in define.js
    if (elem.type && !elem.type.$inferred)
      return;                 // explicit type -> enough or getOrigin()
    if (elem.$inferred) {
      // redirectImplicitly( elem, elem._origin );
      return;
    }
    if (!elem.type && elem.value?.type) {  // top-level CAST( expr AS type )
      if (!elem.target)   // TODO: we might issue an error if there is a target
        elem.type = { ...elem.value.type, $inferred: 'cast' };
    }
    if (elem.foreignKeys)       // REDIRECTED with explicit foreign keys
      forEachGeneric( elem, 'foreignKeys', (key, name) => initKey( key, name, elem ) );
  }

  function initKey( key, name, elem ) {
    setLink( key, '_block', elem._block );
    setMemberParent( key, name, elem ); // TODO: set _block here if not present?
  }

  // col ($replacement set before *)
  // false if two cols have same name
  function wildcardSiblings( columns, query ) {
    const siblings = Object.create(null);
    if (!columns)
      return siblings;

    let seenWildcard = null;
    for (const col of columns) {
      const id = ensureColumnName( col, query );
      if (id) {
        col.$replacement = !seenWildcard;
        siblings[id] = !(id in siblings) && col;
      }
      else if (col.val === '*') {
        seenWildcard = true;
      }
    }
    return siblings;
  }

  // TODO: disallow $self.elem.* and $self.*, toSelf.* (circular dependency)
  function expandWildcard( wildcard, siblingElements, colParent, query ) {
    const { elements } = query.items || query;
    let location = wildcard.location || query.from && query.from.location || query.location;
    const inferred = query._main.$inferred;
    const excludingDict = (colParent || query).excludingDict || Object.create(null);

    const envParent = wildcard._pathHead; // TODO: rename _pathHead to _pathEnv
    // console.log('S1:',location.line,location.col,
    //             envParent&&!!envParent._origin&&envParent._origin.name)
    const env = columnEnv( envParent, query );
    // if (envParent) console.log('S2:',location.line,location.col,
    //             envParent?.name,envParent?._origin?.name,
    //             Object.keys(env),Object.keys(elements))
    for (const name in env) {
      const navElem = env[name];
      // TODO: remove all access to masked (use 'grep')
      if (excludingDict[name] || navElem.masked && navElem.masked.val)
        continue;
      const sibling = siblingElements[name];
      if (sibling) {          // is explicitly provided (without duplicate)
        if (!inferred && !envParent) // not yet for expand/inline
          reportReplacement( sibling, navElem, query );
        if (!sibling.$replacement) {
          sibling.$replacement = true;
          sibling.kind = 'element';
          dictAdd( elements, name, sibling, ( _name, loc ) => {
            // there can be a definition from a previous inline with the same name:
            error( 'duplicate-definition', [ loc, query ], { name, '#': 'element' } );
          });
          setMemberParent( sibling, name, query );
        }
        // else {
        //   sibling.$inferred = 'query';
        // }
      }
      else if (Array.isArray(navElem)) {
        const names = navElem.filter( e => !e.$duplicates)
          .map( e => `${ e.name.alias }.${ e.name.element }` );
        if (names.length) {
          error( 'wildcard-ambiguous', [ location, query ], { id: name, names },
                 'Ambiguous wildcard, select $(ID) explicitly with $(NAMES)' );
        }
      }
      else {
        location = weakLocation( location );
        const origin = envParent ? navElem : navElem._origin;
        const elem = linkToOrigin( origin, name, query, null, location );
        // TODO: check assocToMany { * }
        dictAdd( elements, name, elem, ( _name, loc ) => {
          // there can be a definition from a previous inline with the same name:
          error( 'duplicate-definition', [ loc, query ], { name, '#': 'element' } );
        });
        elem.$inferred = '*';
        elem.name.$inferred = '*';
        if (envParent)
          setWildcardExpandInline( elem, envParent, origin, name, location );
        else
          setElementOrigin( elem, navElem, name, location );
      }
    }
    if (envParent || query.kind !== 'select') {
      // already done in populateQuery (TODO: change that and check whether
      // `*` is allowed at all in definer)
      const user = colParent || query;
      for (const name in user.excludingDict)
        resolveExcluding( name, env, excludingDict, query );
    }
  }

  function columnEnv( envParent, query ) { // etc.  wildcard._pathHead;
    // if (envParent) console.log( 'CE:', envParent._origin, query );
    return (envParent)
      ? environment( getOrigin( envParent ) ) // not the col with expand, but the referred
      : userQuery( query )._combined;
  }

  function reportReplacement( sibling, navElem, query ) {
    // TODO: bring this much less often = only if shadowed elem does not appear
    // in expr and if not projected as other name.
    // Probably needs to be reported at a later phase
    const path = sibling.value && sibling.value.path;
    if (!sibling.target || sibling.target.$inferred || // not explicit REDIRECTED TO
        path && path[path.length - 1].id !== sibling.name.id) { // or renamed
      const { id } = sibling.name;
      if (Array.isArray(navElem)) {
        // ID published! Used in stakeholder project; if renamed, add to oldMessageIds
        info( 'wildcard-excluding-many', [ sibling.name.location, query ],
              { id, keyword: 'excluding' },
              // eslint-disable-next-line max-len
              'This select item replaces $(ID) from two or more sources. Add $(ID) to $(KEYWORD) to silence this message' );
      }
      else {
        // ID published! Used in stakeholder project; if renamed, add to oldMessageIds
        info( 'wildcard-excluding-one', [ sibling.name.location, query ],
              { id, alias: navElem._parent.name.id, keyword: 'excluding' },
              // eslint-disable-next-line max-len
              'This select item replaces $(ID) from table alias $(ALIAS). Add $(ID) to $(KEYWORD) to silence this message' );
      }
    }
  }

  function setWildcardExpandInline( queryElem, pathHead, origin, name, location ) {
    setLink( queryElem, '_pathHead', pathHead );
    const path = [ { id: name, location } ];
    queryElem.value = { path, location }; // TODO: can we omit that?  We have _origin
    setArtifactLink( path[0], origin );
    setLink( queryElem, '_origin', origin );
    // set _projections when inline with table alias:
    // const alias = pathHead?.value?.path?.[0]?._navigation;
    // if (alias?.kind === '$tableAlias')
    //   pushLink( alias.elements[name], '_projections', queryElem );
  }

  // called by expandWildcard():
  function setElementOrigin( queryElem, navElem, name, location ) {
    const sourceElem = navElem._origin;
    const alias = navElem._parent;
    // always expand * to path with table alias (reason: columns current_date etc)
    const path = [ { id: alias.name.id, location }, { id: name, location } ];
    queryElem.value = { path, location };
    setLink( path[0], '_navigation', alias );
    setArtifactLink( path[0], alias._origin );
    setArtifactLink( path[1], sourceElem );
    // TODO: or should we set the _artifact/_effectiveType directly to the target?
    setArtifactLink( queryElem.value, sourceElem );
    // pushLink( navElem, '_projections', queryElem );
    // TODO: _effectiveType?
  }

  //--------------------------------------------------------------------------
  // Auto-Redirections
  //--------------------------------------------------------------------------

  // Conditions for redirecting target of assoc in elem
  // - we (the elem) are in a service
  // - target provided in assoc is not defined in current service
  // - elem is to be auto-redirected (included elem, elem from main query, ...)
  // - assoc is not defined in current service (or was not to be auto-redirected)
  function redirectImplicitly( elem, assoc ) {
    // PRE: elem has no target, assoc has target prop
    if (elem.kind === '$tableAlias')
      return false;
    const assocTarget = resolvePath( assoc.target, 'target', assoc );
    let target = assocTarget;
    // console.log( info( null, [ elem.location, elem ], {target,art:assoc,name:''+assoc.target},
    //              'RED').toString())
    if (!target)
      return false;             // error in target ref
    const { location } = elem.value || elem.type || elem.name;
    const service = (elem._main || elem)._service;
    if (service && service !== target._service && assocIsToBeRedirected( elem )) {
      if (service !== (assoc._main || assoc)._service ||
          !assocIsToBeRedirected( assoc ) ||
          elem === assoc)
        target = redirectImplicitlyDo( elem, assoc, target, service );
    }
    if (elem === assoc) {    // redirection of user-provided target
      if (assocTarget === target) // no change (due to no implicit redirection)
        return true;
      const type = resolvePath( elem.type, 'type', elem ); // cds.Association or cds.Composition
      const origin = {
        kind: elem.kind, // necessary for rewrite, '$user-provided' would be best
        name: elem.name,
        type: {                 // TODO: necessary?
          path: [ { id: type.name.absolute, location: elem.type.location } ],
          scope: 'global',
          location: elem.type.location,
          $inferred: 'REDIRECTED',
        },
        target: elem.target,
        $inferred: 'REDIRECTED',
        location: elem.target.location,
      };
      setLink( elem, '_origin', origin );
      setArtifactLink( elem.type, type );
      setLink( origin, '_outer', elem );
      setLink( origin, '_parent', elem._parent );
      if (elem._main)           // remark: the param `elem` can also be a type
        setLink( origin, '_main', elem._main );
      setLink( origin, '_effectiveType', origin );
      setLink( origin, '_block', elem._block );
      if (elem.foreignKeys) {
        origin.foreignKeys = elem.foreignKeys;
        delete elem.foreignKeys; // will be rewritten
      }
      if (elem.on) {
        origin.on = elem.on;
        delete elem.on;         // will be rewritten
      }
    }
    if (target !== assocTarget)
      setExpandStatus( elem, 'target' ); // (might) also set in rewriteCondition
    elem.target = {
      path: [ { id: target.name.absolute, location } ],
      scope: 'global',
      location,
      $inferred: (target !== assocTarget ? 'IMPLICIT' : 'rewrite' ),
    };
    setArtifactLink( elem.target, target );
    setArtifactLink( elem.target.path[0], target );
    return true;
  }

  function assocIsToBeRedirected( assoc ) {
    if (assoc.kind === 'mixin')
      return false;
    const query = userQuery( assoc );
    return redirectInSubQueries || !query || query._main._leadingQuery === query;
  }

  function redirectImplicitlyDo( elem, assoc, target, service ) {
    // console.log('ES:',elem.name.absolute,elem.name.element);
    const elemScope = scopedRedirections && // null if no scoped redirections
          preferredElemScope( target, service, elem, assoc._main || assoc );
    const exposed = minimalExposure( target, service, elemScope );

    if (!exposed.length) {
      const origTarget = target;
      if (isAutoExposed( target ))
        target = createAutoExposed( origTarget, service, elemScope );
      const desc = origTarget._descendants ||
            setLink( origTarget, '_descendants', Object.create(null) );
      if (!desc[service.name.absolute]) // could be the target itself (no repeated msgs)!
        desc[service.name.absolute] = [ target ];
      else
        desc[service.name.absolute].push( target );
    }
    else if (exposed.length === 1) {
      return exposed[0];
    }
    else if (elem === assoc) {
      // `assoc: Association to ModelEntity`: user-provided target is to be auto-redirected
      warning( 'type-ambiguous-target',
               [ elem.target.location, elem ],
               {
                 target,
                 // art: definitionScope( target ), - TODO extra debug info in message
                 sorted_arts: exposed,
               }, {
                 // eslint-disable-next-line max-len
                 std: 'Replace target $(TARGET) by one of $(SORTED_ARTS); can\'t auto-redirect this association if multiple projections exist in this service',
                 // eslint-disable-next-line max-len
                 two: 'Replace target $(TARGET) by $(SORTED_ARTS) or $(SECOND); can\'t auto-redirect this association if multiple projections exist in this service',
               });
      // continuation semantics: no auto-redirection
    }
    else {
      // referred (and probably inferred) assoc (without a user-provided target at that place)
      // HINT: consider bin/cdsv2m.js when changing the following message text
      // No grouped and sub messages yet (TODO v3): mention at all target places with all assocs
      const withAnno = annotationVal( exposed[0]['@cds.redirection.target'] );
      for (const proj of exposed) {
        // TODO: def-ambiguous-target (just v3, as the current is infamous and used in options),
        message( 'redirected-implicitly-ambiguous',
                 [ weakLocation( proj.name.location ), proj ],
                 {
                   '#': withAnno && 'justOne',
                   target,
                   art: elem,
                   // art: definitionScope( target ), - TODO extra debug info in message
                   anno: 'cds.redirection.target',
                   sorted_arts: exposed,
                 }, {
                   // eslint-disable-next-line max-len
                   std: 'Add $(ANNO) to one of $(SORTED_ARTS) to select the entity as redirection target for $(TARGET) in this service; can\'t auto-redirect $(ART) otherwise',
                   // eslint-disable-next-line max-len
                   two: 'Add $(ANNO) to either $(SORTED_ARTS) or $(SECOND) to select the entity as redirection target for $(TARGET) in this service; can\'t auto-redirect $(ART) otherwise',
                   // eslint-disable-next-line max-len
                   justOne: 'Remove $(ANNO) from all but one of $(SORTED_ARTS) to have a unique redirection target for $(TARGET) in this service; can\'t auto-redirect $(ART) otherwise',
                 } );
      }
      // continuation semantics: no implicit redirections
    }
    return target;
  }

  // Return projections of `target` in `service`.  Shorted by
  // - first, only consider projections with @cds.redirection.target=true
  // - exclude all indirect projections, i.e. those which are projection on others in list
  //
  // To avoid repeated messages: if already tried to do autoexposure, return
  // auto-exposed entity when successful, or `target` otherwise (no/failed autoexposure)
  function minimalExposure( target, service, elemScope ) {
    const descendants = scopedExposure( target._descendants &&
                                        target._descendants[service.name.absolute] ||
                                        [],
                                        elemScope, target );
    const preferred = descendants.filter( d => annotationVal( d['@cds.redirection.target'] ) );
    const exposed = preferred.length ? preferred : descendants;
    if (exposed.length < 2)
      return exposed || [];
    let min = [];
    for (const e of exposed) {
      if (min.every( m => m._ancestors?.includes( e ))) {
        min = [ e ];
      }
      else if (min.length !== 1 || !e._ancestors?.includes( min[0] )) {
        if (elemScope === '' && options.testMode)
          throw new CompilerAssertion( `Scope for ${ target } in service ${ service } is empty`);
        if (elemScope === '')
          return [];
        min.push( e );
      }
    }
    return min;
  }

  // Scoped redirections -----------------------------------------------------


  function preferredElemScope( target, service, elem, assocMain ) {
    const assocScope = definitionScope( assocMain );
    const targetScope = definitionScope( target );
    if (targetScope === assocScope) { // intra-scope in model
      const elemScope = definitionScope( elem._main || elem );
      // without the if, compile.recompile.json versus expected csn.json in
      // test3/Redirections/AutoExposeDeepScoped would fail
      if (targetScope === target ||  // model target is scope root
          assocScope === assocMain || // unscoped assoc source in model
          elemScope !== (elem._main || elem)) // scoped assoc source in service
        return elemScope;         // own scope, then global
    }
    if (targetScope === target)  // unscoped target in model / other service
      return false;              // all (there could be no scoped autoexposed)
    // scoped target in model:
    const exposed = minimalExposure( targetScope, service, false );
    // console.log('PES:',elem.name.absolute,elem.name.element,exposed.map(e=>e.name.absolute))
    if (exposed.length === 1)   // unique redirection for target scope: use that
      return exposed[0];
    // TODO: warning if exposed.length >= 2?  Probably not
    // TODO: use excessive testing for the following
    // Now re-scope according to naming of auto-exposed entity:
    const autoScopeName = autoExposedName( targetScope, service, false );
    const autoScope = model.definitions[autoScopeName];
    // console.log('AEN:',autoScopeName,autoScope&&(autoScope.$inferred || autoScope.kind))
    if (autoScope)
      return autoScope;
    const { location } = service.name;
    const nullScope = {
      kind: 'namespace', name: { absolute: autoScopeName, location }, location,
    };
    model.definitions[autoScopeName] = nullScope;
    initArtifact( nullScope );
    return nullScope;
  }

  function scopedExposure( descendants, elemScope, target ) {
    if (!elemScope)             // no scoped redirections
      return descendants;
    // try scope as target first, even if it has @cds.redirection.target: false
    if (isDirectProjection( elemScope, target ))
      return [ elemScope ];
    const scoped = descendants.filter( d => elemScope === definitionScope( d ) );
    if (scoped.length)          // use scoped new targets if present
      return scoped;
    // otherwise return new targets outside any scope
    return descendants.filter( d => d === definitionScope( d ) );
  }

  // Return the scope of a definition.  It is the last parent of the definition
  // which is not a context/service/namespace, or the definition itself.
  // If inside service, it is the direct child of the (most inner) service.
  function definitionScope( art ) {
    let base = art;
    while (art._parent) {
      if (art._parent.kind === 'service')
        return art;
      art = art._parent;
      if (!kindProperties[art.kind].artifacts)
        base = art;
    }
    return base;
  }

  function isDirectProjection( proj, base ) {
    return proj.kind === 'entity' && // not event
      // direct proj (TODO: or should we add them to another list?)
      proj.query && proj.query.op && proj.query.op.val === 'SELECT' &&
      proj._from && proj._from.length === 1 &&
      base === resolvePath( proj._from[0], 'from', proj );
  }

  // Auto-exposure -----------------------------------------------------------

  // TODO: do something in kick-start.js ?
  function isAutoExposed( target ) {
    if (target.$autoexpose !== undefined)
      return target.$autoexpose;
    const origTarget = target;
    const chain = [];
    let source = target._from && resolvePath( target._from[0], 'from', target );
    // query source ref might not have been resolved yet, cycle avoided as
    // setAutoExposed() sets $autoexpose and a second call on same art would
    // return false
    while (target.$autoexpose === undefined && setAutoExposed( target ) && source) {
      // stop at first ancestor with annotation or at non-query entity
      chain.push( target );
      target = source;
      source = target._from && resolvePath( target._from[0], 'from', target );
    }
    const autoexpose = target.$autoexpose;
    if (typeof autoexpose === 'boolean') {
      for (const a of chain)
        a.$autoexpose = autoexpose;
    }
    return origTarget.$autoexpose;
  }

  // TODO: less auto-exposed for compositions (see lengthy discussions)
  function setAutoExposed( art ) {
    const anno = art['@cds.autoexpose'];
    if (anno && anno.val !== null) { // XSN TODO: set val, but no location for anno short form
      // @cds.autoexpose:true or @cds.autoexpose:false
      art.$autoexpose = anno.val === undefined || !!anno.val;
      return false;
    }
    // no @cds.autoexpose or @cds.autoexpose:null
    // TODO: introduce deprecated._noInheritedAutoexposeViaComposition
    art.$autoexpose = model.$compositionTargets[art.name.absolute]
      ? autoexposeViaComposition
      : null;
    return true;                // still check for inherited @cds.autoexpose
  }

  function autoExposedName( target, service, elemScope ) {
    const { absolute } = target.name;
    if (isDeprecatedEnabled( options, '_shortAutoexposed' )) {
      const parent = definitionScope( target )._parent;
      const name = (parent) ? absolute.substring( parent.name.absolute.length + 1 ) : absolute;
      // no need for dedot here (as opposed to deprecated._longAutoexposed), as
      // the name for dependent entities have already been created using `_` then
      return `${ service.name.absolute }.${ name }`;
    }
    if (isDeprecatedEnabled( options, '_longAutoexposed' ))
      return `${ service.name.absolute }.${ absolute }`;
    const base = definitionScope( target );
    if (base === target)
      return `${ service.name.absolute }.${ absolute.substring( absolute.lastIndexOf('.') + 1 ) }`;
    // for scoped (e.g. calculated) entities, use exposed name of base:
    const exposed = minimalExposure( base, service, elemScope );
    // console.log(exposed.map( a => a.name.absolute ));
    const sbasename = (exposed.length === 1 && exposed[0] !== base) // same with no/failed expose
      ? exposed[0].name.absolute
      : autoExposedName( base, service, elemScope );
    return sbasename + absolute.slice( base.name.absolute.length );
  }


  function createAutoExposed( target, service, elemScope ) {
    const absolute = autoExposedName( target, service, elemScope );
    const autoexposed = model.definitions[absolute];
    if (autoexposed && (autoexposed.kind !== 'namespace' || !scopedRedirections)) {
      if (isDirectProjection( autoexposed, target )) {
        const anno = autoexposed['@cds.redirection.target'];
        if (annotationIsFalse( anno )) {
          // It would probably be cleaner to ignore a dubious
          // `@cds.redirection.target: false` earlier, but that is not easy to detect
          // due to the name of the auto-exposed entity with scoped redirections
          if (!anno.$errorReported) {
            info( 'anno-redirecting-anyway',
                  [ annotationLocation( anno ), autoexposed ],
                  { target, art: absolute, code: '@cds.redirection.target: false' },
                  '$(TARGET) is auto-redirected to $(ART) even with $(CODE)' );
            anno.$errorReported = 'anno-redirecting-anyway';
          }
        }
        else if (autoexposed._parent === service ||
                 !annotationVal( autoexposed['@cds.autoexposed'] )) {
          // existing def not auto-exposed, or un-scoped auto-exposed: should not happen
          if (options.testMode)
            throw new CompilerAssertion( `Tried to auto-expose ${ target.name.absolute } twice`);
        }
        return autoexposed;
      }
      error( 'duplicate-autoexposed', [ service.name.location, service ],
             { target, art: absolute },
             'Name $(ART) of auto-exposed entity for $(TARGET) collides with other definition' );
      info( null, [ target.name.location, target ],
            { art: service },
            'Expose this (or the competing) entity explicitly in service $(ART)' );
      if (autoexposed.$inferred !== 'autoexposed')
        return target;
      const firstTarget = autoexposed.query.from._artifact;
      error( 'duplicate-autoexposed', [ service.name.location, service ],
             { target: firstTarget, art: absolute },
             'Name $(ART) of auto-exposed entity for $(TARGET) collides with other definition' );
      info( null, [ firstTarget.name.location, firstTarget ],
            { art: service },
            'Expose this (or the competing) entity explicitly in service $(ART)' );
      autoexposed.$inferred = 'duplicate-autoexposed';
      return target;
    }
    // console.log(absolute)
    const { location } = target.name;
    const from = augmentPath( location, target.name.absolute );
    let art = {
      kind: 'entity',
      name: { location, path: splitIntoPath( location, absolute ), absolute },
      location: target.location,
      query: { location, op: { val: 'SELECT', location }, from },
      $syntax: 'projection',
      $inferred: 'autoexposed',
      '@cds.autoexposed': {
        name: { path: [ { id: 'cds.autoexposed', location } ], location },
        $inferred: '$generated',
      },
    };
    // forward target parameters to projection
    if (target.params) {
      art.params = Object.create(null);
      // is art.query.from.path[0].$syntax: ':' required?
      art.query.from.path[0].args = Object.create(null);
      forEachGeneric(target, 'params', (p, pn) => {
        art.params[pn] = linkToOrigin(p, pn, art, 'params', p.location);
        art.query.from.path[0].args[pn] = {
          name: { id: p.name.id, location: p.location },
          location: p.location,
          scope: 'param',
          path: [ { id: pn, location: p.location } ],
        };
      });
    }
    // TODO: do we need to tag the generated entity with elemScope = 'auto'?
    if (autoexposed) {
      Object.assign( autoexposed, art );
      art = autoexposed;
    }
    else {
      model.definitions[absolute] = art;
    }
    setLink( art, '_service', service );
    setLink( art, '_block', model.$internal );
    initArtifact( art, !!autoexposed );
    effectiveType( art );
    // TODO: try to set locations of elements locations of orig target elements
    newAutoExposed.push( art );
    return art;
  }
}

module.exports = populate;
