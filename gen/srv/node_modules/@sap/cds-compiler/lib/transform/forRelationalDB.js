'use strict';

const { setProp, isBetaEnabled } = require('../base/model');
const { cloneCsnNonDict,
        forEachMemberRecursively, forAllQueries, applyTransformationsOnNonDictionary,
        getArtifactDatabaseNameOf, getElementDatabaseNameOf, isBuiltinType, applyTransformations,
        isAspect, walkCsnPath, isPersistedOnDatabase,
      } = require('../model/csnUtils');
const { makeMessageFunction } = require('../base/messages');
const transformUtils = require('./transformUtilsNew');
const { translateAssocsToJoinsCSN } = require('./translateAssocsToJoins');
const { csnRefs, pathId, traverseQuery } = require('../model/csnRefs');
const { checkCSNVersion } = require('../json/csnVersion');
const validate = require('../checks/validator');
const { rejectManagedAssociationsAndStructuresForHdbcdsNames } = require('../checks/selectItems');
const { addLocalizationViewsWithJoins, addLocalizationViews } = require('../transform/localized');
const { timetrace } = require('../utils/timetrace');
const { createReferentialConstraints, assertConstraintIdentifierUniqueness } = require('./db/constraints');
const { createDict, forEach } = require('../utils/objectUtils');
const handleExists = require('./db/transformExists');
const { rewriteCalculatedElementsInViews, processCalculatedElementsInEntities } = require('./db/rewriteCalculatedElements');
const replaceAssociationsInGroupByOrderBy = require('./db/groupByOrderBy');
const _forEachDefinition = require('../model/csnUtils').forEachDefinition;
const flattening = require('./db/flattening');
const expansion = require('./db/expansion');
const assertUnique = require('./db/assertUnique');
const generateDrafts = require('./draft/db');
const enrichUniversalCsn = require('./universalCsn/universalCsnEnricher');
const { getViewTransformer } = require('./db/views');
const cdsPersistence = require('./db/cdsPersistence');
const temporal = require('./db/temporal');
const associations = require('./db/associations')
const { ModelError } = require('../base/error');

// By default: Do not process non-entities/views
function forEachDefinition(csn, cb) {
  _forEachDefinition(csn, cb, {skip: ['annotation', 'action', 'function','event']})
}

/**
 * Return a copy of the compact CSN model with a number of transformations made for rendering
 * in HANA CDS style, used by 'toHana', toSql' and 'toRename'.
 * The behavior is controlled by the following options:
 * options = {
 *    sqlMapping // See the behavior of 'sqlMapping' in toHana, toSql and toRename
 * }
 * The result model will always have 'options.forHana' set, to indicate that these transformations have happened.
 * The following transformations are made:
 * - (000) Some primitive type names are mapped to HANA type names (e.g. DateTime => UTCDateTime,
 *         Date => LocalDate, ...).The primitive type 'UUID' is renamed to 'String' (see also 060 below).
 * - (001) Add a temporal where condition to views where applicable before assoc2join
 * - (010) (not for to.hdbcds with hdbcds names): Transform associations to joins
 * - (015) Draft shadow entities are generated for entities/views annotated with '@odata.draft.enabled'.
 * - (020) Check: in "plain" mode, quoted ids are not allowed.
 *         (a) check in namespace declarations
 *         (b) check in artifact/element definitions.
 * - (040) Abstract entities and entities 'implemented in' something are ignored, as well
 *         as entities annotated with '@cds.persistence.skip' or '@cds.persistence.exists'.
 * - (050) Checks on the hierarchical model (pre-flattening)
 *         array of, @cds.valid.from/to
 * - (045) The query is stripped from entities that are annotated with '@cds.persistence.table',
 *         essentially converting views to entities.
 * - (060) Users of primitive type 'UUID' (which is renamed to 'String' in 000) get length 36'.
 * - (070) Default length 5000 is supplied for strings if not specified.
 * - (080) Annotation definitions are ignored (note that annotation assignments are filtered out by toCdl).
 * - (090) Compositions become associations.
 * - (100) 'masked' is ignored (a), and attribute 'localized' is removed (b)
 * - (110) Actions and functions (bound or unbound) are ignored.
 * - (120) (a) Services become contexts.
 * - (130) (not for to.hdbcds with hdbcds names): Elements having structured types are flattened into
 *         multiple elements (using '_' or '.' as name separator, depending on 'sqlMapping').
 * - (140) (not for to.hdbcds with hdbcds names): Managed associations get explicit ON-conditions, with
 *         generated foreign key elements (also using '_' or '.' as name separator, depending on 'sqlMapping').
 * - (150) (a) Elements from inherited (included) entities are copied into the receiving entity
 *         (b) The 'include' property is removed from entities.
 * - (160) Projections become views, with MIXINs for association elements (adding $projection where
 *         appropriate for ON-conditions).
 * - (170) ON-conditions referring to '$self' are transformed to compare explicit keys instead.
 * - (180) In projections and views, ...
 *         (a) association elements that are mixins must not be explicitly redirected
 *         (b) MIXINs are created for association elements in the select list that are not mixins by themselves.
 * - (190) For all enum types, ...
 *         (a) enum constants in defaults are replaced by their values (assuming a matching enum as element type)
 *         (b) the enum-ness is stripped off (i.e. the enum type is replaced by its final base type).
 * - (200) The 'key' property is removed from all elements of types.
 * - (210) (not for to.hdbcds with hdbcds names): Managed associations in GROUP BY and ORDER BY are
 *         replaced by by their foreign key fields.
 * - (220) Contexts that contain no artifacts or only ignored artifacts are ignored.
 * - (230) (only for to.hdbcds with hdbcds names): The following are rejected in views
 *         (a) Structured elements
 *         (b) Managed association elements
 *         (c) Managed association entries in GROUP BY
 *         (d) Managed association entries in ORDER BY
 * - (240) All artifacts (a), elements, foreign keys, parameters (b) that have a DB representation are annotated
 *         with their database name (as '@cds.persistence.name') according to the naming convention chosen
 *         in 'options.sqlMapping'.
 * - (250) Remove name space definitions again (only in forRelationalDB). Maybe we can omit inserting namespace definitions
 *         completely (TODO)
 *
 * @param {CSN.Model}   inputModel
 * @param {CSN.Options} options
 * @param {string}      moduleName The calling compiler module name, e.g. `to.hdi` or `to.hdbcds`.
 */
function transformForRelationalDBWithCsn(inputModel, options, moduleName) {
  // copy the model as we don't want to change the input model
  timetrace.start('HANA transformation');

  timetrace.start('Clone CSN');
  /** @type {CSN.Model} */
  let csn = cloneCsnNonDict(inputModel, options);
  timetrace.stop('Clone CSN');

  checkCSNVersion(csn, options);

  const pathDelimiter = (options.sqlMapping === 'hdbcds') ? '.' : '_';

  let csnUtils;
  let message, error, warning, info; // message functions
  /** @type {() => void} */
  let throwWithAnyError;
  // csnUtils
  let artifactRef,
    inspectRef,
    effectiveType,
    initDefinition,
    dropDefinitionCache,
    get$combined,
    getCsnDef,
    isAssocOrComposition,
    addStringAnnotationTo;
  // transformUtils
  let addDefaultTypeFacets,
    expandStructsInExpression,
    flattenStructuredElement,
    flattenStructStepsInRef,
    isAssociationOperand,
    isDollarSelfOrProjectionOperand;

  bindCsnReference();

  throwWithAnyError(); // reclassify and throw in case of non-configurable errors

  if (options.csnFlavor === 'universal' && isBetaEnabled(options, 'enableUniversalCsn')) {
    enrichUniversalCsn(csn, options);
    bindCsnReference();
  }

  const dialect = options.sqlDialect;
  const doA2J = !(options.transformation === 'hdbcds' && options.sqlMapping === 'hdbcds');
  if (!doA2J)
    forEachDefinition(csn, handleMixinOnConditions);

  // replace all type refs to builtin types with direct type
  transformUtils.rewriteBuiltinTypeRef(csn);

  timetrace.start('Validate');
  // Run validations on CSN - each validator function has access to the message functions and the inspect ref via this
  const cleanup = validate.forRelationalDB(csn, {
    message, error, warning, info, inspectRef, effectiveType, artifactRef, csnUtils, csn, options, isAspect
  });
  timetrace.stop('Validate');

  // Needs to happen before tuple expansion, so the newly generated WHERE-conditions have it applied
  handleExists(csn, options, error, inspectRef, initDefinition, dropDefinitionCache);

  // Check if structured elements and managed associations are compared in an expression
  // and expand these structured elements. This tuple expansion allows all other
  // subsequent procession steps (especially a2j) to see plain paths in expressions.
  // If errors are detected, throwWithAnyError() will return from further processing

  // If this function is ever undefined, we have a bug in our logic.
  // @ts-ignore
  expandStructsInExpression(csn, { drillRef: true });

  throwWithAnyError();

  const transformCsn = transformUtils.transformModel;

  forEachDefinition(csn, [
    // (001) Add a temporal where condition to views where applicable before assoc2join
    //       assoc2join eventually rewrites the table aliases
    temporal.getViewDecorator(csn, {info}, csnUtils),
    // check unique constraints - further processing is done in rewriteUniqueConstraints
    assertUnique.prepare(csn, options, error, info)
  ]);

  rewriteCalculatedElementsInViews(csn, options, pathDelimiter, error);

  if(doA2J) {
    // Expand a structured thing in: keys, columns, order by, group by
    expansion.expandStructureReferences(csn, options, pathDelimiter, {error, info, throwWithAnyError}, csnUtils);
    bindCsnReference();
  }

  // Remove properties attached by validator - they do not "grow" as the model grows.
  cleanup();

  bindCsnReferenceOnly();


  // TODO: Instead of 3 separate applyTransformations, we could have each of them just return the "listeners", merge them into
  // one big listener that then gets passed into one single applyTransformations. Each listener would then have to return an array of callbacks to call.
  // With that, we could still ensure the processing order (assuming we don't run into problems with scoping).
  // To analyze: Increased memory vs. saved cycles
  // Looked at it with AFC: This is only a small part of the overall processing time, enrich step of validator is just as expensive
  if(doA2J) {
    const resolved = new WeakMap();
    // No refs with struct-steps exist anymore
    flattening.flattenAllStructStepsInRefs(csn, options, resolved, pathDelimiter);
    // No type references exist anymore
    // Needs to happen exactly between flattenAllStructStepsInRefs and flattenElements to keep model resolvable.
    flattening.resolveTypeReferences(csn, options, resolved, pathDelimiter);
    // No structured elements exists anymore
    flattening.flattenElements(csn, options, pathDelimiter, error);
  } else {
    // For to.hdbcds with naming mode hdbcds we also need to resolve the types
    flattening.resolveTypeReferences(csn, options, undefined, pathDelimiter);
  }

  // (010) If requested, translate associations to joins
  if (doA2J)
    handleAssocToJoins();

  bindCsnReference();

  const redoProjections = [];
  // Use the "raw" forEachDefinition here to ensure that the _ignore takes effect
  _forEachDefinition(csn, (artifact) => {
    if(artifact.kind === 'entity' && artifact.projection) {
      artifact.query = { SELECT: artifact.projection };
      delete artifact.projection;
      redoProjections.push(() => {
        if(artifact.query) {
          artifact.projection = artifact.query.SELECT;
          delete artifact.query;
          if(artifact.$syntax === 'projection') {
            delete artifact.$syntax;
          }
        }
      })
    } else if(artifact.kind === 'annotation' || artifact.kind === 'action' || artifact.kind === 'function' || artifact.kind === 'event'){
      // _ignore actions etc. - this loop seemed handy for this, as we can hook into an existing if
      artifact._ignore = true;
    }
  });

  processCalculatedElementsInEntities(csn);

  timetrace.start('Transform CSN')

  // (000) Rename primitive types, make UUID a String
  transformCsn(csn, {
    type: (val, node, key) => {
      renamePrimitiveTypesAndUuid(val, node, key);
      addDefaultTypeFacets(node);
    },
    // HANA/SQLite do not support array-of - turn into CLOB/Text
    items: (val, node) => {
      node.type = 'cds.LargeString';
      delete node.items;
    },
  }, true);

  forEachDefinition(csn, [
    // (040) Ignore entities and views that are abstract or implemented
    // or carry the annotation cds.persistence.skip/exists
    // These entities are not removed from the csn, but flagged as "to be ignored"
    cdsPersistence.getAnnoProcessor(),
    // (050) Check @cds.valid.from/to only on entity
    //       Views are checked in (001), unbalanced valid.from/to's or mismatching origins
    temporal.getAnnotationHandler(csn, options, pathDelimiter, {error})
  ]);

  // eliminate the doA2J in the functions 'handleManagedAssociationFKs' and 'createForeignKeyElements'
  doA2J && flattening.handleManagedAssociationsAndCreateForeignKeys(csn, options, error, warning, pathDelimiter, true, csnUtils, { skipDict: { actions: true }, allowArtifact: artifact => (artifact.kind === 'entity') });

  doA2J && forEachDefinition(csn, flattenIndexes);
  // Managed associations get an on-condition - in views and entities
  doA2J && associations.attachOnConditions(csn, csnUtils, pathDelimiter);

  // (045) Strip all query-ish properties from views and projections annotated with '@cds.persistence.table',
  // and make them entities
  forEachDefinition(csn, cdsPersistence.getPersistenceTableProcessor(csn, options, {error}));

  // Allow using managed associations as steps in on-conditions to access their fks
  // To be done after handleAssociations, since then the foreign keys of the managed assocs
  // are part of the elements
  if (doA2J)
    forEachDefinition(csn, associations.getFKAccessFinalizer(csn, csnUtils, pathDelimiter));

  // Create convenience views for localized entities/views.
  // To be done after getFKAccessFinalizer because associations are
  // handled and before handleDBChecks which removes the localized attribute.
  // Association elements of localized convenience views do not have hidden properties
  // like $managed set, so we cannot do this earlier on.
  if (doA2J)
    addLocalizationViewsWithJoins(csn, options);
  else
    addLocalizationViews(csn, options);

  !doA2J && forEachDefinition(csn, (definition, artName, prop, path) => {
    if (definition.query && isPersistedOnDatabase(definition)) {
      // reject managed association and structure publishing for to-hdbcds.hdbcds
      const that = { csnUtils, options, error };
      rejectManagedAssociationsAndStructuresForHdbcdsNames.call(that, definition, path)
    }
  });

  forEachDefinition(csn, [
    // For generating DB stuff:
    // - table-entity with parameters: not allowed
    // - view with parameters: ok on HANA, not allowed otherwise
    // (don't complain about action/function with parameters)
    handleChecksForWithParameters,
    // Remove .masked
    // Check that keys are not explicitly nullable
    // Check that Associations are not used in entities/views with parameters
    // (150 b) Strip inheritance
    // Note that this should happen after implicit redirection, because includes are required for that
    handleDBChecks,
  ]);

  // (170) Transform '$self' in backlink associations to appropriate key comparisons
  // Must happen before draft processing because the artificial ON-conditions in generated
  // draft shadow entities have crooked '_artifact' links, confusing the backlink processing.
  // But it must also happen after flattenForeignKeys has been called for all artifacts,
  // because otherwise we would produce wrong ON-conditions for the keys involved. Sigh ...
  forEachDefinition(csn, transformSelfInBacklinks);

  /**
   * Referential Constraints are only supported for sql-dialect "hana" and "sqlite".
   * For to.hdbcds with naming mode "hdbcds", no foreign keys are calculated,
   * hence we do not generate the referential constraints for them.
   */
  if(options.sqlDialect !== 'plain' && options.sqlDialect !== 'h2' && doA2J)
    createReferentialConstraints(csn, options);

  // no constraints for drafts
  generateDrafts(csn, options, pathDelimiter, { info, warning, error });

  // Set the final constraint paths and produce hana tc indexes if required
  // See function comment for extensive information.
  assertUnique.rewrite(csn, options, pathDelimiter);

  // Associations that point to things marked with @cds.persistence.skip are removed
  forEachDefinition(csn, cdsPersistence.getAssocToSkippedIgnorer(csn, options, {info}, csnUtils));

  // Apply view-specific transformations
  // (160) Projections now finally become views
  // Replace managed association in group/order by with foreign keys
  const transformEntityOrViewPass2 = getViewTransformer(csn, options, {error, info}, transformCommon);
  forEachDefinition(csn, transformViews);

  // Recursively apply transformCommon and attach @cds.persistence.name
  forEachDefinition(csn, recursivelyApplyCommon);

  const checkConstraintIdentifiers = (artifact, artifactName, prop, path) => {
    assertConstraintIdentifierUniqueness(artifact, artifactName, path, error);
  };

  forEachDefinition(csn, [
    /* assert that there will be no conflicting unique- and foreign key constraint identifiers */
    checkConstraintIdentifiers,
    /* Check Type Parameters (precision, scale, length ...) */
    checkTypeParameters,
    // (200) Strip 'key' property from type elements
    removeKeyPropInType,
  ]);

  // Remove leading $self to keep renderer-diffs smaller
  if(doA2J)
    flattening.removeLeadingSelf(csn);

  throwWithAnyError();

  function killProp(parent, prop){
    delete parent[prop];
  }

  const killers = {
    // Used to ignore actions etc from processing and remove associations/elements
    '_ignore': function (parent, a, b, path){
      if(path.length > 2) {
        const tail = path[path.length-1];
        const parentPath = path.slice(0, -1)
        const parentParent = walkCsnPath(csn, parentPath);
        delete parentParent[tail];
      } else {
        delete parent._ignore;
      }
    },
    // Still used in flattenStructuredElements - in db/flattening.js
    '_flatElementNameWithDots': killProp,
    // Set when setting default string/binary length - used in copyTypeProperties and fixBorkedElementsOfLocalized
    // to not copy the .length property if it was only set via default
    '$default': killProp,
    // Set when we turn UUID into String, checked during generateDraftForHana
    '$renamed': killProp,
    // Set when we remove .key from temporal things, used in localized.js
    '$key': killProp,
    // We need .elements easily for rendering - otherwise we have to compute it then
    // Does not fit in the "killers" theme - TODO: Find a better place
    SET: (parent, prop, SET) => {
      if(!SET.elements) {
        const stack = [parent];
        while(stack.length > 0) {
          const query = stack.pop();

          if(query.SET)
            stack.push(query.SET.args[0]);
          else if(query.SELECT)
            setProp(SET, 'elements', query.SELECT.elements);
        }
      }
    },

  }

  if(options.sqlDialect === 'postgres') {
    killers.length = (parent) => {
      if (parent.type === 'cds.Binary') {
        delete parent.length;
      }
    }
  }

  applyTransformations(csn, killers, [], { skipIgnore: false});

  redoProjections.forEach(fn => fn());

  timetrace.stop('Transform CSN');
  timetrace.stop('HANA transformation');

  return csn;

  /* ----------------------------------- Functions start here -----------------------------------------------*/

  function bindCsnReference(){
    ({ error, warning, info, message, throwWithAnyError } = makeMessageFunction(csn, options, moduleName));

    ({ flattenStructuredElement,
      flattenStructStepsInRef,
      isAssociationOperand,
      isDollarSelfOrProjectionOperand,
      addDefaultTypeFacets,
      expandStructsInExpression,
      csnUtils
    } = transformUtils.getTransformers(csn, options, pathDelimiter));

    ({ artifactRef,
      inspectRef,
      effectiveType,
      initDefinition,
      dropDefinitionCache,
      get$combined,
      getCsnDef,
      isAssocOrComposition,
      addStringAnnotationTo,
    } = csnUtils);
  }

  function bindCsnReferenceOnly(){
    // invalidate caches for CSN ref API
    ({ artifactRef, inspectRef, effectiveType, initDefinition, dropDefinitionCache } = csnRefs(csn));
  }

  function handleMixinOnConditions(artifact, artifactName) {
    if (!artifact.query)
      return;
    forAllQueries(artifact.query, (query, path) => {
      const { mixin } = query.SELECT  || {};
      if(mixin) {
        query.SELECT.columns
        // filter for associations which are used in the SELECT
        .filter((c) => {
          return c.ref &&  c.ref.length > 1;
        })
        .forEach((usedAssoc) => {
          const assocName = pathId(usedAssoc.ref[0]);
          const mixinAssociation = mixin[assocName];
          if(mixinAssociation){
            mixinAssociation.on = getResolvedMixinOnCondition(csn, mixinAssociation, query, assocName, path.concat(['mixin', assocName]));
          }
        })
      }
    }, [ 'definitions', artifactName, 'query' ]);

    function getResolvedMixinOnCondition(csn, mixinAssociation, query, assocName, path){
      const { inspectRef } = csnRefs(csn);
      const referencedThroughStar = query.SELECT.columns.some((column) => column === '*');
      return mixinAssociation.on
            .map((onConditionPart, i) => {
              let columnToReplace;
              if(onConditionPart.ref && (onConditionPart.ref[0] === '$projection' || onConditionPart.ref[0] === '$self')){
                const { links } = inspectRef(path.concat(['on', i]));
                if(links){
                  columnToReplace = onConditionPart.ref[links.length - 1];
                }
              }
              if (!columnToReplace)
                return onConditionPart;

              const replaceWith = query.SELECT.columns.find((column) =>
                column.as && column.as === columnToReplace ||
                column.ref && column.ref[0] === columnToReplace
              );
              if (!replaceWith && referencedThroughStar) {
                // not explicitly in column list, check query sources
                // get$combined also includes elements which are part of "excluding {}"
                // this shouldn't be an issue here, as such references get rejected
                const elementsOfQuerySources = get$combined(query);
                forEach(elementsOfQuerySources, (id, element) => {
                  // if the ref points to an element which is not explicitly exposed in the column list,
                  // but through the '*' operator -> replace the $projection / $self with the correct source entity
                  if(id === columnToReplace)
                    onConditionPart.ref[0] = element[0].parent;
                });
              }

              // No implicit CAST in on-condition
              if(replaceWith && replaceWith.cast) {
                const clone = cloneCsnNonDict(replaceWith, options);
                delete clone.cast;
                return clone;
              }
              return replaceWith || onConditionPart;
            });
    }
  }

  /**
   * @param {CSN.Artifact} artifact
   * @param {string} artifactName
   */
  function transformViews(artifact, artifactName) {
    if (!artifact._ignore) {
      // Do things specific for entities and views (pass 2)
      if ((artifact.kind === 'entity') && artifact.query) {

        // First pass: Set alias name for SELECTs without table alias. Required for setting proper table aliases
        // for HDBCDS in naming mode HDBCDS.  We use the same schema as the core-compiler, so duplicates should
        // have already been reported.
        let selectDepth = 0;
        traverseQuery(artifact.query, null, null, (query, fromSelect) => {
          if (!query.ref && !query.as && fromSelect) {
            // Use +1; for UNION, it's the next select, for SELECT, it's increased later.
            query.as = `$_select_${selectDepth + 1}__`;
          }
          if (query.SELECT)
            ++selectDepth;
        });

        const process = (parent, prop, query, path) => {
          transformEntityOrViewPass2(parent, artifact, artifactName, path.concat(prop))
          replaceAssociationsInGroupByOrderBy(parent, options, inspectRef, error, path.concat(prop));
          return query;
        }
        applyTransformationsOnNonDictionary(csn.definitions, artifactName, {
          SELECT: process
        }, {}, [ 'definitions']);
      }
    }
  }

  /**
   * @param {CSN.Artifact} artifact
   * @param {string} artifactName
   */
  function recursivelyApplyCommon(artifact, artifactName) {
    if (!artifact._ignore) {
      if (artifact.kind !== 'service' && artifact.kind !== 'context')
        addStringAnnotationTo('@cds.persistence.name', getArtifactDatabaseNameOf(artifactName, options.sqlMapping, csn, options.sqlDialect), artifact);

      forEachMemberRecursively(artifact, (member, memberName, property, path) => {
        if (memberName === '' && property === 'params')
          return; // ignore "returns" type
        transformCommon(member, memberName, path);
        // (240 b) Annotate elements, foreign keys, parameters etc with their DB names
        // Virtual elements in entities and types are not annotated, as they have no DB representation.
        // In views they are, as we generate a null expression for them (null as <colname>)
        if ((!member.virtual || artifact.query))
          addStringAnnotationTo('@cds.persistence.name', getElementDatabaseNameOf(memberName, options.sqlMapping, options.sqlDialect), member);
      }, [ 'definitions', artifactName ]);
    }
  }

  /**
   * @param {CSN.Artifact} artifact
   * @param {string} artifactName
   */
  function removeKeyPropInType(artifact, artifactName) {
    if (!artifact._ignore && artifact.kind === 'type') {
      forEachMemberRecursively(artifact, (member) => {
        if (member.key)
          delete member.key;
      }, [ 'definitions', artifactName ]);
    }
  }


  /**
   * @param {CSN.Artifact} artifact
   * @param {string} artifactName
   */
  function transformSelfInBacklinks(artifact, artifactName, dummy, path) {
    // Fixme: For toHana mixins must be transformed, for toSql -d hana
    // mixin elements must be transformed, why can't toSql also use mixins?
    if(artifact.kind === 'entity' || artifact.query || (options.forHana && options.sqlMapping === 'hdbcds' && artifact.kind === 'type'))
      doit(artifact.elements, path.concat([ 'elements' ]));
    if (artifact.query && artifact.query.SELECT && artifact.query.SELECT.mixin)
      doit(artifact.query.SELECT.mixin, path.concat([ 'query', 'SELECT', 'mixin' ]));

    function doit(dict, subPath) {
      for (const elemName in dict) {
        const elem = dict[elemName];
        if (elem.on && isAssocOrComposition(elem))
          processBacklinkAssoc(elem, elemName, artifact, artifactName, subPath.concat([ elemName, 'on' ]));
      }
    }
  }

  /**
   * @param {CSN.Artifact} artifact
   * @param {string} artifactName
   */
  function handleDBChecks(artifact, artifactName) {
    // Strip inheritance
    if (artifact.includes)
      delete artifact.includes;

    // Process the artifact's  members
    forEachMemberRecursively(artifact, (member, memberName, prop, path) => {
      // (100 a) Ignore the property 'masked' itself (but not its effect on projections)
      if (member.masked)
        delete member.masked;
      // For HANA: Report an error on
      // - view with parameters that has an element of type association/composition
      // - association that points to entity with parameters
      if (options.sqlDialect === 'hana' && member.target && isAssocOrComposition(member) && !isBetaEnabled(options, 'assocsWithParams')) {
        if (artifact.params) {
          // HANA does not allow 'WITH ASSOCIATIONS' on something with parameters:
          // SAP DBTech JDBC: [7]: feature not supported: parameterized sql view cannot support association: line 1 col 1 (at pos 0)
          message('def-unexpected-paramview-assoc', path, { '#': 'source' });
        }
        else if(artifact['@cds.persistence.udf'] || artifact['@cds.persistence.calcview']) {
          // UDF/CVs w/o params don't support 'WITH ASSOCIATIONS'
          const anno = artifact['@cds.persistence.udf'] ? '@cds.persistence.udf' : '@cds.persistence.calcview';
          message('def-unexpected-calcview-assoc', path, { '#': 'source', anno });
        }
        if (csn.definitions[member.target].params) {
          // HANA does not allow association targets with parameters or to UDFs/CVs w/o parameters:
          // SAP DBTech JDBC: [7]: feature not supported: cannot support create association to a parameterized view
          message('def-unexpected-paramview-assoc', path, { '#': 'target' });
        }
        else if(csn.definitions[member.target]['@cds.persistence.udf'] || csn.definitions[member.target]['@cds.persistence.calcview']) {
          // HANA won't check the assoc target but when querying an association with target UDF, this is the error:
          // SAP DBTech JDBC: [259]: invalid table name: target object SYSTEM.UDF does not exist: line 3 col 6 (at pos 43)
          // CREATE TABLE F (id INTEGER NOT NULL);
          // CREATE FUNCTION UDF RETURNS TABLE (ID INTEGER) LANGUAGE SQLSCRIPT SQL SECURITY DEFINER AS BEGIN RETURN SELECT ID FROM F; END;
          // CREATE TABLE Y (  id INTEGER NOT NULL,  toUDF_id INTEGER) WITH ASSOCIATIONS (MANY TO ONE JOIN UDF AS toUDF ON (toUDF.id = toUDF_id));
          // CREATE VIEW U AS SELECT  id, toUDF.a FROM Y;
          const anno = csn.definitions[member.target]['@cds.persistence.udf'] ? '@cds.persistence.udf' : '@cds.persistence.calcview';
          message('def-unexpected-calcview-assoc', path, { '#': 'target', anno });
        }
      }
    }, [ 'definitions', artifactName ]);
  }

  /**
   * @param {CSN.Artifact} artifact
   * @param {string} artifactName
   */
  function handleChecksForWithParameters(artifact, artifactName) {
    if (!artifact._ignore && artifact.params && (artifact.kind === 'entity')) {
      if (!artifact.query) { // table entity with params
        // Allow with plain
        error(null, [ 'definitions', artifactName ], { '#': options.toSql ? 'sql' : 'std' }, {
          std: 'Table-like entities with parameters are not supported for conversion to SAP HANA CDS',
          sql: 'Table-like entities with parameters are not supported for conversion to SQL',
        });
      }
      else if (options.sqlDialect === 'sqlite') { // view with params
        // Allow with plain
        error(null, [ 'definitions', artifactName ], 'SQLite does not support entities with parameters');
      }
      else {
        for (const pname in artifact.params) {
          if (pname.match(/\W/g) || pname.match(/^\d/) || pname.match(/^_/)) { // parameter name must be regular SQL identifier
            warning(null, [ 'definitions', artifactName, 'params', pname ], 'Expecting regular SQL-Identifier');
          }
          else if (options.sqlMapping !== 'plain' && pname.toUpperCase() !== pname) { // not plain mode: param name must be all upper
            warning(null, [ 'definitions', artifactName, 'params', pname ], { name: options.sqlMapping },
                   'Expecting parameter to be uppercase in naming mode $(NAME)');
          }
        }
      }
    }
  }

  function handleAssocToJoins() {
    // With flattening errors, it makes little sense to continue.
    throwWithAnyError();
    // the augmentor isn't able to deal with technical configurations and since assoc2join can ignore it we
    // simply make it invisible and copy it over to the result csn
    forEachDefinition(csn, art => art.technicalConfig && setProp(art, 'technicalConfig', art.technicalConfig));

    const newCsn = translateAssocsToJoinsCSN(csn, options);

    // restore all (non-enumerable) properties that wouldn't survive reaugmentation/compactification into the new compact model
    forEachDefinition(csn, (art, artName) => {
      if(art['$tableConstraints']) {
        setProp(newCsn.definitions[artName], '$tableConstraints', art['$tableConstraints']);
      }
      if (art.technicalConfig)
        newCsn.definitions[artName].technicalConfig = art.technicalConfig;

    });
    csn = newCsn;
  }



  /**
   * Remove `localized` from elements and replace Enum symbols by their values.
   *
   * Only applies to elements.
   *
   * @param {CSN.Element} obj
   * @param {String} objName
   * @param {CSN.Path} path
   */
  function transformCommon(obj, objName, path) {
    // (100 b) Remove attribute 'localized'
    if (obj.localized)
      delete obj.localized;

    // (190 a) Replace enum symbols by their value (if found)
    replaceEnumSymbolsByValues(obj, path);

    if (obj.enum)
      delete obj.enum;
  }

  // Change the names of those builtin types that have different names in HANA.
  // (do that directly in the csn where the builtin types are defined, so that
  // all users of the types benefit from it). Also add the type parameter 'length'
  // to 'UUID' (which becomes a string).
  // TODO: there is no benefit at all - it is fundamentally wrong
  function renamePrimitiveTypesAndUuid(val, node, key) {
    // assert key === 'type'
    const hanaNamesMap = createDict({
      'cds.DateTime': 'cds.UTCDateTime',
      'cds.Timestamp': 'cds.UTCTimestamp',
      'cds.Date': 'cds.LocalDate',
      'cds.Time': 'cds.LocalTime',
      'cds.UUID': 'cds.String',
    });
    node[key] = hanaNamesMap[val] || val;
    if (val === 'cds.UUID' && !node.length) {
      node.length = 36;
      setProp(node, '$renamed', 'cds.UUID');
    }

    if(options.sqlDialect === 'h2' && val === 'cds.Decimal' && node.scale === undefined) {
      node[key] = 'cds.DecimalFloat'; // cds.Decimal and cds.Decimal(p) should map do DECFLOAT for h2
    }

    // Length/Precision/Scale is done in addDefaultTypeFacets
  }

  // If 'obj' has final type 'cds.UUID' (renamed to String in 000), set its length to 36.
  // function setLengthForFormerUuid(obj) {
  //   if (!obj || !obj.type)
  //     return;
  //   if (obj.type === 'cds.UUID' && !obj.length) {
  //     obj.length = 36;
  //   }
  // }


  // If 'elem' has a default that is an enum constant, replace that by its value. Complain
  // if not found or not an enum type,
  function replaceEnumSymbolsByValues(elem, path) {
    // (190 a) Replace enum symbols by their value (if found)
    if (elem.default && elem.default['#']) {
      let Enum = elem.enum;
      if (!Enum && !isBuiltinType(elem.type)) {
        const typeDef = getCsnDef(elem.type);
        Enum = typeDef && typeDef.enum;
      }
      if (!Enum) {
        // Not an enum at all
        // Looks like it is always run?! But message says HANA CDS?!
        error(null, path, {
          $reviewed: true,
          name: `#${ elem.default['#'] }`
        },
        'Expecting enum literal $(NAME) to be used with an enum type');
      }
      else {
        // Try to get the corresponding enum symbol from the element's type
        const enumSymbol = Enum[elem.default['#']];
        if (!enumSymbol) {
          error(null, path, {
            $reviewed: true,
            name: `#${ elem.default['#'] }`
          }, 'Enum literal $(NAME) is undefined in enumeration type');
        }
        else if (enumSymbol.val !== undefined) { // `val` may be `null`
          // Replace default with enum value
          elem.default.val = enumSymbol.val;
          delete elem.default['#'];
        }
        else {
          // Enum symbol without explicit value - replace default by the symbol in string form
          elem.default.val = elem.default['#'];
          delete elem.default['#'];
        }
      }
    }
  }


  // If the association element 'elem' of 'art' is a backlink association, massage its ON-condition
  // (in place) so that it
  // - compares the generated foreign key fields of the corresponding forward
  //   association with their respective keys in 'art' (for managed forward associations)
  // - contains the corresponding forward association's ON-condition in "reversed" form,
  //   i.e. as seen from 'elem' (for unmanaged associations)
  // Otherwise, do nothing.
  function processBacklinkAssoc(elem, elemName, art, artName, pathToOn) {
    // Don't add braces if it is a single expression (ignoring superfluous braces)
    const multipleExprs = elem.on.filter(x => x !== '(' && x !== ')' ).length > 3;
    /**
     * Process the args
     *
     * @param {Array} xprArgs
     * @param {CSN.Path} path
     * @returns {Array} Array of parsed expression
     */
    function processExpressionArgs(xprArgs, path) {
      const result = [];
      let i = 0;
      while (i < xprArgs.length) {
        // Only token tripel `<path>, '=', <path>` are of interest here
        if (i < xprArgs.length - 2 && xprArgs[i + 1] === '=') {
          // Check if one side is $self and the other an association
          // (if so, replace all three tokens with the condition generated from the other side, in parentheses)
          if (isDollarSelfOrProjectionOperand(xprArgs[i]) && isAssociationOperand(xprArgs[i + 2], path.concat([ i + 2 ]))) {
            const assoc = inspectRef(path.concat([ i + 2 ])).art;
            if (multipleExprs)
              result.push('(');
            const backlinkName = xprArgs[i + 2].ref[xprArgs[i + 2].ref.length - 1];
            result.push(...transformDollarSelfComparison(xprArgs[i + 2],
              assoc,
              backlinkName,
              elem, elemName, art, artName, path.concat([ i ])
            ));
            if (multipleExprs)
              result.push(')');
            i += 3;
            attachBacklinkInformation(backlinkName);
          }
          else if (isDollarSelfOrProjectionOperand(xprArgs[i + 2]) && isAssociationOperand(xprArgs[i], path.concat([ i ]))) {
            const assoc = inspectRef(path.concat([ i ])).art;
            if (multipleExprs)
              result.push('(');
            const backlinkName = xprArgs[i].ref[xprArgs[i].ref.length - 1];
            result.push(...transformDollarSelfComparison(xprArgs[i], assoc, backlinkName, elem, elemName, art, artName, path.concat([ i + 2 ])));
            if (multipleExprs)
              result.push(')');
            i += 3;
            attachBacklinkInformation(backlinkName);
          }
          // Otherwise take one (!) token unchanged
          else {
            result.push(xprArgs[i]);
            i++;
          }
        }
        // Process subexpressions - but keep them as subexpressions
        else if(xprArgs[i].xpr){
          result.push({xpr: processExpressionArgs(xprArgs[i].xpr, path.concat([i, 'xpr']))});
          i++;
        }
        // Take all other tokens unchanged
        else {
          result.push(xprArgs[i]);
          i++;
        }
      }
      return result;

      /**
       * The knowledge whether an association was an `<up_>` association in a
       * `$self = <comp>.<up_>` comparison, is important for the foreign key constraints.
       * By the time we generate them, such on-conditions are already transformed
       * --> no more `$self` in the on-conditions, that is why we need to remember it here.
       *
       * @param {string} backlinkName name of `<up_>` in a `$self = <comp>.<up_>` comparison
       */
      function attachBacklinkInformation(backlinkName) {
        if (elem.$selfOnCondition)
          elem.$selfOnCondition.up_.push(backlinkName);
        else {
          setProp(elem, '$selfOnCondition', {
            up_: [backlinkName]
          });
        }
      }
    }

    elem.on = processExpressionArgs(elem.on, pathToOn);

    // Return the condition to replace the comparison `<assocOp> = $self` in the ON-condition
    // of element <elem> of artifact 'art'. If there is anything to complain, use location <loc>
    function transformDollarSelfComparison(assocOp, assoc, assocName, elem, elemName, art, artifactName, path) {
      // Check: The forward link <assocOp> must point back to this artifact
      // FIXME: Unfortunately, we can currently only check this for non-views (because when a view selects
      // a backlink association element from an entity, the forward link will point to the entity,
      // not to the view).
      // FIXME: This also means that corresponding key fields should be in the select list etc ...
      if (!art.query && !art.projection && assoc.target && assoc.target !== artifactName)
        error( null, path, { id: '$self', name: artifactName, target: assoc.target },
               'Expected association using $(ID) to point back to $(NAME) but found $(TARGET)' );

      // Check: The forward link <assocOp> must not contain '$self' in its own ON-condition
      if (assoc.on) {
        const containsDollarSelf = assoc.on.some(isDollarSelfOrProjectionOperand);

        if (containsDollarSelf)
          error(null, path, { name: '$self' },
            'An association that uses $(NAME) in its ON-condition can\'t be compared to $(NAME)');
      }

      // Transform comparison of $self to managed association into AND-combined foreign key comparisons
      if (assoc.keys) {
        if(assoc.keys.length)
          return transformDollarSelfComparisonWithManagedAssoc(assocOp, assoc, assocName, elemName);
        else {
          elem._ignore = true;
          return [];
        }
      }

      // Transform comparison of $self to unmanaged association into "reversed" ON-condition
      else if (assoc.on)
        return transformDollarSelfComparisonWithUnmanagedAssoc(assocOp, assoc, assocName, elemName);

      throw new ModelError(`Expected either managed or unmanaged association in $self-comparison: ${ JSON.stringify(elem.on) }`);
    }

    // For a condition `<elemName>.<assoc> = $self` in the ON-condition of element <elemName>,
    // where <assoc> is a managed association, return a condition comparing the generated
    // foreign key elements <elemName>.<assoc>_<fkey1..n> of <assoc> to the corresponding
    // keys in this artifact.
    // For example, `ON elem.ass = $self` becomes `ON elem.ass_key1 = key1 AND elem.ass_key2 = key2`
    // (assuming that `ass` has the foreign keys `key1` and `key2`)
    function transformDollarSelfComparisonWithManagedAssoc(assocOp, assoc, originalAssocName, elemName) {
      const conditions = [];
      // if the element was structured then it was flattened => change of the delimiter from '.' to '_'
      // this is done in the flattening, but as we do not alter the onCond itself there should be done here as well
      const assocName = originalAssocName.replace(/\./g, pathDelimiter);
      elemName = elemName.replace(/\./g, pathDelimiter);

      assoc.keys.forEach((k) => {
        // Depending on naming conventions, the foreign key may two path steps (hdbcds) or be a single path step with a flattened name (plain, quoted)
        // With to.hdbcds in conjunction with hdbcds naming, we need to NOT use the alias - else we get deployment errors
        const keyName = k.as && doA2J ? [k.as] : k.ref;
        const fKeyPath = !doA2J ? [ assocName, ...keyName ] : [ `${ assocName }${ pathDelimiter }${ keyName[0] }` ];
        // FIXME: _artifact to the args ???
        const a = [
          {
            ref: [ elemName, ...fKeyPath ],
          },
          { ref: k.ref },
        ];

        conditions.push([ a[0], '=', a[1] ]);
      });

      return conditions.reduce((prev, current) => {
        if (prev.length === 0)
          return [ ...current ];

        return [ ...prev, 'and', ...current ];
      }, []);
    }

    // For a condition `<elemName>.<assoc> = $self` in the ON-condition of element <elemName>,
    // where <assoc> is an unmanaged association, return the ON-condition of <assoc> as it would
    // be written from the perspective of the artifact containing association <elemName>.
    // For example, `ON elem.ass = $self` becomes `ON a = elem.x AND b = elem.y`
    // (assuming that `ass` has the ON-condition `ON ass.a = x AND ass.b = y`)
    function transformDollarSelfComparisonWithUnmanagedAssoc(assocOp, assoc, originalAssocName, elemName) {
      // if the element was structured then it may have been flattened => change of the delimiter from '.' to '_'
      // this is done in the flattening, but as we do not alter the onCond itself there should be done here as well
      elemName = elemName.replace(/\./g, pathDelimiter);
      const assocName = originalAssocName.replace(/\./g, pathDelimiter);
      // clone the onCond for later use in the path transformation
      const newOnCond = cloneCsnNonDict(assoc.on, options);
      applyTransformationsOnNonDictionary({on: newOnCond}, 'on', {
        ref: (parent, prop, ref) => {
          if (ref[0] === assocName) // we are in the "path" from the forwarding assoc => need to remove the first part of the path
          {
            ref.shift();
          } else if(ref && ref.length > 1 && ref[0] === '$self' && ref[1] === assocName) {
            // We could also have a $self in front of the assoc name - so we would need to shift twice
            ref.shift();
            ref.shift();
          }
          else { // we are in the backlink assoc "path" => need to push at the beginning the association's id
            ref.unshift(elemName);
            // if there was a $self identifier in the forwarding association onCond
            // we do not need it anymore, as we prepended in the previous step the back association's id
            if (ref[1] === '$self')
              ref.splice(1, 1);
          }
        }
      });
      return newOnCond;
    }
  }

  /**
   * @param {CSN.Artifact} artifact
   * @param {string} artifactName
   */
  function checkTypeParameters(artifact, artifactName) {
    forEachMemberRecursively(artifact, (member, memberName, prop, path) => {
      // Check type parameters (length, precision, scale ...)
      if (!member._ignore && member.type)
        _check(member, memberName, csn, path);

      if (!member._ignore && member.items && member.items.type)
        _check(member.items, memberName, csn, path.concat([ 'items' ]));
    }, [ 'definitions', artifactName ]);

    // Check that required actual parameters on 'node.type' are set, that their values are in the correct range etc.
    function _check(node, nodeName, model, path) {
      if (node.type) {
        const absolute = node.type;
        switch (absolute) {
          case 'cds.String':
          case 'cds.Binary':
          case 'cds.hana.VARCHAR': {
            checkTypeParamValue(node, 'length', { min: 1, max: 5000 }, path);
            break;
          }
          case 'cds.Decimal': {
            // Don't check with "plain"?
            if (node.precision || node.scale) {
              checkTypeParamValue(node, 'precision', { max: 38 }, path);
              checkTypeParamValue(node, 'scale', { max: node.precision }, path);
            }
            break;
          }

          case 'cds.hana.BINARY':
          case 'cds.hana.NCHAR':
          case 'cds.hana.CHAR': {
            checkTypeParamValue(node, 'length', { min: 1, max: 2000 }, path);
            break;
          }
          case 'cds.hana.ST_POINT':
          case 'cds.hana.ST_GEOMETRY': {
            checkTypeParamValue(node, 'srid', { max: Number.MAX_SAFE_INTEGER }, path);
            break;
          }
        }
      }

      // Check that the value of the type property `paramName` (e.g. length, precision, scale ...) is of `expectedType`
      // (which can currently only be 'positiveInteger') and (optional) the value is in a given range
      function checkTypeParamValue(node, paramName, range = null, path = null) {
        const paramValue = node[paramName];
        if (paramValue === undefined || paramValue === null) {
          if(options.toSql || artifact.query || !['cds.Binary','cds.hana.BINARY', 'cds.hana.NCHAR','cds.hana.CHAR'].includes(node.type)) {
            return true;
          } else {
            return error('type-missing-argument', path, { name: paramName, id: node.type, $reviewed: false });
          }
        }
        if (range) {
          if (isMaxParameterLengthRestricted(node.type) && range.max && paramValue > range.max) {
            error('type-unexpected-argument', path,
              { '#': 'max', prop: paramName, type: node.type, number: range.max, $reviewed: false });
            return false;
          }
          if (range.min && paramValue < range.min) {
            error('type-unexpected-argument', path,
              { '#': 'min', prop: paramName, type: node.type, number: range.min, $reviewed: false });
            return false;
          }
        }
        return true;
      }
    }
  }

  /**
  * Check if the maximum length of the value of the given type is restricted.
  *
  * @param {string} type
  * @returns {boolean}
  */
  function isMaxParameterLengthRestricted(type) {
    return !(options.toSql && type === 'cds.String' && (options.sqlDialect === 'sqlite' || options.sqlDialect === 'plain'));
  }

  /**
   * Flatten technical configuration stuff
   *
   * @param {CSN.Artifact} art
   * @param {string} artName Artifact Name
   */
  function flattenIndexes(art, artName) {
    // Flatten structs in indexes (unless explicitly asked to keep structs)
    const tc = art.technicalConfig;
    if (art.kind === 'entity') {
      if (tc && tc[dialect]) {
        // Secondary and fulltext indexes
        for (const name in tc[dialect].indexes) {
          const index = tc[dialect].indexes[name];
          if (Array.isArray(index)) {
            const flattenedIndex = [];
            const isFulltextIndex = (index[0] === 'fulltext');
            index.forEach((val, idx) => {
              if (typeof val === 'object' && val.ref) {
                // Replace a reference by references to it's elements, if it is structured
                const path = [ 'definitions', artName, 'technicalConfig', dialect, 'indexes', name, idx ];
                const { art } = inspectRef(path);
                if (!art) {
                  // A reference that has no artifact (e.g. the reference to the index name itself). Just copy it over
                  flattenedIndex.push(val);
                }
                else if (art.elements) {
                  // The reference is structured
                  if (isFulltextIndex)
                    error(null, path, { name: artName }, 'A fulltext index can\'t be defined on a structured element $(NAME)');
                  // First, compute the name from the path, e.g ['s', 's1', 's2' ] will result in 'S_s1_s2' ...
                  const refPath = flattenStructStepsInRef(val.ref, path);
                  // ... and take this as the prefix for all elements
                  const flattenedElems = flattenStructuredElement(art, refPath, [], ['definitions', artName, 'elements']);
                  Object.keys(flattenedElems).forEach((elem, i, elems) => {
                    // if it's not the first entry, add a ',' ...
                    if (i)
                      flattenedIndex.push(',');
                    // ... then add the flattend element name as a single ref
                    flattenedIndex.push({ ref: [ elem ] });
                    // ... then check if we have to propagate a 'asc'/'desc', omitting the last, which will be copied automatically
                    if ((idx + 1) < index.length && (index[idx + 1] === 'asc' || index[idx + 1] === 'desc') && i < elems.length - 1)
                      flattenedIndex.push(index[idx + 1]);
                  });
                }
                else {
                  // The reference is not structured, so just replace it by a ref to the combined prefix path
                  const refPath = flattenStructStepsInRef(val.ref, path);
                  flattenedIndex.push({ ref: refPath });
                }
              }
              else // it's just some token like 'index', '(' etc. so we copy it over
              {
                flattenedIndex.push(val);
              }
            });
            // Replace index by the flattened one
            tc[dialect].indexes[name] = flattenedIndex;
          }
        }
      }
    }
  }
}


module.exports = {
  transformForRelationalDBWithCsn,
};
