'use strict';

const { makeMessageFunction } = require('../base/messages');
const { isDeprecatedEnabled, isBetaEnabled } = require('../base/model');
const transformUtils = require('./transformUtilsNew');
const { cloneCsnNonDict,
        forEachDefinition,
        forEachMemberRecursively,
        applyTransformationsOnNonDictionary,
        getArtifactDatabaseNameOf,
        getElementDatabaseNameOf,
        isAspect,
        getServiceNames,
        forEachGeneric,
      } = require('../model/csnUtils');
const { checkCSNVersion } = require('../json/csnVersion');
const validate = require('../checks/validator');
const { isArtifactInSomeService, isLocalizedArtifactInService } = require('./odata/utils');
const expandToFinalBaseType = require('./odata/toFinalBaseType');
const { timetrace } = require('../utils/timetrace');
const enrichUniversalCsn = require('./universalCsn/universalCsnEnricher');
const flattening = require('./db/flattening');
const associations = require('./db/associations')
const expansion = require('./db/expansion');
const generateDrafts = require('./draft/odata');

const { addLocalizationViews } = require('./localized');

// Transformation for ODATA. Expects a CSN 'inputModel', processes it for ODATA.
// The result should be suitable for consumption by EDMX processors (annotations and metadata)
// and also as a final CSN output for the ODATA runtime.
// Performs the following:
//   - Validate the input model. (forODataNew Candidate)
//   - Unravel derived types for elements, actions, action parameters, types and
//     annotations (propagating annotations).
//     (EdmPreproc Candidate, don't know if flatten step depends on it)
//   - If we execute in flat mode, flatten:
//        -- structured elements
//        -- all the references in the model
//        -- foreign keys of managed associations (cover also the case when the foreign key is
//           pointing to keys that are themselves managed associations)
//       (long term EdmPreproc Candidate when RTs are able to map to flat)
//   - Generate foreign keys for all the managed associations in the model as siblings to the association
//     where ever the association is located (toplevel in flat or deep structured). (forODataNew Candidate)
//   - Tackle on-conditions in unmanaged associations. In case of flat mode - flatten the
//     on-condition, in structured mode - normalize it. (forODataNew Candidate)
//   - Generate artificial draft fields if requested. (forODataNew Candidate)
//   - Check associations for:
//     TODO: move to validator (Is this really required here?
//                              EdmPreproc cuts off assocs or adds proxies/xrefs)
//        -- exposed associations do not point to non-exposed targets
//        -- structured types must not contain associations for OData V2
//   - Element must not be an 'array of' for OData V2 TODO: move to the validator
//     (Linter Candiate, move as hard error into EdmPreproc on V2 generation)
//   - Perform checks for exposed non-abstract entities and views - check media type and
//        key-ness (requires that containers have been identified) (Linter candidate, scenario check)
//   Annotations related:
//   - Annotate artifacts, elements, foreign keys, parameters etc with their DB names if requested
//     (must remain in CSN => ForODataNewCandidate)
//   - Mark fields with @odata.on.insert/update as @Core.Computed
//     (EdmPreproc candidate, check with RT if @Core.Computed required by them)
//   - Rename shorthand annotations according to a builtin list (EdmPreproc Candidate)
//       e.g. @label -> @Common.Label
//   - If the association target is annotated with @cds.odata.valuelist, annotate the
//        association with @Common.ValueList.viaAssociation (EdmPreproc Candidate)
//   - Check for @Analytics.Measure and @Aggregation.default (Linter check candidate, remove)
//   - Check annotations. If annotation starts with '@sap...' it must have a string or boolean value
//     (Linter check candidate)
module.exports = { transform4odataWithCsn };

function transform4odataWithCsn(inputModel, options) {
  timetrace.start('OData transformation');

  // copy the model as we don't want to change the input model
  let csn = cloneCsnNonDict(inputModel, options);

  const { message, error, warning, info, throwWithAnyError } = makeMessageFunction(csn, options, 'for.odata');
  throwWithAnyError();

  // the new transformer works only with new CSN
  checkCSNVersion(csn, options);

  const transformers = transformUtils.getTransformers(csn, options, '_');
  const {
    addDefaultTypeFacets,
    extractValidFromToKeyElement,
    checkAssignment, checkMultipleAssignments,
    recurseElements, setAnnotation, renameAnnotation,
    expandStructsInExpression,
    csnUtils,
  } = transformers;

  const {
    getCsnDef,
    getServiceName,
    isAssocOrComposition,
    isAssociation,
    inspectRef,
    artifactRef,
    effectiveType,
    getFinalTypeInfo
  } = csnUtils;

  // are we working with structured OData or not
  const structuredOData = options.odataFormat === 'structured' && options.odataVersion === 'v4';

  // collect all declared non-abstract services from the model
  // use the array when there is a need to identify if an artifact is in a service or not
  const services = getServiceNames(csn);
  // @ts-ignore
  const externalServices = services.filter(serviceName => csn.definitions[serviceName]['@cds.external']);
  // @ts-ignore
  const isExternalServiceMember = (art, name) => {
    return !!(externalServices.includes(getServiceName(name)) ||  (art && art['@cds.external']))
  }

  if (options.csnFlavor === 'universal' && isBetaEnabled(options, 'enableUniversalCsn'))
    enrichUniversalCsn(csn, options);

  const keepLocalizedViews = isDeprecatedEnabled(options, '_createLocalizedViews');

  function acceptLocalizedView(_name, parent) {
    csn.definitions[parent].$localized = true;
    return keepLocalizedViews && !isExternalServiceMember(undefined, parent);
  }

  addLocalizationViews(csn, options, { acceptLocalizedView, ignoreUnknownExtensions: true });

  // replace all type refs to builtin types with direct type
  transformUtils.rewriteBuiltinTypeRef(csn);

  const cleanup = validate.forOdata(csn, {
    message, error, warning, info, inspectRef, effectiveType, getFinalTypeInfo, artifactRef, csn, options, csnUtils, services, isAspect, isExternalServiceMember
  });


  // Throw exception in case of errors
  throwWithAnyError();

  // Semantic checks before flattening regarding temporal data
  // TODO: Move in the validator
  forEachDefinition(csn, [
    checkTemporalAnnotationsAssignment,
    (def) => {
      // Convert a projection into a query for internal processing will be re-converted
      // at the end of the OData processing
      // TODO: handle artifact.projection instead of artifact.query correctly in future V2
      if (def.kind === 'entity' && def.projection) {
        def.query = { SELECT: def.projection };
      }
    }],
    { skipArtifact: isExternalServiceMember }
  );

  // All type refs must be resolved, including external APIs.
  // OData has no 'type of' so 'real' imported OData APIs marked @cds.external are safe.
  // If in the future 'other' APIs that might support type refs are imported, these refs must be
  // resolved here, as this is the OData transformation and sets the foundation for subsequent EDM
  // rendering which may has to publish external definitions
  expandToFinalBaseType(csn, transformers, csnUtils, services, options);

  // Check if structured elements and managed associations are compared in an expression
  // and expand these structured elements. This tuple expansion allows all other
  // subsequent procession steps (especially a2j) to see plain paths in expressions.
  // If errors are detected, throwWithAnyError() will return from further processing
  expandStructsInExpression(csn, { skipArtifact: isExternalServiceMember, drillRef: true });

  if (!structuredOData) {
    expansion.expandStructureReferences(csn, options, '_', { error, info, throwWithAnyError }, csnUtils, { skipArtifact: isExternalServiceMember });
    const resolved = new WeakMap();
    // No refs with struct-steps exist anymore
    flattening.flattenAllStructStepsInRefs(csn, options, resolved, '_', { skipArtifact: isExternalServiceMember });
    // No type references exist anymore
    // Needs to happen exactly between flattenAllStructStepsInRefs and flattenElements to keep model resolvable.
    // OData doesn't resolve type chains after the first 'items'
    flattening.resolveTypeReferences(csn, options, resolved, '_',
      { skip: [ 'action', 'aspect', 'event', 'function', 'type'],
        skipArtifact: isExternalServiceMember, skipStandard: { items: true } });
    // No structured elements exists anymore
    flattening.flattenElements(csn, options, '_', error,
      { skip: ['action', 'aspect', 'event', 'function', 'type'],
        skipArtifact: isExternalServiceMember,
        skipStandard: { items: true },  // don't drill further into .items
        skipDict: { actions: true } }); // don't drill further into .actions -> bound actions, action-artifacts are handled by skip
  }

  // TODO: add the generated foreign keys to the columns when we are in a view
  // see db/views.js::addForeignKeysToColumns
  flattening.handleManagedAssociationsAndCreateForeignKeys(csn, options, error, warning, '_', !structuredOData, csnUtils,{ skipArtifact: isExternalServiceMember });

  // Allow using managed associations as steps in on-conditions to access their fks
  // To be done after handleManagedAssociationsAndCreateForeignKeys,
  // since then the foreign keys of the managed assocs are part of the elements
  if(!structuredOData)
    forEachDefinition(csn, associations.getFKAccessFinalizer(csn, csnUtils, '_'));

  // structure flattener reports errors, further processing is not safe -> throw exception in case of errors
  throwWithAnyError();

  // Apply default type facets as set by options
  // Flatten on-conditions in unmanaged associations
  /* FIXME (HJB): Is this comment still correct? processOnCond only strips $self
                  We should not remove $self prefixes in structured OData to not
                  interfer with path resolution
  */
  // This must be done before all the draft logic as all
  // composition targets are annotated with @odata.draft.enabled in this step
  forEachDefinition(csn, [ setDefaultTypeFacets, processOnCond ], { skipArtifact: isExternalServiceMember });

  // Now all artificially generated things are in place
  // - Generate artificial draft fields if requested
  // TODO: should be done by the compiler - Check associations for valid foreign keys
  // TODO: check if needed at all: Remove '$projection' from paths in the element's ON-condition
  // - Check associations for:
  //        - exposed associations do not point to non-exposed targets
  //        - structured types must not contain associations for OData V2
  // - Element must not be an 'array of' for OData V2 TODO: move to the validator
  // - Perform checks for exposed non-abstract entities and views - check media type and key-ness
  generateDrafts(csn, options, services)

  // Deal with all kind of annotations manipulations here
  const skipPersNameKinds = {'service':1, 'context':1, 'namespace':1, 'annotation':1, 'action':1, 'function':1};
  forEachDefinition(csn, (def, defName) => {
    // Resolve annotation shorthands for entities, types, annotations, ...
    renameShorthandAnnotations(def);

    // Annotate artifacts with their DB names if requested.
    // Skip artifacts that have no DB equivalent anyway
    if (options.sqlMapping && !(def.kind in skipPersNameKinds))
      def['@cds.persistence.name'] = getArtifactDatabaseNameOf(defName, options.sqlMapping, csn, 'hana'); // hana to allow naming mode "hdbcds"

    forEachMemberRecursively(def, (member, memberName, propertyName) => {
      if (memberName === '' && propertyName === 'params')
        return; // ignore "returns" type
      // Annotate elements, foreign keys, parameters, etc. with their DB names if requested
      // Only these are actually required and don't annotate virtual elements in entities or types
      // as they have no DB representation (although in views)
      if (options.sqlMapping && typeof member === 'object' && !(member.kind === 'action' || member.kind === 'function') && propertyName !== 'enum' && (!member.virtual || def.query)) {
        // If we have a 'preserved dotted name' (i.e. we are a result of flattening), use that for the @cds.persistence.name annotation
        member['@cds.persistence.name'] = getElementDatabaseNameOf(member._flatElementNameWithDots || memberName, options.sqlMapping, 'hana'); // hana to allow "hdbcds"
      }

      // Mark fields with @odata.on.insert/update as @Core.Computed
      annotateCoreComputed(member);

      // Resolve annotation shorthands for elements, actions, action parameters
      renameShorthandAnnotations(member);

      // - If the association target is annotated with @cds.odata.valuelist, annotate the
      //      association with @Common.ValueList.viaAssociation
      // - Check for @Analytics.Measure and @Aggregation.default
      // @ts-ignore
      if (isArtifactInSomeService(defName, services) || isLocalizedArtifactInService(defName, services)) {
        // If the member is an association and the target is annotated with @cds.odata.valuelist,
        // annotate the association with @Common.ValueList.viaAssociation (but only for service member artifacts
        // to avoid CSN bloating). The propagation of the @Common.ValueList.viaAssociation annotation
        // to the foreign keys is done very late in edmPreprocessor.initializeAssociation()
        addCommonValueListviaAssociation(member, memberName);
      }
    }, ['definitions', defName]);

    // Convert a query back into a projection for CSN compliance as
    // the very last conversion step of the OData transformation
    if (def.kind === 'entity' && def.query && def.query && def.projection) {
      delete def.query;
    }
  }, { skipArtifact: isExternalServiceMember })

  if(isBetaEnabled(options, 'odataTerms')) {
    forEachGeneric(csn, 'vocabularies', renameShorthandAnnotations);
  }

  // Throw exception in case of errors
  throwWithAnyError();
  cleanup();
  if (options.testMode) csn = cloneCsnNonDict(csn, options);   // sort, keep hidden properties
  timetrace.stop('OData transformation');
  return csn;

  // TODO: Move this to checks?
  // @ts-ignore
  function checkTemporalAnnotationsAssignment(artifact, artifactName, propertyName, path) {
    // Gather all element names with @cds.valid.from/to/key
    let validFrom = [], validTo = [], validKey = [];
    recurseElements(artifact, ['definitions', artifactName], (member, path) => {
      let [f, t, k] = extractValidFromToKeyElement(member, path);
      validFrom.push(...f);
      validTo.push(...t);
      validKey.push(...k);
    });
    // Check that @cds.valid.from/to/key is only in valid places
    validFrom.forEach(obj => checkAssignment('@cds.valid.from', obj.element, obj.path, artifact));
    validTo.forEach(obj => checkAssignment('@cds.valid.to', obj.element, obj.path, artifact));
    validKey.forEach(obj => checkAssignment('@cds.valid.key', obj.element, obj.path, artifact));
    checkMultipleAssignments(validFrom, '@cds.valid.from', artifact, artifactName);
    checkMultipleAssignments(validTo, '@cds.valid.to', artifact, artifactName);
    checkMultipleAssignments(validKey, '@cds.valid.key', artifact, artifactName);
    if (validKey.length && !(validFrom.length && validTo.length)) {
      error(null, path, 'Annotation “@cds.valid.key” was used but “@cds.valid.from” and “@cds.valid.to” are missing');
    }
  }

  // Mark elements that are annotated with @odata.on.insert/update with the annotation @Core.Computed.
  function annotateCoreComputed(node) {
    // If @Core.Computed is explicitly set, don't overwrite it!
    if (node['@Core.Computed'] !== undefined) return;

    // For @odata.on.insert/update,  also add @Core.Computed
    // @odata.on is deprecated, use @cds.on {update|insert} instead
    if(['@odata.on.insert', '@odata.on.update', '@cds.on.insert', '@cds.on.update'].some(a => node[a]))
      node['@Core.Computed'] = true;
  }

  // Rename shorthand annotations within artifact or element 'node' according to a builtin
  // list.
  function renameShorthandAnnotations(node) {
    // FIXME: Verify this list - are they all still required? Do we need any more?
    const setMappings = {
      '@label': '@Common.Label',
      '@title': '@Common.Label',
      '@description': '@Core.Description',
    };
    const renameMappings = {
      '@ValueList.entity': '@Common.ValueList.entity',
      '@ValueList.type': '@Common.ValueList.type',
      '@Capabilities.Deletable': '@Capabilities.DeleteRestrictions.Deletable',
      '@Capabilities.Insertable': '@Capabilities.InsertRestrictions.Insertable',
      '@Capabilities.Updatable': '@Capabilities.UpdateRestrictions.Updatable',
      '@Capabilities.Readable': '@Capabilities.ReadRestrictions.Readable',
    };

    const setShortCuts = Object.keys(setMappings);
    const renameShortCuts = Object.keys(renameMappings);
    Object.keys(node).forEach( name => {
      if (!name.startsWith('@'))
        return;
      // Rename according to map above
      const renamePrefix = (name in renameMappings) ? name : renameShortCuts.find(p => name.startsWith(p + '.'));
      if(renamePrefix) {
        renameAnnotation(node, name, name.replace(renamePrefix, renameMappings[renamePrefix]));
      } else {
        // The two mappings have no overlap, so no need to check for second map if first matched.
        // Rename according to map above
        const setPrefix = (name in setMappings) ? name : setShortCuts.find(p => name.startsWith(p + '.'));
        if(setPrefix) {
          setAnnotation(node, name.replace(setPrefix, setMappings[setPrefix]), node[name]);
        }
      }

      // Special case: '@readonly' becomes a triplet of capability restrictions for entities,
      // but '@Core.Immutable' for everything else.
      if (!(node['@readonly'] && node['@insertonly'])) {
        if (name === '@readonly' && node[name]) {
          if (node.kind === 'entity' || node.kind === 'aspect') {
            setAnnotation(node, '@Capabilities.DeleteRestrictions.Deletable', false);
            setAnnotation(node, '@Capabilities.InsertRestrictions.Insertable', false);
            setAnnotation(node, '@Capabilities.UpdateRestrictions.Updatable', false);
          } else {
            setAnnotation(node, '@Core.Computed', true);
          }
        }
        // @insertonly is effective on entities/queries only
        else if (name === '@insertonly' && node[name]) {
          if (node.kind === 'entity' || node.kind === 'aspect') {
            setAnnotation(node, '@Capabilities.DeleteRestrictions.Deletable', false);
            setAnnotation(node, '@Capabilities.ReadRestrictions.Readable', false);
            setAnnotation(node, '@Capabilities.UpdateRestrictions.Updatable', false);
          }
        }
      }
      // Only on element level: translate @mandatory
      if (name === '@mandatory' && node[name] &&
        node.kind === undefined && node['@Common.FieldControl'] === undefined) {
        setAnnotation(node, '@Common.FieldControl', { '#': 'Mandatory' });
      }

      if (name === '@assert.format' && node[name] !== null)
        setAnnotation(node, '@Validation.Pattern', node['@assert.format']);

      if (name === '@assert.range' && node[name] !== null) {
        if (Array.isArray(node['@assert.range']) && node['@assert.range'].length === 2) {
          setAnnotation(node, '@Validation.Minimum', node['@assert.range'][0]);
          setAnnotation(node, '@Validation.Maximum', node['@assert.range'][1]);
        }
      }
    });
  }

  // Apply default type facets to each type definition and every member
  // But do not apply default string length 5000 (as in DB)
  function setDefaultTypeFacets(def) {
    addDefaultTypeFacets(def.items || def, false)
    forEachMemberRecursively(def,  m=>addDefaultTypeFacets(m.items || m, false));
    if(def.returns)
      addDefaultTypeFacets(def.returns.items || def.returns, false);
  }

  // Handles on-conditions in unmanaged associations
  function processOnCond(def) {
    forEachMemberRecursively(def, (member) => {
      if (member.on && isAssocOrComposition(member)) {
        removeLeadingDollarSelfInOnCondition(member);
      }
    });

    // removes leading $self in on-conditions's references
    function removeLeadingDollarSelfInOnCondition(assoc) {
      if (!assoc.on) return; // nothing to do
      // TODO: Shouldn't this only run on the on-condition and not the whole assoc-node?
      applyTransformationsOnNonDictionary({ assoc }, 'assoc', {
        ref: (node, prop, ref) => {
          // remove leading $self when at the begining of a ref
          if (ref.length > 1 && ref[0] === '$self')
            node.ref.splice(0, 1);
        }
      });
    }
  }

  // CDXCORE-481
  // (4.5) If the member is an association whose target has @cds.odata.valuelist annotate it
  // with @Common.ValueList.viaAssociation.
  /*
    FIXME (HJB): Comment outdated: Anno propagation to FKs is done in EdmPreprocessor
  */
  // This must be done before foreign keys are calculated and the annotations are propagated
  // to them. This will make sure that association and all its foreign keys are annotated with
  // Common.ValueList in the final EDM.
  // Do this only if the association is navigable and the enclosing artifact is
  // a service member (don't pollute the CSN with unnecessary annotations).
  // TODO: test???
  function addCommonValueListviaAssociation(member, memberName) {
    let vlAnno = '@Common.ValueList.viaAssociation';
    if (isAssociation(member)) {
      let navigable = member['@odata.navigable'] !== false; // navigable disabled only if explicitly set to false
      let targetDef = getCsnDef(member.target);
      if (navigable && targetDef['@cds.odata.valuelist'] && !member[vlAnno]) {
        member[vlAnno] = { '=': memberName };
      }
    }
  }

} // transform4odataWithCsn
