'use strict';

/**
 * Module for general (partial) CSN looper functions, respecting dictionaries and allowing
 * to pass custom callbacks for certain properties like "ref".
 *
 * Functions are also published in csnUtils.js for convenience.
 *
 * They should stay here due to the stricter linter rules for the time being.
 *
 * @module lib/transform/db/applyTransformations
 */
const { setProp } = require('../../base/model');


/**
 * @param {object} parent The "parent" of which we transform a property of
 * @param {string} prop The property of parent to start at
 * @param {object} customTransformers Map of prop to transform and function to apply
 * @param {Function[]} [artifactTransformers=[]] Transformations to run on the artifacts, like forEachDefinition
 * @param {applyTransformationsOptions} [options={}]
 * @param {CSN.Path} path Path to parent
 * @returns {object} parent with transformations applied
 */
function applyTransformationsInternal( parent, prop, customTransformers, artifactTransformers, options, path = [] ) {
  const transformers = {
    elements: dictionary,
    definitions: dictionary,
    actions: dictionary,
    params: dictionary,
    enum: dictionary,
    mixin: dictionary,
    ref: pathRef,
    $origin: () => {}, // no-op
  };

  const csnPath = [ ...path ];
  if (prop === 'definitions') {
    definitions( parent, 'definitions', parent.definitions );
  }
  else if (options.directDict) {
    for (const name of Object.getOwnPropertyNames( parent ))
      standard( parent, name, parent[name] );
  }
  else {
    standard(parent, prop, parent[prop]);
  }
  return parent;

  /**
   * Default transformer for things that are not dictionaries, like "type" or "keys".
   * The customTransformers are applied here (and only here).
   *
   * @param {object | Array} _parent the thing that has _prop
   * @param {string|number} _prop the name of the current property
   * @param {object} node The value of node[_prop]
   */
  function standard( _parent, _prop, node ) {
    if (!node || typeof node !== 'object' ||
        !{}.propertyIsEnumerable.call( _parent, _prop ) ||
        (typeof _prop === 'string' && _prop.startsWith('@')) ||
        (options.skipIgnore && node._ignore) ||
        (options.skipStandard && options.skipStandard[_prop])
    )
      return;

    csnPath.push( _prop );

    if (Array.isArray(node)) {
      node.forEach( (n, i) => standard( node, i, n ) );
    }

    else {
      for (const name of Object.getOwnPropertyNames( node )) {
        const trans = transformers[name] || standard;
        if (customTransformers[name])
          customTransformers[name](node, name, node[name], csnPath, _parent, _prop);

        trans( node, name, node[name], csnPath );
      }
    }
    csnPath.pop();
  }

  /**
   * Transformer for things that are dictionaries - like "elements".
   *
   * @param {object | Array} node the thing that has _prop
   * @param {string|number} _prop the name of the current property
   * @param {object} dict The value of node[_prop]
   */
  function dictionary( node, _prop, dict ) {
    // Allow skipping dicts like actions in forRelationalDB
    if (options.skipDict && options.skipDict[_prop] || dict === null || dict === undefined) // with universal CSN, dicts might be null
      return;
    csnPath.push( _prop );
    for (const name of Object.getOwnPropertyNames( dict ))
      standard( dict, name, dict[name] );

    if (!Object.prototype.propertyIsEnumerable.call( node, _prop ))
      setProp(node, `$${_prop}`, dict);
    csnPath.pop();
  }

  /**
   * Special version of "dictionary" to apply artifactTransformers.
   *
   * @param {object | Array} node the thing that has _prop
   * @param {string|number} _prop the name of the current property
   * @param {object} dict The value of node[_prop]
   */
  function definitions( node, _prop, dict ) {
    csnPath.push( _prop );
    for (const name of Object.getOwnPropertyNames( dict )) {
      const skip = (options && options.allowArtifact && !options.allowArtifact(dict[name], name)) ||
                   (options && options.skipArtifact && options.skipArtifact(dict[name], name)) ||
                   (options && options.skip && options.skip.includes(dict[name].kind)) ||
                   false;
      if (!skip) {
        artifactTransformers.forEach(fn => fn(dict, name, dict[name]));
        standard( dict, name, dict[name] );
      }
    }
    if (!Object.prototype.propertyIsEnumerable.call( node, _prop ))
      setProp(node, `$${_prop}`, dict);
    csnPath.pop();
  }

  /**
   * Keep looping through the pathRef - because in a .ref we can have .args and .where
   *
   * @param {object | Array} node the thing that has _prop
   * @param {string|number} _prop the name of the current property
   * @param {any} _path The value of node[_prop]
   */
  function pathRef( node, _prop, _path ) {
    csnPath.push( _prop );
    _path.forEach( ( s, i ) => {
      if (s && typeof s === 'object') {
        csnPath.push( i );
        if (options.drillRef) {
          standard(_path, i, s);
        }
        else {
          if (s.args)
            standard( s, 'args', s.args );
          if (s.where)
            standard( s, 'where', s.where );
        }
        csnPath.pop();
      }
    } );
    csnPath.pop();
  }
}

/**
 * Loop through the model, applying the custom transformations on the node's matching.
 *
 * Each transformer gets:
 * - the parent having the property
 * - the name of the property
 * - the value of the property
 * - the path to the property
 *
 * @param {object} csn CSN to enrich in-place
 * @param {object} customTransformers Map of _prop to transform and function to apply
 * @param {Function[]} [artifactTransformers=[]] Transformations to run on the artifacts, like forEachDefinition
 * @param {applyTransformationsOptions} [options={}]
 * @returns {object} CSN with transformations applied
 */
function applyTransformations( csn, customTransformers = {}, artifactTransformers = [], options = { } ) {
  if (options.skipIgnore === undefined)
    options.skipIgnore = true;

  if (csn && csn.definitions)
    return applyTransformationsInternal(csn, 'definitions', customTransformers, artifactTransformers, options);
  return csn;
}


/**
 * Instead of looping through the whole model, start at a given thing (like an on-condition),
 * as long as it is not a dictionary.
 *
 * Each transformer gets:
 * - the parent having the property
 * - the name of the property
 * - the value of the property
 * - the path to the property
 *
 * @param {object} parent The "parent" of which we transform a property of
 * @param {string} prop The property of parent to start at
 * @param {object} customTransformers Map of prop to transform and function to apply
 * @param {applyTransformationsOptions} [options={}]
 * @param {CSN.Path} path Path pointing to parent
 * @returns {object} parent[prop] with transformations applied
 */
function applyTransformationsOnNonDictionary( parent, prop, customTransformers = {}, options = {}, path = [] ) {
  return applyTransformationsInternal(parent, prop, customTransformers, [], options, path)[prop];
}

/**
 * Instead of looping through the whole model, start at a given thing (like .elements),
 * as long as it is a dictionary.
 *
 * Each transformer gets:
 * - the parent having the property
 * - the name of the property
 * - the value of the property
 * - the path to the property
 *
 *
 * @param {object} dictionary Dictionary to enrich in-place
 * @param {object} customTransformers Map of prop to transform and function to apply
 * @param {applyTransformationsOptions} [options={}]
 * @param {CSN.Path} path Path pointing to parent
 * @returns {object} dictionary with transformations applied
 */
function applyTransformationsOnDictionary( dictionary, customTransformers = {}, options = {}, path = [] ) {
  return applyTransformationsInternal(dictionary, null, customTransformers, [], { directDict: true, ...options }, path);
}

module.exports = {
  applyTransformations,
  applyTransformationsOnNonDictionary,
  applyTransformationsOnDictionary,
};


/**
 * @typedef {object} applyTransformationsOptions
 * @property {(artifact, name) => boolean} [allowArtifact] to only allow certain artifacts
 * @property {(artifact, name) => boolean} [skipArtifact] to skip certain artifacts
 * @property {boolean} [drillRef] whether to drill into infix/args
 * @property {string[]} [skip] skip definitions from certain kind
 * @property {object} [skipStandard] stop drill-down on certain "standard" props
 * @property {object} [skipDict] stop drill-down on certain "dictionary" props
 * @property {boolean} [skipIgnore=true] Whether to skip _ignore elements or not
 * @property {boolean} [directDict=false] Implicitly set via applyTransformationsOnDictionary
 */
