'use strict';

const { forEachDefinition } = require('../../base/model');
const { applyTransformations, hasAnnotationValue, getResultingName } = require('../../model/csnUtils');
const { csnRefs } = require('../../model/csnRefs');
const { forEach, forEachKey } = require('../../utils/objectUtils');
const { CompilerAssertion } = require('../../base/error');

const COMPOSITION = 'cds.Composition';
const ASSOCIATION = 'cds.Association';
/**
 * Create referential constraints for foreign keys mentioned in on-conditions of associations and compositions.
 * The referential constraints will be attached to the csn.Artifacts.
 *
 * @param {CSN.Model} csn
 * @param {CSN.Options} options are used to modify the validate / enforced flag on the constraints
 */
function createReferentialConstraints( csn, options ) {
  let validated = true;
  let enforced = true;
  if (options.integrityNotValidated)
    validated = false;

  if (options.integrityNotEnforced)
    enforced = false;

  const { inspectRef } = csnRefs(csn);
  // prepare the functions with the compositions and associations across all entities first
  // and execute it afterwards.
  // compositions must be processed first, as the <up_> links for them must result in `ON DELETE CASCADE`
  const compositions = [];
  const associations = [];
  applyTransformations(csn, {
    elements: (parent, prop, elements, path) => {
      // Step I: iterate compositions, enrich dependent keys for <up_> association in target entity of composition
      for (const elementName in elements) {
        const element = elements[elementName];
        const ePath = path.concat([ 'elements', elementName ]); // Save a copy in this scope for the late callback
        if (element.type === COMPOSITION && element.$selfOnCondition) {
          compositions.push({
            fn: () => {
              foreignKeyConstraintForUpLinkOfComposition(element, parent, ePath);
            },
          });
        }
      }

      // Step II: iterate associations, enrich dependent keys (in entity containing the association)
      for (const elementName in elements) {
        const element = elements[elementName];
        const ePath = path.concat([ 'elements', elementName ]); // Save a copy in this scope for the late callback
        if (element.keys && isToOne(element) && element.type === ASSOCIATION || element.type === COMPOSITION && treatCompositionLikeAssociation(element)) {
          associations.push({
            fn: () => {
              foreignKeyConstraintForAssociation(element, ePath );
            },
          });
        }
      }
    },
  }, [], { skipIgnore: false, skipArtifact: a => a.query || a.kind !== 'entity' });

  // create constraints on foreign keys
  // always process unmanaged first, up_ links must be flagged
  // before they are processed
  compositions.forEach(composition => composition.fn());
  associations.forEach(association => association.fn());

  // Step III: Create the final referential constraints from all dependent key <-> parent key pairs stemming from the same $sourceAssociation
  forEachDefinition(csn, collectAndAttachReferentialConstraints);

  /**
   * Retrieve the <up_> link of an `cds.Composition` used in an on-condition like `$self = <comp>.<up_>`
   * and calculate a foreign key constraint for this association if it is constraint compliant.
   * The constraint will have an `ON DELETE CASCADE`.
   *
   * @param {CSN.Element} composition which might has the `$self = <comp>.<up_>` on-condition
   * @param {CSN.Artifact} parent artifact containing the composition
   * @param {CSN.Path} path
   */
  function foreignKeyConstraintForUpLinkOfComposition( composition, parent, path ) {
    const dependent = csn.definitions[path[1]];
    if (skipConstraintGeneration(parent, dependent, composition))
      return;

    const onCondition = composition.on;
    if (composition.$selfOnCondition && composition.$selfOnCondition.up_.length === 1) {
      const upLinkName = composition.$selfOnCondition.up_[0];
      const up_ = csn.definitions[composition.target].elements[upLinkName];
      if (up_.keys && isToOne(up_)) // no constraint for unmanaged / to-many up_ links
        foreignKeyConstraintForAssociation(up_, [ 'definitions', composition.target, 'elements', upLinkName ], path[path.length - 1]);
    }
    else if (!onCondition && composition.keys.length > 0) {
      throw new CompilerAssertion('Please debug me, an on-condition was expected here, but only found keys');
    }
  }

  /**
   * Calculate referential constraints for dependent keys in the entity where the cds.Associations is defined.
   * The DELETE rule for a referential constraint stemming from a cds.Association will be 'RESTRICT'
   * If the association is used as an <up_> link in a compositions on-condition, the ON DELETE rule will be `CASCADE`
   *
   * @param {CSN.Association} association for that a constraint should be generated
   * @param {CSN.Path} path
   * @param {CSN.PathSegment} upLinkFor the name of the composition which used this association in a `$self = <comp>.<up_>` comparison
   */
  function foreignKeyConstraintForAssociation( association, path, upLinkFor = null ) {
    const parent = csn.definitions[association.target];
    const dependent = csn.definitions[path[1]];
    if (skipConstraintGeneration(parent, dependent, association))
      return;
    const { elements } = csn.definitions[path[1]];
    const onCondition = association.on;
    if (onCondition && hasConstraintCompliantOnCondition(association, elements, path)) {
      // 1. cds.Association has constraint compliant on-condition
      // mark each dependent key - in the entity containing the association - referenced in the on-condition
      const dependentKeys = Array.from(elementsOfSourceSide(onCondition, elements));
      const parentKeys = Array.from(elementsOfTargetSide(onCondition, parent.elements));
      // sanity check; do not generate constraints for on-conditions like "dependent.idOne = id AND dependent.idTwo = id"
      if (dependentKeys.length === parentKeys.length)
        attachConstraintsToDependentKeys(dependentKeys, parentKeys, association.target, path[path.length - 1], upLinkFor);
    }
    else if (!onCondition && association.keys.length > 0) {
      throw new CompilerAssertion('Please debug me, an on-condition was expected here, but only found keys');
    }
  }

  /**
   * Attach constraints to individual foreign key elements
   * The $foreignKeyConstraint property will later be collected from the foreign keys
   * and attached to the $tableConstraints property of the respective entity.
   *
   * @param {Array} dependentKeys array holding dependent keys in the format [['key1', 'value1'], [...], ...]
   * @param {Array} parentKeys array holding parent keys in the format [['key1', 'value1'], [...], ...]
   * @param {CSN.PathSegment} parentTable the sql-table where the foreign key constraints will be pointing to
   * @param {CSN.PathSegment} sourceAssociation the name of the association from which the constraint originates
   * @param {CSN.PathSegment} upLinkFor the name of the composition which used this association in a `$self = <comp>.<up_>` comparison
   *                                    it is used for a comment in the constraint, which is only printed out in test-mode
   */
  function attachConstraintsToDependentKeys( dependentKeys, parentKeys, parentTable, sourceAssociation, upLinkFor = null ) {
    while (dependentKeys.length > 0) {
      const dependentKeyValuePair = dependentKeys.pop();
      const dependentKey = dependentKeyValuePair[1];
      // if it already has a dependent key assigned, do not overwrite it.
      // this is the case for <up_> associations in on-conditions of compositions
      if (Object.prototype.hasOwnProperty.call(dependentKey, '$foreignKeyConstraint'))
        return;

      const parentKeyValuePair = parentKeys.pop();
      const parentKeyName = parentKeyValuePair[0];

      const constraint = {
        parentKey: parentKeyName,
        parentTable,
        upLinkFor,
        sourceAssociation,
        onDelete: upLinkFor ? 'CASCADE' : 'RESTRICT',
        validated,
        enforced,
      };
      dependentKey.$foreignKeyConstraint = constraint;
    }
  }

  /**
   * Constraints can only be generated if the full primary key of the target is referenced by the foreign key in an on-condition.
   * 1. on-condition only contains AND as logical operator
   * 2. each part of the on-condition must either:
   *    - reference a valid field in the dependent entity:
   *      a) for cds.Composition this is in the target entity
   *      b) for cds.Association this is the entity, where the association is defined
   *    - reference a key element in the parent entity:
   *      a) for cds.Composition this is the entity, where the composition itself is defined
   *      b) for cds.Association this is the target entity
   * 3. parent keys must be the full primary key tuple
   *
   * @param {CSN.Association} element
   * @param {CSN.Elements} siblingElements
   * @param {CSN.Path} path the path to the element
   * @returns {boolean} indicating whether the association / composition is a constraint candidate
   */
  function hasConstraintCompliantOnCondition( element, siblingElements, path ) {
    const onCondition = element.on;
    const allowedTokens = [ '=', 'and', '(', ')' ];
    // on condition must only contain logical operator 'AND'
    if (onCondition.some(step => typeof step === 'string' && !allowedTokens.includes(step)))
      return false;

    // on-condition like ... TemplateAuthGroupAssignments.isTemplate = true; is not allowed
    if (onCondition.some(step => typeof step === 'object' && Object.prototype.hasOwnProperty.call(step, 'val')))
      return false;

    // no magic vars in on-condition
    // e.g. for localized: ... and localized.locale = $user.locale; -> not a valid on-condition
    if (onCondition.some((step, index) => typeof step === 'object' && inspectRef(path.concat([ 'on', index ])).scope === '$magic'))
      return false;

    // for cds.Associations the parent keys are in the associations target entity
    // for cds.Composition the parent keys are in the entity, where the composition is defined
    const parentElements = csn.definitions[element.target].elements;
    const parentKeys = elementsOfTargetSide(onCondition, parentElements);

    const referencesNonPrimaryKeyField = Array.from(parentKeys.values()).some(parentKey => !parentKey.key);
    if (referencesNonPrimaryKeyField)
      return false;

    // returns true if the parentKeys found in the on-condition are covering the full primary key tuple in the parent entity
    return Array.from(parentKeys.entries())
      // check if primary key found in on-condition is present in association target / composition source
      .filter(([ keyName, pk ]) => pk.key && parentElements[keyName].key).length ===
      Object.keys(parentElements)
        // compare that with the length of the primary key tuple found in association target / composition source
        .filter(key => parentElements[key].key &&
          parentElements[key].type !== ASSOCIATION &&
          parentElements[key].type !== COMPOSITION)
        .length;
  }
  /**
   *  Skip referential constraint if the parent table (association target, or artifact where composition is defined)
   *  of the relation is:
   *    - a query
   *    - annotated with '@cds.persistence.skip:true'
   *
   *  The following decision table reflects the current implementation:
   *
   *   +-----------------+--------------------+-------------------+----------+
   *   | Global Switch:  | Global Check Type:  | @assert.integrity | Generate  |
   *   |"assertIntegrity"| "assertIntegrityType"|                   | Constraint|
   *   +-----------------+--------------------+-------------------+----------+
   *   | on              | RT                 | false             | no       |
   *   +-----------------+--------------------+-------------------+----------+
   *   | on              | RT                 | true/not set      | no       |
   *   +-----------------+--------------------+-------------------+----------+
   *   | on              | RT                 | RT                | no       |
   *   +-----------------+--------------------+-------------------+----------+
   *   | on              | RT                 | DB                | yes      |
   *   +-----------------+--------------------+-------------------+----------+
   *   |                 |                    |                   |          |
   *   +-----------------+--------------------+-------------------+----------+
   *   | on              | DB                 | false             | no       |
   *   +-----------------+--------------------+-------------------+----------+
   *   | on              | DB                 | true/not set      | yes      |
   *   +-----------------+--------------------+-------------------+----------+
   *   | on              | DB                 | RT                | no       |
   *   +-----------------+--------------------+-------------------+----------+
   *   | on              | DB                 | DB                | yes      |
   *   +-----------------+--------------------+-------------------+----------+
   *   |                 |                    |                   |          |
   *   +-----------------+--------------------+-------------------+----------+
   *   | off             | don't care         | don't care        | no       |
   *   +-----------------+--------------------+-------------------+----------+
   *   |                 |                    |                   |          |
   *   +-----------------+--------------------+-------------------+----------+
   *   | individual      | RT                 | true              | no       |
   *   +-----------------+--------------------+-------------------+----------+
   *   | individual      | DB                 | true              | yes      |
   *   +-----------------+--------------------+-------------------+----------+
   *   | individual      | don't care         | RT                | no       |
   *   +-----------------+--------------------+-------------------+----------+
   *   | individual      | don't care         | DB                | yes      |
   *   +-----------------+--------------------+-------------------+----------+
   *   | individual      | don't care         | false/not set     | no       |
   *   +-----------------+--------------------+-------------------+----------+
   *
   * @param {CSN.Definition} parent entity where the foreign key reference will point at
   * @param  {CSN.Definition} dependent entity where the constraint will be defined on
   * @param {CSN.Association} element the composition or association
   * @returns {boolean}
   */
  function skipConstraintGeneration( parent, dependent, element ) {
    // if set to 'off' don't even bother, just skip all constraints
    if (options.assertIntegrity === false || options.assertIntegrity === 'false')
      return true;

    if (parent.query)
      return true;

    // no constraint if either dependent or parent is not persisted
    if (
      hasAnnotationValue(parent, '@cds.persistence.skip') ||
      hasAnnotationValue(dependent, '@cds.persistence.skip') ||
      hasAnnotationValue(parent, '@cds.persistence.exists') ||
      hasAnnotationValue(dependent, '@cds.persistence.exists')
    )
      return true;

    // some commonly used string literals
    const RT = 'RT';
    const DB = 'DB';
    const CREATE_FOR_UP = '$createReferentialConstraintForUp_';
    const SKIP_FOR_UP = '$skipReferentialConstraintForUp_';

    // if the element itself is explicitly excluded from being checked
    // skip the constraint for it (and its backlink)
    if (isAssertIntegrityAnnotationSetTo(false) ||
      isAssertIntegrityAnnotationSetTo(RT) ||
      element[SKIP_FOR_UP]
    ) {
      // for "auto-generated" associations like for the up_ of a composition of aspects,
      // the annotation on the composition influences the referential constraint for the
      // up_ association
      if (element.$selfOnCondition && element.targetAspect)
        assignPropOnBacklinkIfPossible(SKIP_FOR_UP, true);

      return true;
    }
    const runtimeChecks = options.assertIntegrityType && options.assertIntegrityType.toUpperCase() === RT;
    const compilerChecks = options.assertIntegrityType && options.assertIntegrityType.toUpperCase() === DB;

    if ((!options.assertIntegrity || options.assertIntegrity === true || options.assertIntegrity === 'true') &&
      (!options.assertIntegrityType || runtimeChecks))
      return assertForIntegrityTypeRT();

    if ((!options.assertIntegrity || options.assertIntegrity === true || options.assertIntegrity === 'true') &&
      compilerChecks)
      return assertForIntegrityTypeDB();

    if ((options.assertIntegrity === 'individual'))
      return assertForIndividual();

    // The default for the assertIntegrityType is 'RT', no constraints in that case
    if ((!options.assertIntegrity || options.assertIntegrity === true) &&
      (!options.assertIntegrityType || runtimeChecks))
      return true;

    if (!element.keys || !isToOne(element))
      return true;

    return false;

    /**
     *  if global checks are 'individual' we evaluate every association,
     *  we create db constraints if it is annotated with @assert.integrity: 'DB' (or true)
     *
     * @returns {boolean}
     */
    function assertForIndividual() {
      if (isAssertIntegrityAnnotationSetTo(DB) || element[CREATE_FOR_UP]) {
        // if this is has a $self comparison, the up_ link should then result in a constraint
        assignPropOnBacklinkIfPossible(CREATE_FOR_UP, true);
        return false;
      }
      if (options.assertIntegrityType === DB && isAssertIntegrityAnnotationSetTo(true)) {
        // if this is has a $self comparison, the up_ link should then result in a constraint
        assignPropOnBacklinkIfPossible(CREATE_FOR_UP, true);
        return false;
      }

      // individual and no ('DB') annotation on constraint --> skip
      return true;
    }

    /**
     * if global check type is 'RT' (or not provided) only generate DB constraint if element
     * is explicitly annotated "@assert.integrity: 'DB'"
     *
     * @returns {boolean}
     */
    function assertForIntegrityTypeRT() {
      // for "auto-generated" associations like for the up_ of a composition of aspects,
      // the annotation on the composition influences the referential constraint for the
      // up_ association
      if (isAssertIntegrityAnnotationSetTo(DB)) {
        if (element.targetAspect)
          assignPropOnBacklinkIfPossible(CREATE_FOR_UP, true);
        return false;
      }
      if (element[CREATE_FOR_UP])
        return false;
      return true;
    }

    /**
     * if global checks are on and global integrity check type is 'DB'
     * we create db constraints in any case except if annotated
     * with @assert.integrity: 'RT' (or false, but that is rejected earlier)
     *
     * @returns {boolean}
     */
    function assertForIntegrityTypeDB() {
      return isAssertIntegrityAnnotationSetTo(RT);
    }

    /**
     * convenience to check if value of element's @assert.integrity annotation
     * is the same as a given value
     *
     * @param {string|boolean} value
     * @returns {boolean}
     */
    function isAssertIntegrityAnnotationSetTo( value ) {
      return hasAnnotationValue(element, '@assert.integrity', value, true);
    }

    /**
     * Assigns a helper key-value pair on the up_ association for a $self comparison
     * for the current 'element', if applicable
     *
     * @param {string} prop
     * @param {object} val
     */
    function assignPropOnBacklinkIfPossible( prop, val ) {
      if (!element.$selfOnCondition)
        return;
      const target = csn.definitions[element.target];
      const backlink = target.elements[element.$selfOnCondition.up_[0]];
      backlink[prop] = val;
    }
  }

  /**
   * If we have a managed composition with a target cardinality of one, we will treat it like
   * a regular association when it comes to referential constraints.
   * The constraint will thus be generated for the foreign key we create in the source entity.
   *
   * @param {CSN.Composition} composition the composition which might be treated like an association
   * @returns {boolean} true if the composition should be treated as an association in regards to foreign key constraints
   */
  function treatCompositionLikeAssociation( composition ) {
    return Boolean(isToOne(composition) && composition.keys);
  }

  /**
   * returns true if the association/composition has a max target cardinality of one
   *
   * @param {CSN.Association|CSN.Composition} assocOrComposition
   * @returns {boolean}
   */
  function isToOne( assocOrComposition ) {
    const { min, max } = assocOrComposition.cardinality || {};
    return !min && !max || max === 1;
  }

  /**
   * Finds and returns elementNames and elements of target side mentioned in on-condition.
   *
   * @param {CSN.OnCondition} on
   * @param {CSN.Elements} targetElements elements of association/composition target entity
   * @returns {Map} of target elements with their name as key
   */
  function elementsOfTargetSide( on, targetElements ) {
    const elements = new Map();
    on.filter(element => typeof element === 'object' &&
      element.ref.length > 1 &&
      targetElements[element.ref[element.ref.length - 1]])
      .forEach((element) => {
        elements.set(element.ref[element.ref.length - 1], targetElements[element.ref[element.ref.length - 1]]);
      });

    return elements;
  }

  /**
   * Finds and return elementNames and elements of source side mentioned in on-condition.
   *
   * @param {CSN.OnCondition} on the on-condition
   * @param {CSN.Elements} sourceElements elements of source entity where the association/composition is defined.
   * @returns {Map} of source elements with their name as key
   */
  function elementsOfSourceSide( on, sourceElements ) {
    const elements = new Map();
    on.filter(element => typeof element === 'object' &&
      element.ref.length === 1 &&
      sourceElements[element.ref[0]])
      .forEach((element) => {
        elements.set(element.ref[0], sourceElements[element.ref[0]]);
      });
    return elements;
  }

  /**
   * Creates the final referential constraints from all dependent key <-> parent key pairs stemming from the same $sourceAssociation
   * and attaches it to the given artifact.
   *
   * Go over all elements with $foreignKeyConstraint property:
   *  - Find all other elements in artifact with the same $sourceAssociation
   *  - Create constraints with the information supplied by $parentKey, $parentTable and $onDelete
   *
   * @param {CSN.Artifact} artifact
   * @param {string} artifactName
   */
  function collectAndAttachReferentialConstraints( artifact, artifactName ) {
    const referentialConstraints = Object.create(null);
    for (const elementName in artifact.elements) {
      const element = artifact.elements[elementName];
      if (!element.$foreignKeyConstraint)
        continue;
      // copy constraint property, and delete it from the element
      const $foreignKeyConstraint = Object.assign({}, element.$foreignKeyConstraint);
      delete element.$foreignKeyConstraint;
      const { parentTable } = $foreignKeyConstraint;
      const parentKey = [ $foreignKeyConstraint.parentKey ];
      const dependentKey = [ elementName ];
      const onDeleteRules = new Set();
      onDeleteRules.add($foreignKeyConstraint.onDelete);
      forEach(artifact.elements, (foreignKeyName, foreignKey) => {
        // find all other `$foreignKeyConstraint`s with same `$sourceAssociation` and same `parentTable`
        const matchingForeignKeyFound = foreignKey.$foreignKeyConstraint &&
        foreignKey.$foreignKeyConstraint.sourceAssociation === $foreignKeyConstraint.sourceAssociation &&
        foreignKey.$foreignKeyConstraint.parentTable === $foreignKeyConstraint.parentTable;
        if (!matchingForeignKeyFound)
          return;

        const $foreignKeyConstraintCopy = Object.assign({}, foreignKey.$foreignKeyConstraint);
        delete foreignKey.$foreignKeyConstraint;
        parentKey.push($foreignKeyConstraintCopy.parentKey);
        dependentKey.push(foreignKeyName);
        onDeleteRules.add($foreignKeyConstraintCopy.onDelete);
      });
      // onDelete Rule is the "weakest" rule applicable. Precedence: RESTRICT > SET NULL > CASCADE
      const onDelete = onDeleteRules.has('RESTRICT') ? 'RESTRICT' : 'CASCADE';
      let onDeleteRemark = null;
      // comments in sqlite files are causing the JDBC driver to throw an error on deployment
      if (options.testMode && onDelete === 'CASCADE')
        onDeleteRemark = `Up_ link for Composition "${$foreignKeyConstraint.upLinkFor}" implies existential dependency`;
      // constraint identifier usually start with `c__` to avoid name clashes
      let identifier = options.pre2134ReferentialConstraintNames ? '' : 'c__';
      identifier += `${getResultingName(csn, options.sqlMapping, artifactName)}_${$foreignKeyConstraint.sourceAssociation}`;
      referentialConstraints[`${getResultingName(csn, 'quoted', artifactName)}_${$foreignKeyConstraint.sourceAssociation}`] = {
        identifier,
        foreignKey: dependentKey,
        parentKey,
        dependentTable: artifactName,
        parentTable,
        onDelete,
        onDeleteRemark, // explain why this particular rule is chosen
        validated: $foreignKeyConstraint.validated,
        enforced: $foreignKeyConstraint.enforced,
      };
    }
    if (Object.keys(referentialConstraints).length) {
      if (!('$tableConstraints' in artifact))
        artifact.$tableConstraints = Object.create(null);

      artifact.$tableConstraints.referential = referentialConstraints;
    }
  }
}

/**
 * If the artifact has both, unique- and foreign key constraints, it is possible that the constraints have the same identifier.
 * This would end in table which can't be activated.
 *
 * @param {CSN.Artifact} artifact
 * @param {string} artifactName
 * @param {CSN.Path} path
 * @param {Function} error
 */
function assertConstraintIdentifierUniqueness( artifact, artifactName, path, error ) {
  // can only happen if referential & unique constraints are present
  if (!(artifact.$tableConstraints && artifact.$tableConstraints.referential && artifact.$tableConstraints.unique))
    return;

  forEachKey(artifact.$tableConstraints.unique, (uniqueConstraintKey) => {
    const uniqueConstraintIdentifier = `${artifactName}_${uniqueConstraintKey}`; // final unique constraint identifier will be generated in renderer likewise
    if (artifact.$tableConstraints.referential[uniqueConstraintIdentifier]) {
      error(null, path,
            { name: uniqueConstraintIdentifier, art: artifactName },
            'Duplicate constraint name $(NAME) in artifact $(ART)');
    }
  });
}

module.exports = { createReferentialConstraints, assertConstraintIdentifierUniqueness };
