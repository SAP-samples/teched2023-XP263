'use strict';

const {
  applyTransformationsOnNonDictionary,
  applyTransformations,
} = require('../../model/csnUtils');

/**
 * In all .elements of entities and views (and their bound actions/functions), create the on-condition for
 * a managed associations. This needs to happen after the .keys are expanded and the corresponding elements are created.
 *
 * @param {CSN.Model} csn
 * @param {object} csnUtils
 * @param {string} pathDelimiter
 * @returns {CSN.Model} Return the input csn, with the transformations applied
 */
function attachOnConditions( csn, csnUtils, pathDelimiter ) {
  const {
    isManagedAssociation,
  } = csnUtils;

  const alreadyHandled = new WeakMap();
  applyTransformations(csn, {
    elements: (parent, prop, elements) => {
      for (const elemName in elements) {
        const elem = elements[elemName];
        // (140) Generate the ON-condition for managed associations
        if (isManagedAssociation(elem))
          transformManagedAssociation(elem, elemName);
      }
    },     /* only for views and entities */
  }, [], { skipIgnore: false, allowArtifact: artifact => (artifact.kind === 'entity') });

  return csn;

  /**
   * Create the foreign key elements for a managed association and build the on-condition
   *
   * @param {object} elem The association to process
   * @param {string} elemName
   * @returns {void}
   */
  function transformManagedAssociation( elem, elemName ) {
    // No need to run over this - we already did, possibly because it was referenced in the ON-Condition
    // of another association - see a few lines lower
    if (alreadyHandled.has(elem))
      return;
    // Assemble an ON-condition with the foreign keys created in earlier steps
    const onCondParts = [];
    let joinWithAnd = false;
    if (elem.keys.length === 0) { // TODO: really kill instead of _ignore?
      elem._ignore = true;
    }
    else {
      for (const foreignKey of elem.keys) {
        // Assemble left hand side of 'assoc.key = fkey'
        const assocKeyArg = {
          ref: [
            elemName,
          ].concat(foreignKey.ref),
        };
        const fkName = `${elemName}${pathDelimiter}${foreignKey.as}`;
        const fKeyArg = {
          ref: [
            fkName,
          ],
        };

        if (joinWithAnd) { // more than one FK
          onCondParts.push('and');
        }

        onCondParts.push(
          assocKeyArg
        );
        onCondParts.push('=');
        onCondParts.push(fKeyArg);

        if (!joinWithAnd)
          joinWithAnd = true;
      }
      elem.on = onCondParts;
    }

    // If the managed association has a 'key' property => remove it as unmanaged assocs cannot be keys
    // TODO: Are there other modifiers (like 'key') that are valid for managed, but not valid for unmanaged assocs?
    if (elem.key)
      delete elem.key;

    // If the managed association has a 'not null' property => remove it
    if (elem.notNull)
      delete elem.notNull;

    // The association is now unmanaged, i.e. actually it should no longer have foreign keys
    // at all. But the processing of backlink associations below expects to have them, so
    // we don't delete them
    // TODO: maybe make non-enumerable, so we become recompilable in the future?

    // Remember that we already processed this
    alreadyHandled.set(elem, true);
  }
}

/**
 * @param {CSN.Model} csn
 * @param {object} csnUtils
 * @param {string} pathDelimiter
 * @returns {(artifact: CSN.Artifact, artifactName: string) => void} Callback for forEachDefinition
 */
function getFKAccessFinalizer( csn, csnUtils, pathDelimiter ) {
  const {
    inspectRef,
  } = csnUtils;

  return handleManagedAssocSteps;

  /**
   * Loop over all elements and for all unmanaged associations translate
   * <assoc base>.<managed assoc>.<fk> to <assoc base>.<managed assoc>_<fk>
   *
   * Or in other words: Allow using the foreign keys of managed associations in on-conditions
   *
   * @param {CSN.Artifact} artifact Artifact to check
   * @param {string} artifactName Name of the artifact
   */
  function handleManagedAssocSteps( artifact, artifactName ) {
    const transformer = {
      ref: (refOwner, prop, ref, path) => {
        // [<assoc base>.]<managed assoc>.<field>
        if (ref.length > 1) {
          const { links } = inspectRef(path);
          if (links) {
            // eslint-disable-next-line for-direction
            for (let i = links.length - 1; i >= 0; i--) {
              const link = links[i];
              // We found the latest managed assoc path step
              if (link.art && link.art.target && link.art.keys &&
                    // Doesn't work when ref-target (filter condition) or similar is used
                    !ref.slice(i).some(refElement => typeof refElement !== 'string')) {
                // We join the managed assoc with everything following it
                const sourceElementName = ref.slice(i).join(pathDelimiter);
                const source = findSource(links, i - 1) || artifact;
                // allow specifying managed assoc on the source side
                const fks = link.art.keys.filter(fk => ref[i] + pathDelimiter + fk.ref[0] === sourceElementName);
                if (fks && fks.length >= 1) {
                  const fk = fks[0];
                  const managedAssocStepName = refOwner.ref[i];
                  const fkName = `${managedAssocStepName}${pathDelimiter}${fk.as}`;
                  if (source && source.elements[fkName])
                    refOwner.ref = [ ...ref.slice(0, i), fkName ];
                }
              }
            }
          }
        }
      },
    };
    for (const elemName in artifact.elements) {
      const elem = artifact.elements[elemName];
      // The association is an unmanaged one
      if (!elem.keys && elem.target && elem.on)
        applyTransformationsOnNonDictionary(elem, 'on', transformer, {}, [ 'definitions', artifactName, 'elements', elemName ]);
    }

    if (artifact.query || artifact.projection) {
      applyTransformationsOnNonDictionary(artifact, artifact.query ? 'query' : 'projection', {
        orderBy: (parent, prop, thing, path) => applyTransformationsOnNonDictionary(parent, prop, transformer, {}, path),
        groupBy: (parent, prop, thing, path) => applyTransformationsOnNonDictionary(parent, prop, transformer, {}, path),
      }, {}, [ 'definitions', artifactName ]);
    }


    /**
     * Find out where the managed association is
     *
     * @param {Array} links
     * @param {number} startIndex
     * @returns {object | undefined} CSN definition of the source of the managed association
     */
    function findSource( links, startIndex ) {
      for (let i = startIndex; i >= 0; i--) {
        const link = links[i];
        // We found the latest assoc step - now check where that points to
        if (link.art && link.art.target)
          return csn.definitions[link.art.target];
      }

      return undefined;
    }
  }
}
module.exports = {
  attachOnConditions,
  getFKAccessFinalizer,
};
