'use strict';

const { isBetaEnabled } = require('../../base/model');
const {
  forEachDefinition, forEachGeneric, forEachMemberRecursively,
  isBuiltinType, cloneCsnDictionary, cloneCsnNonDict,
} = require('../../model/csnUtils');
const { isArtifactInSomeService, isArtifactInService } = require('./utils');

function expandToFinalBaseType(csn, transformers, csnUtils, services, options, isExternalServiceMember) {
  const isV4 = options.odataVersion === 'v4';
  const special$self = !csn?.definitions?.$self && '$self';
  forEachDefinition(csn, (def, defName) => {
    // Unravel derived type chains to final one for elements, actions, action parameters (propagating annotations)
    forEachMemberRecursively(def, (member) => {
      expandToFinalBaseType(member, defName);
      expandToFinalBaseType(member.items, defName);
      expandToFinalBaseType(member.returns, defName);
      expandToFinalBaseType(member.returns && member.returns.items, defName);

    }, ['definitions', defName]);

    expandToFinalBaseType(def, defName);
    expandToFinalBaseType(def.items, defName);
    expandToFinalBaseType(def.returns, defName);
    expandToFinalBaseType(def.returns && def.returns.items, defName);
    /*
      If the definition('def' variable) is a type definition and the assigned type of this very same definition('def' variable)
      is structured type, e.g.:

      type Struct1 {
        a : Integer;
        b : Integer;
      };
      type Struct2: Struct1;
      after compilation the csn looks like this:
      ...
      "S.Struct1": {
        "kind": "type",
        "elements": {
          "a": { "type": "cds.Integer" },
          "b": { "type": "cds.Integer" }
        } },
      "S.Struct2": {
        "kind": "type",
        "type": "S.Struct1",
        "elements": {
          "a": { "type": "cds.Integer" },
          "b": { "type": "cds.Integer" }
        } } ...

      "S.Struct2" should looks just like "S.Struct1" => the "type": "S.Struct1" property has to be removed
    */
    if (def.kind === 'type' && def.type && !isBuiltinType(def.type) && !def.type.ref) {
      // elements are already there -> do not show the type
      delete def.type;
    }
    // TODO: this is more types exposure related, check and move
    // In case we have in the model something like:
    // type Foo: array of Bar; type Bar: { qux: Integer };
    // In the type Foo we expand the first level of elements of the items or
    // type Foo: array of { qux: Integer };
    if (def.kind === 'type' && def.items && isArtifactInSomeService(defName, services)) {
      expandFirstLevelOfArrayed(def);
    }
  }, { skipArtifact: isExternalServiceMember });

  if(isBetaEnabled(options, 'odataTerms')) {
    forEachGeneric(csn, 'vocabularies', (def, defName) => {
      forEachMemberRecursively(def, (member) => {
        expandToFinalBaseType(member, defName);
        expandToFinalBaseType(member.items, defName);

      }, ['vocabularies', defName]);

      expandToFinalBaseType(def, defName);
      expandToFinalBaseType(def.items, defName);
    }, [], { skipArtifact: isExternalServiceMember });
  }
  // In case we have in the model something like:
  // type Foo: array of Bar; type Bar: { qux: Integer };
  // In the type Foo we expand the first level of elements of the items like we have in CDL this:
  // type Foo: array of { qux: Integer };
  function expandFirstLevelOfArrayed(def) {
    if (def.items.type && !isBuiltinType(def.items.type)) {
      let finalBaseType = csnUtils.getFinalTypeInfo(def.items.type);
      if (finalBaseType?.elements) {
        def.items.elements = cloneCsnDictionary(finalBaseType.elements, options);
        delete def.items.type;
      }
    }
  }

  function expandToFinalBaseType(node, defName) {
    if (!node) return;
    // TODO: Clarify how should events be handled?
    // They are not treated by the transformUtilsNew::toFinalBaseType function
    // in the same manner as named types, because the elements of structured events are not
    // propagated as it is with types.
    // It is ok to skip the expansion to the final base type for now as events are not rendered in
    // EDMX at the moment and the reference in the OData CSN is fulfilled.
    if (node.kind === 'event') return;

    if(node.type && !isBuiltinType(node.type)) {
      const finalBaseType = csnUtils.getFinalTypeInfo(node.type);
      if(!finalBaseType) {
        /*
          type could not be resolved, set it to null
          Today, all type refs must be resolvable,
          input validations checkTypeDefinitionHasType, checkElementTypeDefinitionHasType
          guarantee this. In the future this may change.
        */
        node.type = null;
      }
      else {
        if (isExpandable(finalBaseType) || node.kind === 'type') {
          // 1. Get the final type of the node (resolve derived type chain)
          if (finalBaseType.type !== special$self) {
            // The type replacement depends on whether 'node' is a definition or a member[element].
            if (node.kind) {
              /*
                It is a definition and we expand to builtin type and to elements
                type T: S; --> Integer;
                type S: X; --> Integer;
                type X: Integer;

                type A: B; -> {...}
                type B: C; -> { ... }
                type C { .... };
              */
              if (isBuiltinType(finalBaseType.type)) {
                /*
                  use transformUtilsNew::toFinalBaseType for the moment,
                  as it is collects along the chain of types
                  attributes that need to be propagated
                  enum, length, scale, etc.
                */
                transformers.toFinalBaseType(node);
              }
              else if (csnUtils.isStructured(finalBaseType)) {
                cloneElements(finalBaseType);
              }
              else if (node.type && node.items)
                delete node.type;
            }
            else {
              /*
                this is a member and we expand to final base only if builtin
                  type T: S; --> Integer;
                  type S: X; --> Integer;
                  type X: Integer;

                  type {
                    struct_elt: many A; ---> stays the same
                    scalar_elt: T; ---> Integer;
                    type_ref_elt: type of struct_elt;
                  };
                  type A: B; -> {...}
                  type B: C; -> { ... }
                  type C { .... };
              */
              if (isBuiltinType(finalBaseType.type)) {
                /*
                  use transformUtilsNew::toFinalBaseType for the moment,
                  as it is collects along the chain of types
                  attributes that need to be propagated
                  enum, length, scale, etc.
                */
                transformers.toFinalBaseType(node);
                // node.type = finalType;
              }
              else if (node.type && node.type.ref) {
                cloneElements(finalBaseType);
              }
            }
          }
        }
        if (/*the resolved type is not built in*/ !isBuiltinType(node.type)) {
          // handle array of defined via a named type
          // example in actions: 'action act() return Primitive; type Primitive: array of String;'
          const currService = csnUtils.getServiceName(defName);
          const isArrayOfBuiltin = finalBaseType.items &&
            isBuiltinType(csnUtils.getFinalTypeInfo(finalBaseType.items.type)?.type)
          if (isArrayOfBuiltin && (!isArtifactInService(node.type, currService) || !isV4)) {
            node.items = finalBaseType.items;
            delete node.type;
          }
        }
      }
    }

    function cloneElements(finalBaseType) {
      // cloneCsn only works correctly if we start "from the top"
      let clone;
      // do the clone only if really needed
      if((finalBaseType.items && !node.items) ||
         (finalBaseType.elements && !node.elements))
        clone = cloneCsnNonDict({ definitions: { 'TypeDef': finalBaseType } }, options);
      if (finalBaseType.items) {
        delete node.type;
        if(!node.items)
          Object.assign(node, { items: clone.definitions.TypeDef.items });
      }
      if (finalBaseType.elements) {
        if(!finalBaseType.items)
          delete node.type;
        if(!node.elements)
          Object.assign(node, { elements: clone.definitions.TypeDef.elements });
      }
    }

    /*
      Check, if a type needs to be expanded into the service

      All types are expansion candidates except these in V4:
      - it's a builtin
      - it's an assoc
      - the referred type is defined in the service
    */
    function isExpandable(finalBaseType) {
        // in V4 we should use TypeDefinitions whenever possible, thus in case the final type of a field is
        // a builtin from the service - do not expand to the final base type

      const currService = csnUtils.getServiceName(defName);
      const isBuiltin = isBuiltinType(finalBaseType.type);
      const isAssoc = node.target;
      const isInCurServ = isArtifactInService(node.type, currService);
      return !isV4 || !(isBuiltin && !isAssoc && isInCurServ);
    }
  }
}

module.exports = expandToFinalBaseType;
