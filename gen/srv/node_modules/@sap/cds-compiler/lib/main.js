// Main entry point for the CDS Compiler
//
// File for external usage = which is read in other modules with
//   require('cdsv');

// Proposed intra-module lib dependencies:
//  - lib/base/<file>.js: can be required by all others, requires no other
//    of this project
//  - lib/<dir>/<file>.js: can be required by other files lib/<dir>/,
//    can require other files lib/<dir>/ and lib/base/<file>.js
//  - lib/main.js (this file): can be required by none in lib/ (only in
//    bin/ and test/), can require any other

'use strict';

const snapi = lazyload('./api/main');
const csnUtils = lazyload('./model/csnUtils');
const model_api = lazyload('./model/api');
const messages = lazyload('./base/messages');
const sqlIdentifier = lazyload('./sql-identifier');
const keywords = lazyload( './base/keywords' );
const toCdl = lazyload('./render/toCdl');

const parseLanguage = lazyload('./language/antlrParser');
const compiler = lazyload('./compiler');
const shared = lazyload('./compiler/shared');
const define = lazyload('./compiler/define');
const builtins = lazyload('./compiler/builtins');
const base = lazyload('./compiler/base');
const finalizeParseCdl = lazyload('./compiler/finalize-parse-cdl');

// The compiler version (taken from package.json)
function version() {
  return require('../package.json').version;
}

const toCsn = lazyload('./json/to-csn')

function parseCdl( cdlSource, filename, options = {} ) {
  options = Object.assign( {}, options, { parseCdl: true } );
  const sources = Object.create(null);
  /** @type {XSN.Model} */
  const model = { sources, options, $functions: {}, $volatileFunctions: {} };
  const messageFunctions = messages.createMessageFunctions( options, 'parse', model );
  model.$messageFunctions = messageFunctions;

  const xsn = parseLanguage( cdlSource, filename, Object.assign( { parseOnly: true }, options ),
                             messageFunctions );
  sources[filename] = xsn;
  shared.fns( model );
  define( model );
  finalizeParseCdl( model );
  messageFunctions.throwWithError();
  return toCsn.compactModel( model );
}

function parseCql( cdlSource, filename = '<query>.cds', options = {} ) {
  const messageFunctions = messages.createMessageFunctions( options, 'parse' );
  const xsn = parseLanguage( cdlSource, filename, Object.assign( { parseOnly: true }, options ),
                             messageFunctions, 'query' );
  messageFunctions.throwWithError();
  return toCsn.compactQuery( xsn );
}

function parseExpr( cdlSource, filename = '<expr>.cds', options = {} ) {
  const messageFunctions = messages.createMessageFunctions( options, 'parse' );
  const xsn = parseLanguage( cdlSource, filename, Object.assign( { parseOnly: true }, options ),
                             messageFunctions, 'expr' );
  messageFunctions.throwWithError();
  return toCsn.compactExpr( xsn );
}

// FIXME: The implementation of those functions that delegate to 'backends' should probably move here
// ATTENTION: Keep in sync with main.d.ts!
module.exports = {
  // Compiler
  version,
  compile: (...args) => compiler.compileX(...args).then( toCsn.compactModel ), // main function
  compileSync: (filenames, dir, options, fileCache) => toCsn.compactModel( compiler.compileSyncX(filenames, dir, options, fileCache) ), // main function
  compileSources: (sourcesDict, options) => toCsn.compactModel( compiler.compileSourcesX(sourcesDict, options) ), // main function
  compactModel: csn => csn,     // for easy v2 migration
  get CompilationError() {
    Object.defineProperty(this, 'CompilationError', {
      value: messages.CompilationError,
      writable: false,
      configurable: false,
      enumerable: false
    });
    return messages.CompilationError;
  },
  sortMessages: (...args) => messages.sortMessages(...args),
  sortMessagesSeverityAware: (...args) => messages.sortMessagesSeverityAware(...args),
  deduplicateMessages: (...args) => messages.deduplicateMessages(...args),
  messageString: (...args) => messages.messageString(...args),
  messageStringMultiline: (...args) => messages.messageStringMultiline(...args),
  messageContext: (...args) => messages.messageContext(...args),
  explainMessage: (...args) => messages.explainMessage(...args),
  hasMessageExplanation: (...args) => messages.hasMessageExplanation(...args),
  get InvocationError() {
    Object.defineProperty(this, 'InvocationError', {
      value: compiler.InvocationError,
      writable: false,
      configurable: false,
      enumerable: false
    });
    return compiler.InvocationError;
  },
  hasErrors: (...args) => messages.hasErrors(...args),

  // additional API:
  parse: {
    cdl: (...args) => parseCdl(...args),
    cql: (...args) => parseCql(...args),
    expr: (...args) => parseExpr(...args)
  },
  // SNAPI
  for: {
    odata: (...args) => snapi.odata(...args)
  },
  to: {
    cdl: Object.assign((...args) => snapi.cdl(...args), {
      keywords: Object.freeze([ ...keywords.cdl ] ),
      functions: Object.freeze([ ...keywords.cdl_functions ] ),
      smartId: (...args) => toCdl.smartId(...args),
      smartFunctionId: (...args) => toCdl.smartFunctionId(...args),
      delimitedId: (...args) => toCdl.delimitedId(...args),
    }),
    sql: Object.assign((...args) => snapi.sql(...args), {
      migration: (...args) => snapi.sql.migration(...args),
      sqlite: {
        keywords: Object.freeze([ ...keywords.sqlite ] )
      },
      smartId: (...args) => sqlIdentifier.smartId(...args),
      smartFunctionId: (...args) => sqlIdentifier.smartFuncId(...args),
      delimitedId: (...args) => sqlIdentifier.delimitedId(...args),
    }),
    hdi: Object.assign((...args) => snapi.hdi(...args), {
      migration: (...args) => snapi.hdi.migration(...args),
      keywords: Object.freeze([ ...keywords.hana ] ),
    }),
    hdbcds: Object.assign((...args) => snapi.hdbcds(...args), {
      keywords: Object.freeze([ ...keywords.hdbcds ] ),
    }),
    edm: Object.assign((...args) => snapi.edm(...args), {
      all: (...args) => snapi.edm.all(...args)
    }),
    edmx: Object.assign((...args) => snapi.edmx(...args), {
      all: (...args) => snapi.edmx.all(...args)
    }),
  },
  // Convenience for hdbtabledata calculation in @sap/cds
  getArtifactCdsPersistenceName: (...args) => csnUtils.getArtifactDatabaseNameOf(...args),
  getElementCdsPersistenceName: (...args) => csnUtils.getElementDatabaseNameOf(...args),

  // Other API functions:
  traverseCsn: (...args) => model_api.traverseCsn(...args),

  // INTERNAL functions for the cds-lsp package and friends - before you use
  // it, you MUST talk with us - there can be potential incompatibilities with
  // new releases (even having the same major version):
  $lsp: {
    parse: (...args) => compiler.parseX(...args),
    compile: (...args) => compiler.compileX(...args),
    getArtifactName: (...args) => base.getArtifactName(...args),
  },

  // CSN Model related functionality
  model: {
    isInReservedNamespace: (...args) => builtins.isInReservedNamespace(...args),
  },
};

/**
 * Load the module on-demand and not immediately.
 *
 * @param {string} moduleName Name of the module to load - like with require
 * @returns {object} A Proxy that handles the on-demand loading
 */
function lazyload(moduleName) {
  let module;
  return new Proxy(((...args) => {
    if (!module) // eslint-disable-next-line global-require
      module = require(moduleName);

    if (module.apply && typeof module.apply === 'function')
      return module.apply(this, args);
    return module; // for destructured calls
  }), {
    get(target, name) {
      if (!module) // eslint-disable-next-line global-require
        module = require(moduleName);

      return module[name];
    },
  });
}
