'use strict';

const { makeMessageFunction } = require('../base/messages');
const {
  forEachDefinition,
  forEachMember,
  isPersistedAsTable,
  isPersistedAsView
} = require('../model/csnUtils');
const { isBetaEnabled } = require('../base/model');
// used to mark a view as changed so we know to drop-create it
const isChanged = Symbol('Marks a view as changed');

/**
 * Compares two models, in HANA-transformed CSN format, to each other.
 *
 * @param beforeModel the before-model
 * @param afterModel the after-model
 * @param {HdiOptions|false} options
 * @returns {ModelDiff} the sets of deletions, extensions, and migrations of entities necessary to transform the before-model
 * to the after-model, together with all the definitions of the after-model
 */
function compareModels(beforeModel, afterModel, options) {
  // @ts-ignore
  if(!(options && options.testMode)) // no $version with testMode
    validateCsnVersions(beforeModel, afterModel, options);

  const deletedEntities = Object.create(null);
  const elementAdditions = [];
  const migrations = []; // element changes/removals or changes of entity properties

  // There is currently no use in knowing the added entities only. If this changes, hand in `addedEntities` to `getArtifactComparator` below.
  forEachDefinition(afterModel, getArtifactComparator(beforeModel, options, null, null, elementAdditions, migrations));
  forEachDefinition(beforeModel, getArtifactComparator(afterModel, options, null, deletedEntities, null, null));

  const returnObj = Object.create(null);
  returnObj.definitions = afterModel.definitions;
  returnObj.deletions = deletedEntities;
  returnObj.extensions = elementAdditions;
  returnObj.migrations = migrations;
  return returnObj;
}

function validateCsnVersions(beforeModel, afterModel, options) {
  const beforeVersion = beforeModel.$version;
  const afterVersion = afterModel.$version;
  let beforeVersionParts = beforeVersion && beforeVersion.split('.');
  let afterVersionParts = afterVersion && afterVersion.split('.');

  if (!beforeVersionParts || beforeVersionParts.length < 2) {
    const { error, throwWithAnyError } = makeMessageFunction(beforeModel, options, 'modelCompare');
    error(null, null, { version: beforeVersion || 'undefined' }, 'Invalid CSN version: $(VERSION)');
    throwWithAnyError();
  }
  if (!afterVersionParts || afterVersionParts.length < 2) {
    const { error, throwWithAnyError } = makeMessageFunction(afterModel, options, 'modelCompare');
    error(null, null, { version: afterVersion || 'undefined' }, 'Invalid CSN version: $(VERSION)');
    throwWithAnyError();
  }
  if (beforeVersionParts[0] > afterVersionParts[0] && !(options && options.allowCsnDowngrade)) {
    const { error, throwWithAnyError } = makeMessageFunction(afterModel, options, 'modelCompare');
    error(null, null, { value: afterVersion, othervalue: beforeVersion, version: require('../../package.json').version },
      'Incompatible CSN versions: $(VALUE) is a major downgrade from $(OTHERVALUE). Is @sap/cds-compiler version $(VERSION) outdated?');
    throwWithAnyError();
  }
}

function getArtifactComparator(otherModel, options, addedEntities, deletedEntities, elementAdditions, migrations) {
  return function compareArtifacts(artifact, name) {
    function addElements() {
      const elements = {};
      forEachMember(artifact, getElementComparator(otherArtifact, elements), [ 'definitions', name ], true, { elementsOnly: true });
      if (Object.keys(elements).length > 0) {
        elementAdditions.push(addedElements(name, elements));
      }
    }
    function changePropsOrRemoveOrChangeElements() {
      const relevantProperties = [
        { name: 'doc' },
        { name: '@sql.prepend' },
        { name: '@sql.append' },
      ];
      const changedProperties = {};

      const removedElements = {};
      const changedElements = {};

      const migration = { migrate: name };

      relevantProperties.forEach(prop => {
        if (artifact[prop.name] !== otherArtifact[prop.name] && (!prop.beta || isBetaEnabled(options, prop.beta))) {
          changedProperties[prop.name] = changedElement(artifact[prop.name], otherArtifact[prop.name] || null);
        }
      });
      if (Object.keys(changedProperties).length > 0) {
        migration.properties = changedProperties;
      }

      forEachMember(otherArtifact, getElementComparator(artifact, removedElements), [ 'definitions', name ], true, { elementsOnly: true });
      if (Object.keys(removedElements).length > 0) {
        migration.remove = removedElements;
      }

      forEachMember(artifact, getElementComparator(otherArtifact, null, changedElements), [ 'definitions', name ], true, { elementsOnly: true });
      if (Object.keys(changedElements).length > 0) {
        migration.change = changedElements;
      }

      if (migration.properties || migration.remove || migration.change) {
        migrations.push(migration);
      }
    }

    const otherArtifact = otherModel.definitions[name];
    const isPersisted = isPersistedAsTable(artifact);
    const isPersistedOther = otherArtifact && isPersistedAsTable(otherArtifact);

    if (deletedEntities) {
      // Looking for deleted entities only.
      // Arguments are interchanged in this case: `artifact` from beforeModel and `otherArtifact` from afterModel.
      if (isPersisted && !isPersistedOther) {
        deletedEntities[name] = artifact;
      // eslint-disable-next-line sonarjs/no-duplicated-branches
      } else if(isPersistedAsView(artifact) && isPersistedOther) { // view turned into table - need to render a drop for the view
        deletedEntities[name] = artifact;
      }
      return;
    }

    // to make it easier to know which views to drop-create
    if(isPersistedAsView(artifact) && isPersistedAsView(otherArtifact)) {
      // TODO: Check only on artifact.query/projection BUT: Need to manually check for sql-snippets then!
      artifact[isChanged] = JSON.stringify(artifact) !== JSON.stringify(otherArtifact);
    }

    // Looking for added entities and added/deleted/changed elements.
    // Parameters: `artifact` from afterModel and `otherArtifact` from beforeModel.

    if (!isPersisted) {
      // Artifact not persisted in afterModel.
      return;
    }

    if (!isPersistedOther) {
      if (addedEntities) {
        addedEntities[name] = artifact;
      }
      return;
    }

    // Artifact changed?

    if (elementAdditions) {
      addElements();
    }
    if (migrations) {
      changePropsOrRemoveOrChangeElements();
    }
  };
}

function getElementComparator(otherArtifact, addedElementsDict = null, changedElementsDict = null) {
  return function compareElements(element, name) {
    if (element._ignore) {
      return;
    }

    const otherElement = otherArtifact.elements[name];
    if (otherElement && !otherElement._ignore) {
      // Element type changed?
      if (!changedElementsDict) {
        return;
      }
      if (relevantTypeChange(element.type, otherElement.type) || typeParametersChanged(element, otherElement)) {
        // Type or parameters, e.g. association target, changed.
        if(otherElement.notNull && element.notNull === undefined) {
          element.$notNull = false; // Explictily set notNull to the implicit default so we render the correct ALTER
        }
        changedElementsDict[name] = changedElement(element, otherElement);
      }

      return;
    }

    if (addedElementsDict) {
      addedElementsDict[name] = element;
    }
  }
}

function relevantTypeChange(type, otherType) {
  return otherType !== type && ![type, otherType].every(t => ['cds.Association', 'cds.Composition'].includes(t));
}

/**
 * Returns whether two things are deeply equal.
 * Function-type things are compared in terms of identity,
 * object-type things in terms of deep equality of all of their properties,
 * all other things in terms of strict equality (===).
 *
 * @param a {any} first thing
 * @param b {any} second thing
 * @param include {function} function of a key and a depth, returning true if and only if the given key at the given depth is to be included in comparison
 * @param depth {number} the current depth in property hierarchy below each of the original arguments (positive, counting from 0; don't set)
 * @returns {boolean}
 */
function deepEqual(a, b, include = () => true, depth = 0) {
  function isObject(x) {
    return x !== null && typeof x === 'object';
  }
  function samePropertyCount() {
    return Object.keys(a).length === Object.keys(b).length;
  }
  function allPropertiesEqual() {
    return Object.keys(a).reduce((prev, key) => prev && (!include(key, depth) || deepEqual(a[key], b[key], include, depth + 1)), true);
  }

  return isObject(a)
      ? isObject(b)
          ? samePropertyCount() && allPropertiesEqual()
          : false
      : a === b;
}

/**
 * Returns whether any type parameters differ between two given elements. Ignores whether types themselves differ (`type` property).
 * @param element {object} an element
 * @param otherElement {object} another element
 * @returns {boolean}
 */
function typeParametersChanged(element, otherElement) {
  return !deepEqual(element, otherElement, (key, depth) => !(depth === 0 && key === 'type'));
}

function addedElements(entity, elements) {
  return {
    extend: entity,
    elements
  };
}

function changedElement(element, otherElement) {
  return {
    old: otherElement,
    new: element
  };
}

module.exports = {
  compareModels,
  deepEqual,
  isChanged
};

/**
 * A ModelDiff encapsulates the changes between two models ("before" and "after"). It contains information
 * about changes to .elements and removed artifacts.
 *
 * @typedef {object} ModelDiff
 * @property {CSN.Definitions} definitions The artifacts present in the "after" model
 * @property {CSN.Definitions} deletions The artifacts present in the "before", but not in the "after"
 * @property {extension[]} extensions The elements added to artifacts
 * @property {migration[]} migrations Altered or removed elements
 */

/**
 * @typedef {object} extension
 * @property {CSN.Elements} elements The elements that where added
 * @property {string} extend Name of the artifact that the .elements need to be added to
 */

/**
 * @typedef {object} migration
 * @property {Object.<string, ChangeSet>} change An object of changes - the key being the name of the changed element, the value being the change.
 * @property {string} migrate Name of the artifact that the .change and .remove apply to
 * @property {CSN.Elements} remove An object of removed elements
 */

/**
 * @typedef {object} ChangeSet Describes the change of one element
 * @property {CSN.Element} old The old element definition
 * @property {CSN.Element} new The new element definition
 */
