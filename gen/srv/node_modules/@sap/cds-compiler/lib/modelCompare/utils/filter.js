'use strict';

// Each db has some changes that it can and cannot represent, or that cause problems only on that specific db
// In this file, we define rules for each db-dialect to detect and act on these cases.

const { forEach } = require('../../utils/objectUtils');
const { isPersistedAsTable } = require('../../model/csnUtils');

function isKey( element ) {
  return element.key;
}

module.exports = {
  sqlite: getFilterObject(
    'sqlite',
    function forEachExtension(extend, name, element, error) {
      if (isKey(element)) { // Key must not be extended
        error('type-unsupported-key-sqlite', [ 'definitions', extend, 'elements', name ], { id: name, name: 'sqlite' }, 'Added element $(ID) is a primary key change and will not work with dialect $(NAME)');
      }
    },
    function forEachMigration(migrate, name, migration, change, error) {
      const newIsKey = isKey(migration.new);
      const oldIsKey = isKey(migration.old);
      if ((newIsKey || oldIsKey) && oldIsKey !== newIsKey) { // Turned into key or key was removed
        error('type-unsupported-key-sqlite', [ 'definitions', migrate, 'elements', name ], { id: name, name: 'sqlite' }, 'Changed element $(ID) is a primary key change and will not work with dialect $(NAME)');
      }
      else { // Ignore simple migrations
        delete change[name];
      }
    }
  ),
  postgres: getFilterObject('postgres'),
  h2: getFilterObject('h2'),
  hana: getFilterObject('hana'),
};

function getFilterObject( dialect, extensionCallback, migrationCallback ) {
  return {
    // will be called with a simple Array.forEach
    extension: ({ elements, extend }, error) => {
      if (extensionCallback) {
        forEach(elements, (name, element) => {
          extensionCallback(extend, name, element, error);
        });
      }
    },
    // will be called with a Array.map, as we need to filter "change" for SQLite
    migration: ({ change, migrate, remove }, error) => {
      forEach(remove, (name) => {
        error('def-unsupported-element-drop', [ 'definitions', migrate, 'elements', name ], {}, 'Dropping elements is not supported');
      });

      forEach(change, (name, migration) => {
        const loc = [ 'definitions', migrate, 'elements', name ];
        if (migration.new.type === migration.old.type && migration.new.length < migration.old.length)
          error('type-unsupported-length-change', loc, { id: name }, 'Changed element $(ID) is a length reduction and is not supported');
        else if (migration.new.type === migration.old.type && migration.new.scale !== migration.old.scale)
          error('type-unsupported-scale-change', loc, { id: name }, 'Changed element $(ID) is a scale change and is not supported');
        else if (migration.new.type === migration.old.type && migration.new.precision !== migration.old.scale)
          error('type-unsupported-precision-change', loc, { id: name }, 'Changed element $(ID) is a precision change and is not supported');
        else if (migration.new.type !== migration.old.type && typeChangeIsNotCompatible(dialect, migration.old.type, migration.new.type))
          error('type-unsupported-change', loc, { id: name, name: migration.old.type, type: migration.new.type }, 'Changed element $(ID) is a lossy type change from $(NAME) to $(TYPE) and is not supported');
        else if (migrationCallback)
          migrationCallback(migrate, name, migration, change, error);

        // TODO: precision/scale growth
      });
    },
    deletion: ([ artifactName, artifact ], error) => {
      if (isPersistedAsTable(artifact))
        error('def-unsupported-table-drop', [ 'definitions', artifactName ], 'Dropping tables is not supported');
    },
  };
}

const defaultAllowedTypeChanges = {
  // Integer types
  'cds.hana.tinyint': [ 'cds.UInt8', 'cds.Int16', 'cds.Int32', 'cds.Integer', 'cds.Int64', 'cds.Integer64' ],
  'cds.UInt8': [ 'cds.hana.tinyint', 'cds.Int16', 'cds.Int32', 'cds.Integer', 'cds.Int64', 'cds.Integer64' ],
  'cds.Int16': [ 'cds.hana.smallint', 'cds.Int32', 'cds.Integer', 'cds.Int64', 'cds.Integer64' ],
  'cds.hana.smallint': [ 'cds.Int16', 'cds.Int32', 'cds.Integer', 'cds.Int64', 'cds.Integer64' ],
  'cds.Int32': [ 'cds.Integer', 'cds.Int64', 'cds.Integer64' ],
  'cds.Integer': [ 'cds.Int32', 'cds.Int64', 'cds.Integer64' ],
  'cds.Integer64': [ 'cds.Int64' ],
  'cds.Int64': [ 'cds.Integer64' ],
};

const allowedTypeChanges = {
  sqlite: defaultAllowedTypeChanges,
  postgres: defaultAllowedTypeChanges,
  h2: defaultAllowedTypeChanges,
};

function typeChangeIsNotCompatible( dialect, before, after ) {
  if (allowedTypeChanges[dialect]) {
    const map = allowedTypeChanges[dialect];
    return map[before] ? !map[before].includes(after) : true;
  }
  return true;
}
