/** @module API */

'use strict';

const prepareOptions = lazyload('./options');
const baseModel = lazyload('../base/model');
const location = lazyload('../base/location');
const messages = lazyload('../base/messages');
const compiler = lazyload('../compiler/index');
const toCsn = lazyload('../json/to-csn');
const forOdataNew = lazyload('../transform/forOdataNew.js');
const toSql = lazyload('../render/toSql');
const toCdl = require('../render/toCdl');
const modelCompare = lazyload('../modelCompare/compare');
const diffFilter = lazyload('../modelCompare/utils/filter');
const sortViews = lazyload('../model/sortViews');
const csnUtils = lazyload('../model/csnUtils');
const timetrace = lazyload('../utils/timetrace');
const forRelationalDB = lazyload('../transform/forRelationalDB');
const sqlUtils = lazyload('../render/utils/sql');

/**
 * Return the artifact name for use for the hdbresult object
 * So that it stays compatible with v1 .texts
 *
 * @param {string} artifactName Name to map
 * @param {CSN.Model} csn SQL transformed model
 * @returns {string} Name with . replaced as _ in some places
 */
function getFileName( artifactName, csn ) {
  return csnUtils.getResultingName(csn, 'quoted', artifactName);
}

const { toHdbcdsSource } = require('../render/toHdbcds');
const { ModelError } = require('../base/error');
const { forEach, forEachKey } = require('../utils/objectUtils');
const { checkRemovedDeprecatedFlags } = require('../base/model');
const { csn2edm, csn2edmAll } = require('../edm/csn2edm');

const relevantGeneralOptions = [ /* for future generic options */ ];
const relevantOdataOptions = [ 'sqlMapping', 'odataFormat' ];
const warnAboutMismatchOdata = [ 'odataVersion' ];

/**
 * Attach options and transformation name to the $meta tag
 *
 * @param {CSN.Model} csn CSN to attach to
 * @param {string} transformation Name of the transformation - odata or hana
 * @param {NestedOptions} options Options used for the transformation
 * @param {string[]} relevantOptionNames Option names that are defining characteristics
 * @param {string[]} [optionalOptionNames=[]] Option names that should be attached as a fyi
 */
function attachTransformerCharacteristics( csn, transformation, options,
                                           relevantOptionNames, optionalOptionNames = [] ) {
  const relevant = {};
  for (const name of relevantOptionNames ) {
    if (options[name] !== undefined)
      relevant[name] = options[name];
  }

  for (const name of optionalOptionNames ) {
    if (options[name] !== undefined)
      relevant[name] = options[name];
  }

  // eslint-disable-next-line sonarjs/no-empty-collection
  for (const name of relevantGeneralOptions ) {
    if (options[name] !== undefined)
      relevant[name] = options[name];
  }
  if (!csn.meta)
    baseModel.setProp(csn, 'meta', {});

  baseModel.setProp(csn.meta, 'options', relevant);
  baseModel.setProp(csn.meta, 'transformation', transformation);
}

/**
 * Check the characteristics of the provided, already transformed CSN
 * Report an error if they do not match with the currently requested options
 * V2 vs V4, plain vs hdbcds etc.
 *
 * @param {CSN.Model} csn CSN to check
 * @param {NestedOptions} options Options used for the transformation - scanned top-level
 * @param {string[]} relevantOptionNames Option names that are defining characteristics
 * @param {string[]} warnAboutMismatch Option names to warn about, but not error on
 * @param {string} module Name of the module that calls this function, e.g. `for.odata`
 */
function checkPreTransformedCsn( csn, options, relevantOptionNames, warnAboutMismatch, module ) {
  if (!csn.meta) {
    // Not able to check
    return;
  }
  const { error, warning, throwWithAnyError } = messages.makeMessageFunction(csn, options, module);

  for (const name of relevantOptionNames ) {
    if (options[name] !== csn.meta.options?.[name]) {
      error('wrong-pretransformed-csn', null, { prop: name, value: options[name], othervalue: csn.meta.options[name] },
            'Expected pre-processed CSN to have option $(PROP) set to $(VALUE). Found: $(OTHERVALUE)');
    }
  }

  for (const name of warnAboutMismatch ) {
    if (options[name] !== csn.meta.options[name]) {
      warning('options-mismatch-pretransformed-csn', null, { prop: name, value: options[name], othervalue: csn.meta.options[name] },
              'Expected pre-processed CSN to have option $(PROP) set to $(VALUE). Found: $(OTHERVALUE)');
    }
  }

  throwWithAnyError();
}

/**
 * Check if the CSN was already run through the appropriate transformer
 *
 * - Currently only check for odata, as hana is not exposed
 *
 * @param {CSN.Model} csn CSN
 * @param {string} transformation Name of the transformation
 * @returns {boolean} Return true if it is pre-transformed
 */
function isPreTransformed( csn, transformation ) {
  return csn && csn.meta && csn.meta.transformation === transformation;
}

/**
 * Get an odata-CSN without option handling.
 *
 * @param {CSN.Model} csn Clean input CSN
 * @param {object} internalOptions processed options
 * @returns {object} Return an oData-pre-processed CSN
 */
function odataInternal( csn, internalOptions ) {
  internalOptions.transformation = 'odata';
  const oDataCsn = forOdataNew.transform4odataWithCsn(csn, internalOptions);
  attachTransformerCharacteristics(oDataCsn, 'odata', internalOptions, relevantOdataOptions, warnAboutMismatchOdata);
  return oDataCsn;
}

/**
 * Return a odata-transformed CSN
 *
 * @param {CSN.Model} csn Clean input CSN
 * @param {ODataOptions} [options={}] Options
 * @returns {oDataCSN} Return an oData-pre-processed CSN
 */
function odata( csn, options = {} ) {
  traceApi("Options passed into 'for.odata'", options);
  const internalOptions = prepareOptions.for.odata(options);
  return odataInternal(csn, internalOptions);
}

/**
 * Process the given csn back to cdl.
 *
 * @param {object} csn CSN to process
 * @param {object} [options={}] Options
 * @returns {object} { model: string, namespace: string }
 */
function cdl( csn, options = {} ) {
  traceApi("Options passed into 'to.cdl'", options);
  const internalOptions = prepareOptions.to.cdl(options);
  return toCdl.csnToCdl(csn, internalOptions);
}

/**
 * Transform a CSN like to.sql
 *
 * @param {CSN.Model} csn Plain input CSN
 * @param {SqlOptions} [options={}] Options
 * @returns {CSN.Model} CSN transformed like to.sql
 * @private
 */
function forSql( csn, options = {} ) {
  const internalOptions = prepareOptions.to.sql(options);
  internalOptions.transformation = 'sql';
  const transformedCsn = forRelationalDB.transformForRelationalDBWithCsn(csn, internalOptions, 'to.sql');

  return internalOptions.testMode ? toCsn.sortCsn(transformedCsn, internalOptions) : transformedCsn;
}
/**
 * Transform a CSN like to.hdi
 *
 * @param {CSN.Model} csn Plain input CSN
 * @param {HdiOptions} [options={}] Options
 * @returns {CSN.Model} CSN transformed like to.hdi
 * @private
 */
function forHdi( csn, options = {} ) {
  const internalOptions = prepareOptions.to.hdi(options);
  internalOptions.transformation = 'sql';
  const transformedCsn = forRelationalDB.transformForRelationalDBWithCsn(csn, internalOptions, 'to.hdi');

  return internalOptions.testMode ? toCsn.sortCsn(transformedCsn, internalOptions) : transformedCsn;
}
/**
 * Transform a CSN like to.hdbcds
 *
 * @param {CSN.Model} csn Plain input CSN
 * @param {HdbcdsOptions} [options={}] Options
 * @returns {CSN.Model} CSN transformed like to.hdbcds
 * @private
 */
function forHdbcds( csn, options = {} ) {
  const internalOptions = prepareOptions.to.hdbcds(options);
  internalOptions.transformation = 'hdbcds';

  const hanaCsn = forRelationalDB.transformForRelationalDBWithCsn(csn, internalOptions, 'to.hdbcds');

  return internalOptions.testMode ? toCsn.sortCsn(hanaCsn, internalOptions) : hanaCsn;
}

/**
 * Process the given CSN into SQL.
 *
 * @param {CSN.Model} csn A clean input CSN
 * @param {SqlOptions} [options={}] Options
 * @returns {SQL[]} Array of SQL statements, tables first, views second
 */
function sql( csn, options = {} ) {
  traceApi("Options passed into 'to.sql'", options);
  const internalOptions = prepareOptions.to.sql(options);
  internalOptions.transformation = 'sql';

  // we need the CSN for view sorting
  const transformedCsn = forSql(csn, options);
  const sqls = toSql.toSqlDdl(transformedCsn, internalOptions);

  const result = sortViews({ csn: transformedCsn, sql: sqls.sql });

  return result.map(obj => obj.sql).filter(create => create);
}

/**
 * Process the given CSN into HDI artifacts.
 *
 * @param {CSN.Model} csn A clean input CSN
 * @param {HdiOptions} [options={}] Options
 * @returns {HDIArtifacts} { <filename>:<content>, ...}
 */
function hdi( csn, options = {} ) {
  traceApi("Options passed into 'to.hdi'", options);
  const internalOptions = prepareOptions.to.hdi(options);

  // we need the CSN for view sorting
  const sqlCSN = forHdi(csn, options);
  const sqls = toSql.toSqlDdl(sqlCSN, internalOptions);

  if (internalOptions.testMode) {
    // All this mapping is needed because sortViews crossmatches
    // passed in SQLs with the CSN artifact name
    // But we also need to return it with the correct file ending in the end
    // so remember and do lot's of mapping here.

    const flat = flattenResultStructure(sqls);

    const nameMapping = Object.create(null);
    const sqlArtifactsWithCSNNamesToSort = Object.create(null);
    const sqlArtifactsNotToSort = Object.create(null);

    forEach(flat, (key) => {
      const artifactNameLikeInCsn = key.replace(/\.[^/.]+$/, '');
      nameMapping[artifactNameLikeInCsn] = key;
      if (key.endsWith('.hdbtable') || key.endsWith('.hdbview'))
        sqlArtifactsWithCSNNamesToSort[artifactNameLikeInCsn] = flat[key];
      else
        sqlArtifactsNotToSort[key] = flat[key];
    });

    const sorted = sortViews({ sql: sqlArtifactsWithCSNNamesToSort, csn: sqlCSN })
      .filter(obj => obj.sql)
      .reduce((previous, current) => {
        const hdiArtifactName = remapName(nameMapping[current.name], sqlCSN, k => !k.endsWith('.hdbindex'));
        previous[hdiArtifactName] = current.sql;
        return previous;
      }, Object.create(null));

    // now add the not-sorted stuff, like indices
    forEach(sqlArtifactsNotToSort, (key) => {
      sorted[remapName(key, sqlCSN, k => !k.endsWith('.hdbindex'))] = sqlArtifactsNotToSort[key];
    });

    return sorted;
  }

  return remapNames(flattenResultStructure(sqls), sqlCSN, k => !k.endsWith('.hdbindex'));
}
/**
 * Remap names so that they stay consistent between v1 and v2
 *
 * Mainly important for _texts -> .texts
 *
 * @param {object} dict Result dictionary by toSql
 * @param {CSN.Model} csn SQL transformed CSN
 * @param {Function} filter Filter for keys not to remap
 * @returns {object} New result structure
 */
function remapNames( dict, csn, filter ) {
  const result = Object.create(null);

  forEach(dict, (key, value) => {
    const name = remapName(key, csn, filter);
    result[name] = value;
  });

  return result;
}
/**
 * Remap names so that it stays consistent between v1 and v2
 *
 * Mainly important for _texts -> .texts
 *
 * @param {string} key Filename
 * @param {CSN.Model} csn SQL transformed CSN
 * @param {Function} filter Filter for keys not to remap
 * @returns {string} Remapped filename
 */
function remapName( key, csn, filter = () => true ) {
  if (filter(key)) {
    const lastDot = key.lastIndexOf('.');
    const prefix = key.slice(0, lastDot);
    const suffix = key.slice(lastDot);

    const remappedName = getFileName(prefix, csn);
    return remappedName + suffix;
  }

  return key;
}

/**
 * Return all changes in artifacts between two given models.
 * Note: Only supports changes in artifacts compiled/rendered as db-CSN/SQL.
 *
 * @param {CSN.Model}  csn          A clean input CSN representing the desired "after-image"
 * @param {HdiOptions} options      Options
 * @param {CSN.Model}  beforeImage  A db-transformed CSN representing the "before-image", or null in case no such image
 *                                  is known, i.e. for the very first migration step.
 * @returns {object}                An object with three properties:
 *                                  - afterImage: A db-transformed CSN representing the "after-image"
 *                                  - drops: An array of SQL statements to drop views/tables
 *                                  - createsAndAlters: An array of SQL statements to ALTER/CREATE tables/views
 */
function sqlMigration( csn, options, beforeImage ) {
  traceApi("Options passed into 'to.sql.migration'", options);
  const internalOptions = prepareOptions.to.sql(options);
  const { error, throwWithError } = messages.makeMessageFunction(csn, internalOptions, 'to.sql.migration');

  // Prepare after-image.
  const afterImage = forSql(csn, internalOptions);
  // Compare both images.
  const diff = modelCompare.compareModels(beforeImage || afterImage, afterImage, internalOptions);
  const diffFilterObj = diffFilter[internalOptions.sqlDialect];

  if (diffFilterObj) {
    diff.extensions.forEach(ex => diffFilterObj.extension(ex, error));
    diff.migrations.forEach(migration => diffFilterObj.migration(migration, error));
    Object.entries(diff.deletions).forEach(entry => diffFilterObj.deletion(entry, error));
  }

  const identifierUtils = sqlUtils.getIdentifierUtils(csn, internalOptions);

  const drops = {
    creates: {},
    final: Object.entries(diff.deletions).reduce((previous, [ name, artifact ]) => {
      previous[name] = `DROP ${ (artifact.query || artifact.projection) ? 'VIEW' : 'TABLE' } ${ identifierUtils.renderArtifactName(name) };`;
      return previous;
    }, {}),
  };

  const cleanup = [];
  // Delete artifacts that are already present in csn
  if (beforeImage?.definitions) {
    Object.keys(beforeImage.definitions).forEach((artifactName) => {
      const beforeArtifact = beforeImage.definitions[artifactName];
      const diffArtifact = diff.definitions[artifactName];
      // TODO: exists, abstract? isPersistedOnDb?
      if (diffArtifact && diffArtifact['@cds.persistence.name'] && !diffArtifact['@cds.persistence.skip'] &&
        (diffArtifact.query || diffArtifact.projection) &&
        (diffArtifact[modelCompare.isChanged] === true || // we know it changed because we compared two views
          diffArtifact[modelCompare.isChanged] === undefined)) { // if it was removed in the after, then we don't have the flag
        drops.creates[artifactName] = `DROP VIEW ${ identifierUtils.renderArtifactName(artifactName) };`;
      } // TODO: What happens with a changed kind -> entity becomes a view?
      else if (diffArtifact &&
        diffArtifact['@cds.persistence.skip'] !== true &&
        diffArtifact.kind === beforeArtifact.kind && // detect action -> entity
        csnUtils.isPersistedAsView(diffArtifact) === csnUtils.isPersistedAsView(beforeArtifact) // detect view -> entity
      ) { // don't render again, but need info for primary key extension
        diffArtifact['@cds.persistence.skip'] = true;
        cleanup.push(() => delete diffArtifact['@cds.persistence.skip']);
      }
    });
  }

  // Convert the diff to SQL.
  if (!internalOptions.beta)
    internalOptions.beta = {};

  internalOptions.beta.sqlExtensions = true;

  // eslint-disable-next-line no-unused-vars
  const { deletions, migrations, ...hdbkinds } = toSql.toSqlDdl(diff, internalOptions);

  cleanup.forEach(fn => fn());
  // TODO: Handle `ADD CONSTRAINT` etc!
  const sortOrder = sortViews({ sql: {}, csn: afterImage });

  const dropSqls = [];
  const createAndAlterSqls = [];
  // Turn the structured result into just a flat dictionary of "artifact name": "sql"
  const flatSqlDict = Object.values(hdbkinds).reduce((prev, curr) => {
    forEach(curr, (name, value) => {
      prev[name] = value;
    });
    return prev;
  }, Object.create(null));

  // Sort all the SQL statements according to the overall order
  for (const { name } of sortOrder) {
    if (drops.final[name])
      dropSqls.push(drops.final[name]);
    else if (drops.creates[name])
      dropSqls.push(drops.creates[name]);

    // No else-if, since we have drop-creates for views!
    if (flatSqlDict[name])
      createAndAlterSqls.push(flatSqlDict[name]);
    else if (migrations[name])
      createAndAlterSqls.push(...migrations[name].map(m => m.sql));
  }

  // We need to drop the things without dependants first - so inversely sorted
  dropSqls.reverse();

  throwWithError();

  return {
    afterImage,
    drops: dropSqls,
    createsAndAlters: createAndAlterSqls,
  };
}

/**
 * Return all changes in artifacts between two given models.
 * Note: Only supports changes in entities (not views etc.) compiled/rendered as HANA-CSN/SQL.
 *
 * @param {CSN.Model}  csn          A clean input CSN representing the desired "after-image"
 * @param {HdiOptions} options      Options
 * @param {CSN.Model}  beforeImage  A HANA-transformed CSN representing the "before-image", or null in case no such image
 *                                  is known, i.e. for the very first migration step
 * @returns {migration} The migration result
 */
function hdiMigration( csn, options, beforeImage ) {
  traceApi("Options passed into 'to.hdi.migration'", options);
  const internalOptions = prepareOptions.to.hdi(options);

  // Prepare after-image.
  const afterImage = forHdi(csn, options);

  const diff = modelCompare.compareModels(beforeImage || afterImage, afterImage, internalOptions);

  // Convert the diff to SQL.
  if (!internalOptions.beta)
    internalOptions.beta = {};

  internalOptions.beta.sqlExtensions = true;

  const { deletions, migrations, ...hdbkinds } = toSql.toSqlDdl(diff, internalOptions);

  return {
    afterImage,
    definitions: createSqlDefinitions(hdbkinds, afterImage),
    deletions: createSqlDeletions(deletions, beforeImage),
    migrations: createSqlMigrations(migrations, afterImage),
  };
}

/**
 * From the given SQLs, create the correct result structure.
 *
 * @param {object} hdbkinds Object of hdbkinds (such as `hdbindex`) mapped to dictionary of artifacts.
 * @param {CSN.Model} afterImage CSN, used to create correct file names in result structure.
 * @returns {object[]} Array of objects, each having: name, suffix and sql
 */
function createSqlDefinitions( hdbkinds, afterImage ) {
  const result = [];
  forEach(hdbkinds, (kind, artifacts) => {
    const suffix = `.${ kind }`;
    forEach(artifacts, (name, sqlStatement) => {
      if ( kind !== 'hdbindex' )
        result.push({ name: getFileName(name, afterImage), suffix, sql: sqlStatement });
      else
        result.push({ name, suffix, sql: sqlStatement });
    });
  });
  return result;
}
/**
 * From the given deletions, create the correct result structure.
 *
 * @param {object} deletions Dictionary of deletions, only keys are used.
 * @param {CSN.Model} beforeImage CSN used to create correct file names in result structure.
 * @returns {object[]} Array of objects, each having: name and suffix - only .hdbtable as suffix for now
 */
function createSqlDeletions( deletions, beforeImage ) {
  const result = [];
  forEach(deletions, name => result.push({ name: getFileName(name, beforeImage), suffix: '.hdbtable' }));
  return result;
}
/**
 * From the given migrations, create the correct result structure.
 *
 * @param {object} migrations Dictionary of changesets (migrations).
 * @param {CSN.Model} afterImage CSN used to create correct file names in result structure.
 * @returns {object[]} Array of objects, each having: name, suffix and changeset.
 */
function createSqlMigrations( migrations, afterImage ) {
  const result = [];
  forEach(migrations, (name, changeset) => result.push({ name: getFileName(name, afterImage), suffix: '.hdbmigrationtable', changeset }));
  return result;
}

hdi.migration = hdiMigration;

sql.migration = sqlMigration;

/**
 * Process the given CSN into HDBCDS artifacts.
 *
 * @param {any} csn A clean input CSN
 * @param {HdbcdsOptions} [options={}] Options
 * @returns {HDBCDS} { <filename>:<content>, ...}
 */
function hdbcds( csn, options = {} ) {
  traceApi("Options passed into 'to.hdbcds'", options);
  const internalOptions = prepareOptions.to.hdbcds(options);
  internalOptions.transformation = 'hdbcds';

  const hanaCsn = forHdbcds(csn, internalOptions);

  const result = flattenResultStructure(toHdbcdsSource(hanaCsn, internalOptions));
  return result;
}
/**
 * Generate a edm document for the given service
 *
 * @param {CSN|oDataCSN} csn Clean input CSN or a pre-transformed CSN
 * @param {ODataOptions} [options={}] Options
 * @returns {edm} The JSON representation of the service
 */
function edm( csn, options = {} ) {
  traceApi("Options passed into 'to.edm'", options);
  // If not provided at all, set service to undefined to trigger validation
  const internalOptions = prepareOptions.to.edm(
    // eslint-disable-next-line comma-dangle
    options.service ? options : Object.assign({ service: undefined }, options)
  );

  const { service } = options;

  let servicesEdmj;
  if (isPreTransformed(csn, 'odata')) {
    checkPreTransformedCsn(csn, internalOptions, relevantOdataOptions, warnAboutMismatchOdata, 'for.odata');
    servicesEdmj = preparedCsnToEdm(csn, service, internalOptions);
  }
  else {
    const oDataCsn = odataInternal(csn, internalOptions);
    servicesEdmj = preparedCsnToEdm(oDataCsn, service, internalOptions);
  }
  return servicesEdmj.edmj;
}

edm.all = edmall;

/**
 * Generate edm documents for all services
 *
 * @param {CSN|oDataCSN} csn Clean input CSN or a pre-transformed CSN
 * @param {ODataOptions} [options={}] Options
 * @returns {edms} { <service>:<JSON representation>, ...}
 */
function edmall( csn, options = {} ) {
  traceApi("Options passed into 'to.edm.all'", options);
  const internalOptions = prepareOptions.to.edm(options);
  const { error } = messages.makeMessageFunction(csn, internalOptions, 'for.odata');

  if (internalOptions.odataVersion === 'v2')
    error(null, null, {}, 'OData JSON output is not available for OData V2');

  const result = {};
  let oDataCsn = csn;

  if (isPreTransformed(csn, 'odata'))
    checkPreTransformedCsn(csn, internalOptions, relevantOdataOptions, warnAboutMismatchOdata, 'for.odata');

  else
    oDataCsn = odataInternal(csn, internalOptions);

  const servicesJson = preparedCsnToEdmAll(oDataCsn, internalOptions);
  const services = servicesJson.edmj;
  for (const serviceName in services)
    result[serviceName] = services[serviceName];

  return result;
}
/**
 * Generate a edmx document for the given service
 *
 * @param {CSN|oDataCSN} csn Clean input CSN or a pre-transformed CSN
 * @param {ODataOptions} [options={}] Options
 * @returns {edmx} The XML representation of the service
 */
function edmx( csn, options = {} ) {
  traceApi("Options passed into 'to.edmx'", options);
  // If not provided at all, set service to undefined to trigger validation
  const internalOptions = prepareOptions.to.edmx(
    // eslint-disable-next-line comma-dangle
    options.service ? options : Object.assign({ service: undefined }, options)
  );

  const { service } = options;

  let services;
  if (isPreTransformed(csn, 'odata')) {
    checkPreTransformedCsn(csn, internalOptions, relevantOdataOptions, warnAboutMismatchOdata, 'for.odata');
    services = preparedCsnToEdmx(csn, service, internalOptions);
  }
  else {
    const oDataCsn = odataInternal(csn, internalOptions);
    services = preparedCsnToEdmx(oDataCsn, service, internalOptions);
  }

  return services.edmx;
}

edmx.all = edmxall;

/**
 * Generate edmx documents for all services
 *
 * @param {CSN|oDataCSN} csn Clean input CSN or a pre-transformed CSN
 * @param {ODataOptions} [options={}] Options
 * @returns {edmxs} { <service>:<XML representation>, ...}
 */
function edmxall( csn, options = {} ) {
  traceApi("Options passed into 'to.edmx.all'", options);
  const internalOptions = prepareOptions.to.edmx(options);

  const result = {};
  let oDataCsn = csn;

  if (isPreTransformed(csn, 'odata'))
    checkPreTransformedCsn(csn, internalOptions, relevantOdataOptions, warnAboutMismatchOdata, 'for.odata');

  else
    oDataCsn = odataInternal(csn, internalOptions);

  const servicesEdmx = preparedCsnToEdmxAll(oDataCsn, internalOptions);
  const services = servicesEdmx.edmx;
  // Create annotations and metadata once per service
  for (const serviceName in services) {
    const lEdm = services[serviceName];
    result[serviceName] = lEdm;
  }

  return result;
}

/**
 * Generate edmx for given 'service' based on 'csn' (new-style compact, already prepared for OData)
 * using 'options'
 *
 * @param {CSN.Model} csn Input CSN model. Must be OData transformed CSN.
 * @param {string} service Service name to use. If you want all services, use preparedCsnToEdmxAll()
 * @param {ODataOptions} options OData / EDMX specific options.
 * @returns {object} Rendered EDMX string for the given service.
 */
function preparedCsnToEdmx( csn, service, options ) {
  timetrace.timetrace.start('EDMX rendering');
  const e = csn2edm(csn, service, options)?.toXML('all');
  timetrace.timetrace.stop('EDMX rendering');
  return { edmx: e };
}

/**
 * Generate edmx for given 'service' based on 'csn' (new-style compact, already prepared for OData)
 * using 'options'.
 *
 * @param {CSN.Model} csn Input CSN model. Must be OData transformed CSN.
 * @param {ODataOptions} options OData / EDMX specific options.
 * @returns {object} Dictionary of rendered EDMX strings for each service.
 */
function preparedCsnToEdmxAll( csn, options ) {
  timetrace.timetrace.start('EDMX all rendering');
  const edmxResult = csn2edmAll(csn, options);
  for (const service in edmxResult)
    edmxResult[service] = edmxResult[service].toXML('all');
  timetrace.timetrace.stop('EDMX all rendering');
  return { edmx: edmxResult };
}

/**
 * Generate edm-json for given 'service' based on 'csn' (new-style compact, already prepared for OData)
 * using 'options'
 *
 * @param {CSN.Model} csn Input CSN model. Must be OData transformed CSN.
 * @param {string} service Service name for which EDMX should be rendered.
 * @param {ODataOptions} options OData / EDMX specific options.
 * @returns {object} Rendered EDM JSON object for of the given service.
 */
function preparedCsnToEdm( csn, service, options ) {
  timetrace.timetrace.start('EDM rendering');
  // Override OData version as edm json is always v4
  options.odataVersion = 'v4';
  const e = csn2edm(csn, service, options)?.toJSON();
  timetrace.timetrace.stop('EDM rendering');
  return { edmj: e };
}

/**
 * Generate edm-json for given 'service' based on 'csn' (new-style compact, already prepared for OData)
 * using 'options'
 *
 * @param {CSN.Model} csn Input CSN model. Must be OData transformed CSN.
 * @param {ODataOptions} options OData / EDMX specific options.
 * @returns {object} Dictionary of rendered EDM JSON objects for each service.
 */
function preparedCsnToEdmAll( csn, options ) {
  timetrace.timetrace.start('EDM all rendering');
  // Override OData version as edm json is always v4
  options.odataVersion = 'v4';
  const edmj = csn2edmAll(csn, options);
  for (const service in edmj)
    edmj[service] = edmj[service].toJSON();
  timetrace.timetrace.stop('EDM all rendering');
  return {
    edmj,
  };
}


/**
 * Flatten the result structure to a flat map.
 *
 * Don't loop over messages.
 *
 * @param {object} toProcess { <type>: { <name>:<content>, ...}, <type>: ...}
 * @returns {object} { <name.type>:<content> }
 */
function flattenResultStructure( toProcess ) {
  const result = {};
  forEach(toProcess, (fileType, artifacts) => {
    if (fileType === 'messages')
      return;
    forEach(artifacts, (filename) => {
      result[`${ filename }.${ fileType }`] = artifacts[filename];
    });
  });

  return result;
}

/**
 * Print args to stderr if CDSC_TRACE_API is set
 *
 * @param {...any} args to be logged to stderr
 */
function traceApi( ...args ) {
  if (process?.env?.CDSC_TRACE_API !== undefined) {
    for (const arg of args) {
      // eslint-disable-next-line no-console
      console.error( `${ typeof arg === 'object' ? JSON.stringify(arg, null, 2) : arg }`);
    }
  }
}

module.exports = {
  odata: publishCsnProcessor(odata, 'for.odata'),
  cdl: publishCsnProcessor(cdl, 'to.cdl'),
  sql: publishCsnProcessor(sql, 'to.sql'),
  hdi: publishCsnProcessor(hdi, 'to.hdi'),
  hdbcds: publishCsnProcessor(hdbcds, 'to.hdbcds'),
  edm: publishCsnProcessor(edm, 'to.edm'),
  edmx: publishCsnProcessor(edmx, 'to.edmx'),
  /** Internal only */
  for_sql: publishCsnProcessor(forSql, 'for.sql'),
  for_hdi: publishCsnProcessor(forHdi, 'for.hdi'),
  for_hdbcds: publishCsnProcessor(forHdbcds, 'for.hdbcds'),
  /** Deprecated, will be removed in cds-compiler@v4 */
  preparedCsnToEdmx,
  preparedCsnToEdm,
};


/**
 * @param {any} processor CSN processor
 * @param {string} _name Name of the processor
 * @returns {any} Function that calls the processor and recompiles in case of internal errors
 */
function publishCsnProcessor( processor, _name ) {
  api.internal = processor;

  if (processor.all)
    api.all = publishCsnProcessor(processor.all, `${ _name }.all`);

  if (processor.migration)
    api.migration = publishCsnProcessor(processor.migration, `${ _name }.migration`);

  return api;

  /**
   * Function that calls the processor and re-compiles in case of internal errors
   *
   * @param {CSN.Model} csn CSN
   * @param {CSN.Options} options Options
   * @param {any} args Any additional arguments
   * @returns {any} What ever the processor returns
   */
  function api( csn, options = {}, ...args ) {
    try {
      const messageFunctions = messages.makeMessageFunction(csn, options, 'api');
      if (options.deprecated)
        checkRemovedDeprecatedFlags( options, messageFunctions );

      checkOutdatedOptions( options, messageFunctions );
      checkCsnFlavor( csn, options, messageFunctions, _name );

      messageFunctions.throwWithError();

      timetrace.timetrace.start(_name);
      const result = processor( csn, options, ...args );
      timetrace.timetrace.stop(_name);
      return result;
    }
    catch (err) {
      timetrace.timetrace.reset('Exception in backend triggered');
      if (err instanceof messages.CompilationError || options.noRecompile || isPreTransformed(csn, 'odata')) // we cannot recompile a pre-transformed CSN
        throw err;

      if (options.testMode && !(err instanceof TypeError) &&
        !(err instanceof ModelError))
        throw err;

      const { info } = messages.makeMessageFunction( csn, options, 'compile' );
      const msg = info( 'api-recompiled-csn', location.emptyLocation('csn.json'), {}, 'CSN input had to be recompiled' );
      if (options.internalMsg)
        msg.error = err; // Attach original error

      // next line to be replaced by CSN parser call which reads the CSN object
      const xsn = compiler.recompileX(csn, options);
      const recompiledCsn = toCsn.compactModel(xsn);
      return processor( recompiledCsn, options, ...args );
    }
  }
}

// Note: No toCsn, because @sap/cds may still use it (2022-06-15)
const oldBackendOptionNames = [ 'toSql', 'toOdata', 'toHana', 'forHana' ];
/**
 * Checks if outdated options are used and if so, throw a compiler error.
 * These include:
 *  - magicVars (now variableReplacements)
 *  - toOdata/toSql/toHana/forHana -> now flat options
 *
 * @param {CSN.Options} options Backend options
 * @param {object} messageFunctions Functions returned by makeMessageFunction()
 */
function checkOutdatedOptions( options, messageFunctions ) {
  // This error has been emitted once, we don't need to emit it again.
  if (options.messages?.some(m => m.messageId === 'api-invalid-option' || m.messageId === 'api-invalid-variable-replacement'))
    return;


  for (const name of oldBackendOptionNames) {
    if (typeof options[name] === 'object') // may be a boolean due to internal options
      messageFunctions.error('api-invalid-option', null, { '#': 'deprecated', name });
  }

  if (options.magicVars)
    messageFunctions.error('api-invalid-option', null, { '#': 'magicVars', prop: 'magicVars', otherprop: 'variableReplacements' });

  // Don't check `options.magicVars`.  It's likely that the user renamed `magicVars` but
  // forgot about user -> $user and locale -> $user.locale
  if (options.variableReplacements?.user) {
    messageFunctions.error('api-invalid-variable-replacement', null, {
      '#': 'user', option: 'variableReplacements', prop: '$user', otherprop: 'user',
    });
  }
  if (options.variableReplacements?.locale) {
    messageFunctions.error('api-invalid-variable-replacement', null, {
      '#': 'locale', option: 'variableReplacements', prop: '$user.locale', otherprop: 'locale',
    });
  }

  forEachKey(options.variableReplacements || {}, (name) => {
    if (!name.startsWith('$') && name !== 'user' && name !== 'locale') {
      messageFunctions.error('api-invalid-variable-replacement', null, {
        '#': 'noDollar', option: 'variableReplacements', code: '$', name,
      });
    }
  });
}

/**
 * Checks that the given CSN is usable by our backends, e.g. that
 * the CSN is not a gensrc (a.k.a. xtended) for most backends.
 *
 * For reference, cds-compiler/cds-dk CSN flavor map:
 *  - client -> inferred
 *  - gensrc -> xtended
 *  - parseCdl -> parsed
 *
 * If this function becomes more complex (e.g. more module conditions),
 * move it from then generic api wrapper to the individual module.
 *
 * TODO: The compiler does not set any marker in `meta`; we use the umbrella one
 *       for easier debugging.
 *
 * @param {CSN.Model} csn User CSN
 * @param {CSN.Options} options User options
 * @param {object} messageFunctions Functions returned by makeMessageFunction()
 * @param {string} module Backend module, e.g. to.cdl or to.sql
 */
function checkCsnFlavor( csn, options, messageFunctions, module ) {
  if (module === 'to.cdl' || !csn)
    return; // to.cdl allows every CSN flavor

  if (csn.meta?.flavor === 'xtended') {
    // TODO: csn.meta?.flavor === 'parsed'; currently used by `@sap/cds` tests.
    messageFunctions.error('api-unsupported-csn-flavor', null, { name: module, option: csn.meta?.flavor },
                           'Module $(NAME) expects a client/inferred CSN, not $(OPTION)');
  }
}

/**
 * Load the module on-demand and not immediately.
 *
 * @param {string} moduleName Name of the module to load - like with require
 * @returns {object} A Proxy that handles the on-demand loading
 */
function lazyload( moduleName ) {
  let module;
  return new Proxy(((...args) => {
    if (!module) // eslint-disable-next-line global-require
      module = require(moduleName);

    if (module.apply && typeof module.apply === 'function')
      return module.apply(this, args);
    return module; // for destructured calls
  }), {
    get(target, name) {
      if (!module) // eslint-disable-next-line global-require
        module = require(moduleName);

      return module[name];
    },
  });
}


/**
 * Option format used by the old API, where they are grouped thematically.
 *
 * @typedef {object} NestedOptions
 */

/**
 * Option format used by the new API, where all options are top-level.
 *
 * @typedef {object} FlatOptions
 */

/**
 * Available SQL dialects
 *
 * @typedef {'hana' | 'sqlite' } SQLDialect
 */

/**
 * Available naming modes
 *
 * @typedef {'plain' | 'quoted' | 'hdbcds' } NamingMode
 */

/**
 * Available oData versions
 *
 * @typedef {'v2' | 'v4' } oDataVersion
 */

/**
 * Available oData versions
 *
 * @typedef { 'structured' | 'flat' } oDataFormat
 */

/**
 * A fresh (just compiled, not transformed) CSN
 *
 * @typedef {object} CSN
 */

/**
 * A CSN transformed for oData - can be rendered to edm or edmx
 *
 * @typedef {CSN.Model} oDataCSN
 */

/**
 * The CDL representation of a model
 *
 * @typedef {object} CDL
 */

/**
 * A map of { <file.hdbcds|hdbconstraint>:<content> }.
 *
 * @typedef {object} HDBCDS
 */

/**
 * A map of { <file.hdbtable|hdbview|hdbconstraint...>:<content> }.
 *
 * @typedef {object} HDIArtifacts
 */

/**
 * A SQL statement - CREATE TABLE, CREATE VIEW etc.
 *
 * @typedef {string} SQL
 */

/**
 * The XML document representing the service.
 *
 * @typedef {object} edmx
 */

/**
 * The JSON document representing the service.
 *
 * @typedef {object} edm
 */

/**
 * A map of { <serviceName>:<XML> }.
 *
 * @typedef {object} edmxs
 */

/**
 * A map of { <serviceName>:<JSON> }.
 *
 * @typedef {object} edms
 */

/**
 * - afterImage:  The desired after-image in db-CSN format
 * - definitions: An array of objects with all artifacts in the after-image. Each object specifies
 *                the artifact filename, the suffix, and the corresponding SQL statement to create
 *                the artifact.
 * - deletions:   An array of objects with the deleted artifacts. Each object specifies the artifact
 *                filename and the suffix.
 * - migrations:  An array of objects with the changed (migrated) artifacts. Each object specifies the
 *                artifact filename, the suffix, and the changeset (an array of changes, each specifying
 *                whether it incurs potential data loss, and its respective SQL statement(s), with
 *                multiple statements concatenated as a multi-line string in case the change e.g.
 *                consists of a column drop and add).
 *
 * @typedef {object} migration
 */
