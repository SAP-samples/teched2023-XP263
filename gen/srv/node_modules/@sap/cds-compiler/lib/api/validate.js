'use strict';

const { makeMessageFunction } = require('../base/messages');
const { forEach } = require('../utils/objectUtils');

/* eslint-disable arrow-body-style */
const booleanValidator = {
  validate: val => val === true || val === false,
  expected: () => 'type boolean',
  found: val => `type ${ typeof val }`,
};

/**
 * Validation function. Returns false if invalid.
 *
 * @typedef {(input: any) => boolean} ValidateFunction
 */

/**
 * @typedef {object} Validator
 * @property {ValidateFunction} validate Run the validation check
 * @property {Function} expected Returns the expected type/value as a string.
 * @property {Function} found Returns the actually found type/value as a string.
 */

/**
 * Generate a Validator that validates that the
 * input is a string and one of the available options.
 * The validation of the option values is case-insensitive.
 *
 * @param {any} availableValues Available values
 * @returns {Validator} Return a validator for a string in an expected range
 */
function generateStringValidator( availableValues ) {
  return {
    validate: val => typeof val === 'string' && availableValues.some( av => av.toLowerCase() === val.toLowerCase() ),
    expected: (val) => {
      return typeof val !== 'string' ? 'type string' : availableValues.join(', ');
    },
    found: (val) => {
      return typeof val !== 'string' ? `type ${ typeof val }` : `value ${ val }`;
    },
  };
}

const validators = {
  beta: {
    validate: val => val !== null && typeof val === 'object' && !Array.isArray(val),
    expected: () => 'type object',
    found: (val) => {
      return val === null ? val : `type ${ typeof val }`;
    },
  },
  deprecated: {
    validate: val => val !== null && typeof val === 'object' && !Array.isArray(val),
    expected: () => 'type object',
    found: (val) => {
      return val === null ? val : `type ${ typeof val }`;
    },
  },
  severities: {
    validate: val => val !== null && typeof val === 'object' && !Array.isArray(val),
    expected: () => 'type object',
    found: (val) => {
      return val === null ? val : `type ${ typeof val }`;
    },
  },
  // TODO: Maybe do a deep validation of the whole object with leafs?
  variableReplacements: {
    validate: val => val !== null && typeof val === 'object' && !Array.isArray(val),
    expected: () => 'type object',
    found: (val) => {
      return val === null ? val : `type ${ typeof val }`;
    },
  },
  messages: {
    validate: val => Array.isArray(val),
    expected: () => 'type array',
    found: val => `type ${ typeof val }`,
  },
  sqlDialect: generateStringValidator([ 'sqlite', 'hana', 'plain', 'postgres', 'h2' ]),
  sqlMapping: generateStringValidator([ 'plain', 'quoted', 'hdbcds' ]),
  odataVersion: generateStringValidator([ 'v2', 'v4' ]),
  odataFormat: generateStringValidator([ 'flat', 'structured' ]),
  odataVocabularies: {
    validate: val => (typeof val === 'object' && !Array.isArray(val)),
    expected: () => 'type JSON object',
    found: val => `type ${ Array.isArray(val) ? 'JSON array' : typeof val }`,
  },
  service: {
    validate: val => typeof val === 'string',
    expected: () => 'type string',
    found: val => `type ${ typeof val }`,
  },
  serviceNames: {
    validate: val => Array.isArray(val) && !val.some(y => (typeof y !== 'string')),
    expected: () => 'type array of string',
    found: val => `type ${ typeof val }`,
  },
  defaultBinaryLength: {
    validate: val => !Number.isNaN(Number(val)) && Number.isInteger(Number.parseFloat(val)),

    expected: () => 'Integer literal',
    found: val => `${ (!Number.isNaN(Number(val)) ? val : 'Not a Number') }`,
  },
  defaultStringLength: {
    validate: val => !Number.isNaN(Number(val)) && Number.isInteger(Number.parseFloat(val)),

    expected: () => 'Integer literal',
    found: val => `${ (!Number.isNaN(Number(val)) ? val : 'Not a Number') }`,
  },
  csnFlavor: {
    validate: val => typeof val === 'string',
    expected: () => 'type string',
    found: val => `type ${ typeof val }`,
  },
  testMode: {
    validate: val => typeof val === 'boolean' || typeof val === 'number',
    expected: () => 'type boolean|number',
    found: val => `type ${ typeof val }`,
  },
  dictionaryPrototype: {
    validate: () => true,
  },
  assertIntegrity: {
    validate: val => typeof val === 'string' && val === 'individual' || typeof val === 'boolean',
    expected: () => 'a boolean or a string with value \'individual\'',
    found: val => (typeof val === 'string' ? val : `type ${ typeof val }`),
  },
  assertIntegrityType: generateStringValidator([ 'DB', 'RT' ]),
};

const allCombinationValidators = {
  'valid-structured': {
    validate: options => options.odataVersion === 'v2' && options.odataFormat === 'structured',
    severity: 'error',
    getParameters: () => {},
    getMessage: () => 'Structured OData is only supported with OData version v4',
  },
  'sql-dialect-and-naming': {
    validate: options => options.sqlDialect && options.sqlMapping && ![ 'hana' ].includes(options.sqlDialect) && [ 'quoted', 'hdbcds' ].includes(options.sqlMapping),
    severity: 'error',
    getParameters: options => ({ name: options.sqlDialect, prop: options.sqlMapping }),
    getMessage: () => 'sqlDialect $(NAME) can\'t be combined with sqlMapping $(PROP)',
  },
  'beta-no-test': {
    validate: options => options.beta && !options.testMode,
    severity: 'warning',
    getParameters: () => {},
    getMessage: () => 'Option "beta" was used. This option should not be used in productive scenarios!',
  },
};
/* eslint-disable jsdoc/no-undefined-types */
/**
 * Run the validations for each option.
 * Use a custom validator or "default" custom validator, fallback to Boolean validator.
 *
 * @param {object} options Flat options object to validate
 * @param {string} moduleName The called module, e.g. 'for.odata', 'to.hdi'. Needed to initialize the message functions
 * @param {object} [customValidators] Map of custom validators to use
 * @param {string[]} [combinationValidators] Validate option combinations
 * @returns {void}
 * @throws {CompilationError} Throws in case of invalid option usage
 */
function validate( options, moduleName, customValidators = {}, combinationValidators = [] ) {
  // TODO: issuing messages in this function looks very strange...
  {
    const messageCollector = { messages: [] };
    const { error, throwWithAnyError } = makeMessageFunction(null, messageCollector, moduleName);

    forEach(options, (optionName, optionValue) => {
      const validator = customValidators[optionName] || validators[optionName] || booleanValidator;

      if (!validator.validate(optionValue)) {
        error('invalid-option', null, {
          prop: optionName,
          value: validator.expected(optionValue),
          othervalue: validator.found(optionValue),
        }, 'Expected option $(PROP) to have $(VALUE). Found: $(OTHERVALUE)');
      }
    });
    throwWithAnyError();
  }

  const message = makeMessageFunction(null, options, moduleName);

  for (const combinationValidatorName of combinationValidators.concat([ 'beta-no-test' ])) {
    const combinationValidator = allCombinationValidators[combinationValidatorName];
    if (combinationValidator.validate(options))
      message[combinationValidator.severity]('invalid-option-combination', null, combinationValidator.getParameters(options), combinationValidator.getMessage(options));
  }

  message.throwWithAnyError();
}
/* eslint-enable jsdoc/no-undefined-types */


module.exports = { validate, generateStringValidator };
/* eslint-enable arrow-body-style */
