'use strict';
const util = require('util');

const debug = require('debug');
const debugTrace = debug('xssec:validators');
debugTrace.log = console.log.bind(console);
const debugError = debug('xssec:validators');
debugError.log = console.error.bind(console);

const jwt = require('jsonwebtoken');
const url = require('url');

const TokenInfo = require('./tokeninfo');
const TokenExchanger = require('./tokenexchanger');
const JwksManager = require('./jwks/JwksManager');
const JwksReplica = require('./jwks/JwksReplica');
let jwksManager;

const DOT = ".";
const ValidationResults = new function () {
    function Result(suc, desc) {
        var state = suc;
        var description = desc || "";

        this.isValid = function () {
            return suc === true;
        }

        this.isErroneous = function () {
            return suc === false;
        }

        this.getErrorDescription = function () {
            return description;
        }
    };

    this.createValid = function () {
        return new Result(true);
    }

    this.createInvalid = function (description) {
        return new Result(false, description)
    }
};

function JwtAudienceValidator(clientId) {
    var clientIds = [];
    var foreignMode = false;

    this.configureTrustedClientId = function (clientId) {
        if (clientId) {
            clientIds.push(clientId);
        }

        debugTrace("configured JwtAudienceValidator with clientId", clientId);
        return this;
    }

    this.validateToken = function (audiencesFromToken, scopesFromToken, cid) {
        foreignMode = false;
        var allowedAudiences = extractAudiencesFromToken(audiencesFromToken, scopesFromToken || [], cid);
        if (validateSameClientId(cid) === true || validateAudienceOfXsuaaBrokerClone(allowedAudiences) === true || validateDefault(allowedAudiences) === true) {
            return ValidationResults.createValid();
        }

        return ValidationResults.createInvalid("Jwt token with audience: " + util.inspect(allowedAudiences) + " is not issued for these clientIds: " + util.inspect(clientIds) + ".");
    }

    this.isForeignMode = function () {
        return foreignMode;
    }

    function validateSameClientId(cidFromToken) {
        if (!cidFromToken || !clientId) {
            return false;
        }

        return cidFromToken.trim() === clientId.trim();
    }    

    //iterate over all configured clientIds and return true of the cb returns true
    function forEachClientId(cb) {
        for (var i = 0; i < clientIds.length; ++i) {
            if (cb(clientIds[i]) === true) {
                return true;
            }
        }

        return null;
    }

    function validateDefault(allowedAudiences) {
        return forEachClientId(function (configuredClientId) {
            if (allowedAudiences.includes(configuredClientId)) {
                return true;
            }
        });
    }

    function validateAudienceOfXsuaaBrokerClone(allowedAudiences) {
        var ret = forEachClientId(function (configuredClientId) {
            if (configuredClientId.includes("!b")) { //isBrokerClientId
                for (var i = 0; i < allowedAudiences.length; ++i) {
                    var audience = allowedAudiences[i];
                    if (audience.endsWith("|" + configuredClientId)) {
                        return true;
                    }
                }
            }
        });

        if (ret === null) {
            foreignMode = true;
        }
        return ret;
    }

    this.getListOfAudiencesFromToken = function (aud, scopes, cid) {
        return extractAudiencesFromToken(aud || [], scopes || [], cid);
    }

    function extractAudiencesFromToken(aud, scopes, cid) {
        var audiences = [];
        var tokenAudiences = aud || [];

        for (var i = 0; i < tokenAudiences.length; ++i) {
            var audience = tokenAudiences[i];
            if (audience.indexOf(DOT) > -1) {
                // CF UAA derives the audiences from the scopes.
                // In case the scopes contains namespaces, these needs to be removed.
                var aud = audience.substring(0, audience.indexOf(DOT)).trim();
                if (aud && !audiences.includes(aud)) {
                    audiences.push(aud);
                }
            } else {
                audiences.push(audience);
            }
        }

        if (audiences.length == 0) {
            for (var i = 0; i < scopes.length; ++i) {
                var scope = scopes[i];
                if (scope.indexOf(DOT) > -1) {
                    var aud = scope.substring(0, scope.indexOf(DOT)).trim();
                    if (aud && !audiences.includes(aud)) {
                        audiences.push(aud);
                    }
                }
            }
        }

        if (cid && audiences.indexOf(cid) === -1) {
            audiences.push(cid);
        }

        return audiences;
    }

    //allow an empty constructor
    if (clientId) {
        this.configureTrustedClientId(clientId);
    }
};

function buildJwksManager(config) {
    if(!config) {
        return new JwksManager();
    }

    let jwksExpirationTime = config.expirationTime || JwksReplica.DEFAULT_EXPIRATION_TIME;
    let jwksRefreshPeriod = config.refreshPeriod || JwksReplica.DEFAULT_REFRESH_PERIOD;

    return new JwksManager().withExpirationTime(jwksExpirationTime).withRefreshPeriod(jwksRefreshPeriod);
}

function JwtTokenValidatorIAS(configArray, serviceCredentials) {
    if(!jwksManager) {
        jwksManager = buildJwksManager(serviceCredentials.jwksCache);      
    }      

    this.isForeignMode = function () {
        return false;
    }

    function checkIssuer(issuer, domains) {
        if(!issuer) {
            throw "issuer is empty";
        }

        //make sure we have a protocol at the beginning of the url
        if(issuer.indexOf('http') !== 0) {
            issuer = "https://" + issuer;
        }
    
        const myURL = new url.URL(issuer);
    
        if(myURL.protocol !== 'https:') {
            if(myURL.hostname !== 'localhost') {
                throw "Issuer has wrong protocol (" + myURL.protocol + ")";
            }            
        }
    
        if(myURL.hash) {
            throw "Issuer has unallowed hash value (" + myURL.hash + ")";
        }
    
        if(myURL.search) {
            throw "Issuer has unallowed query value (" + myURL.search + ")";
        }
    
        for(let i=0;i<domains.length;++i) {
            if(myURL.hostname.endsWith(domains[i])) {
                return;
            }
        }
    
        throw "Issuer not found in domain list " + domains;
    }

    this.validateToken = function (accessToken, cb) {
        function returnError(code, errorString) {
            debugError('\n' + errorString);
            var error = new Error(errorString);
            error.statuscode = code;
            return cb(error);
        }

        //make sure we have at least an array of 1 domain
        const domains = Array.isArray(serviceCredentials.domains) ? serviceCredentials.domains : [serviceCredentials.domain];
        const token = new TokenInfo(accessToken);

        //Issuer validation
        const issuer = token.getIssuer();
        try {
            checkIssuer(issuer, domains)
        } catch(e) {
            return returnError(401, "Issuer validation failed (iss=" + issuer + ") message=" + e);
        }

        const verificationKeySupplier = async (header, callback) => {
            let err, jwk;
            try {
                const jwks = await jwksManager.getIdentityJwks(issuer, token.getZoneId());
                jwk = await jwks.get(header.kid);
            } catch(e) {
                err = e;
            }

            callback(err, jwk ? jwk.value : null);
        }

        return token.verify(verificationKeySupplier, function(err, token) {
            if (err) {
                debugError('\n' + err.message);
                err.statuscode = 401;
                return cb(err);
            }            

            //Audience validation
            let audienceValidator = new JwtAudienceValidator(serviceCredentials.clientid);
            for (var i = 1; i < configArray.length; ++i) {
                if (configArray[i] && configArray[i].clientid) {
                    audienceValidator.configureTrustedClientId(configArray[i].clientid);
                }
            }

            let valid_result = audienceValidator.validateToken(token.getAudiencesArray());
            if (!valid_result.isValid()) {
                return returnError(401, valid_result.getErrorDescription());
            }
            
            cb(null, token);
        });
    }
}

function validateJku(jkuUrl, uaaDomain) {
    if (!uaaDomain) {
        throw new Error("JKU could not be validated because attribute \'uaadomain\' is missing from service credentials.");
    }

    var tokenKeyUrl = url.parse(jkuUrl);
    if (tokenKeyUrl.hostname.substring(tokenKeyUrl.hostname.indexOf(uaaDomain), tokenKeyUrl.hostname.length) !== uaaDomain) {
        throw new Error(`JKU of JWT token (${jkuUrl}) does not match UAA domain (${uaaDomain}).`);
    }
}

function JwtTokenValidatorXSUAA(configArray, serviceCredentials) {
    if(!jwksManager) {
        jwksManager = buildJwksManager(serviceCredentials.jwksCache);      
    } 
    var foreignMode = false;

    this.isForeignMode = function () {
        return foreignMode;
    }

    //prepare JWT validators
    this.validateToken = function (accessToken, cb) {
        function returnError(code, errorString) {
            debugError('\n' + errorString);
            var error = new Error(errorString);
            error.statuscode = code;
            return cb(error);
        }

        let tokeninfo = new TokenExchanger(serviceCredentials);

        return tokeninfo.prepareToken(accessToken,
            function (err, token) {
                if (err) {
                    debugError('\n' + err.message);
                    err.statuscode = 401;
                    return cb(err);
                }

                const verificationKeySupplier = async (header, callback) => {
                    let keyFromConfig = serviceCredentials.verificationkey;

                    if(!header.jku || !header.kid || header.kid == 'legacy-token-key') {
                        debugTrace("Token header contained no JKU or KID or the KID was 'legacy-token-key'. Using verification key from service configuration.");
                        return callback(null, keyFromConfig);
                    }

                    try {
                        validateJku(header.jku, serviceCredentials.uaadomain);
                    } catch(e) {
                        debugTrace("Using verification key from service configuration because JKU validation failed.", e.toString());
                        return callback(null, keyFromConfig);
                    }

                    let err, jwk;
                    try {
                        const jwks = jwksManager.getXsuaaJwks(header.jku, token.getZoneId());
                        jwk = await jwks.get(header.kid);   
                    } catch(e) {
                        err = e;
                    }                    

                    return callback(err, jwk ? jwk.value : null);
                }

                return token.verify(verificationKeySupplier,
                    function (err, token) {                        
                         if (err) {
                            debugError(err.statuscode);
                            debugError(err.message);
                            debugError(err.stack);
                            return cb(err, token);
                        }

                        var decodedToken = token.getPayload();

                        if (!token.getClientId()) {
                            return returnError(400, 'Client Id not contained in access token. Giving up!');
                        }

                        if (!decodedToken.zid) {
                            return returnError(400, 'Identity Zone not contained in access token. Giving up!');
                        }

                        var audienceValidator = new JwtAudienceValidator(configArray[0].clientid);
                        if (configArray[0].xsappname) {
                            audienceValidator.configureTrustedClientId(configArray[0].xsappname);
                        }

                        for (var i = 1; i < configArray.length; ++i) {
                            if (configArray[i]) {
                                if (configArray[i].clientid) {
                                    audienceValidator.configureTrustedClientId(configArray[i].clientid);
                                }
                                if (configArray[i].xsappname) {
                                    audienceValidator.configureTrustedClientId(configArray[i].xsappname);
                                }
                            }
                        }

                        var valid_result = audienceValidator.validateToken(token.getAudiencesArray(), decodedToken.scope, decodedToken.cid);
                        if (!valid_result.isValid()) {
                            return returnError(401, valid_result.getErrorDescription());
                        }

                        if (configArray[0].clientid !== decodedToken.cid) {
                            foreignMode = audienceValidator.isForeignMode();
                        }

                        cb(null, token);
                    }
                );
            })
    };
};

function JwtTokenValidatorUAA(configArray, serviceCredentials) {
    if(!jwksManager) {
        jwksManager = buildJwksManager(serviceCredentials.jwksCache);      
    } 
    var foreignMode = false;

    this.isForeignMode = function () {
        return foreignMode;
    }

    //prepare JWT validators
    this.validateToken = function (accessToken, cb) {
        function returnError(code, errorString) {
            debugError('\n' + errorString);
            var error = new Error(errorString);
            error.statuscode = code;
            return cb(error);
        }

        let tokeninfo = new TokenExchanger(serviceCredentials, true);

        return tokeninfo.prepareToken(accessToken,
            function (err, token) {
                if (err) {
                    debugError('\n' + err.message);
                    err.statuscode = 401;
                    return cb(err);
                }

                const verificationKeySupplier = async (header, callback) => {
                    let keyFromConfig = serviceCredentials.verificationkey;

                    if(!header.jku || !header.kid || header.kid == 'legacy-token-key') {
                        debugTrace("Token header contained no JKU or KID or the KID was 'legacy-token-key'. Using verification key from service configuration.");
                        return callback(null, keyFromConfig);
                    }

                    try {
                        validateJku(header.jku, serviceCredentials.uaadomain);
                    } catch(e) {
                        debugTrace("Using verification key from service configuration because JKU validation failed.", e.toString());
                        return callback(null, keyFromConfig);
                    }

                    let err, jwk;
                    try {
                        const jwks = jwksManager.getXsuaaJwks(header.jku, token.getZoneId());
                        jwk = await jwks.get(header.kid);   
                    } catch(e) {
                        err = e;
                    }                    

                    return callback(err, jwk ? jwk.value : null);
                }

                return token.verify(verificationKeySupplier,
                    function (err, token) {                        
                        if (err) {
                            debugError(err.statuscode);
                            debugError(err.message);
                            debugError(err.stack);
                            return cb(err, token);
                        }

                        var decodedToken = token.getPayload();

                        if (!token.getClientId()) {
                            return returnError(400, 'Client Id not contained in access token. Giving up!');
                        }

                        if (!decodedToken.zid) {
                            return returnError(400, 'Identity Zone not contained in access token. Giving up!');
                        }

                        var audienceValidator = new JwtAudienceValidator(configArray[0].clientid);
                        if (configArray[0].xsappname) {
                            audienceValidator.configureTrustedClientId(configArray[0].xsappname);
                        }

                        for (var i = 1; i < configArray.length; ++i) {
                            if (configArray[i]) {
                                if (configArray[i].clientid) {
                                    audienceValidator.configureTrustedClientId(configArray[i].clientid);
                                }
                                if (configArray[i].xsappname) {
                                    audienceValidator.configureTrustedClientId(configArray[i].xsappname);
                                }
                            }
                        }

                        var valid_result = audienceValidator.validateToken(token.getAudiencesArray(), decodedToken.scope, decodedToken.cid);
                        if (!valid_result.isValid()) {
                            return returnError(401, valid_result.getErrorDescription());
                        }

                        if (configArray[0].clientid !== decodedToken.cid) {
                            foreignMode = audienceValidator.isForeignMode();
                        }

                        cb(null, token);
                    }
                );
            })
    };
};

module.exports = {
    JwtTokenValidatorIAS: JwtTokenValidatorIAS,
    JwtTokenValidatorUAA: JwtTokenValidatorUAA,
    JwtTokenValidatorXSUAA: JwtTokenValidatorXSUAA,
    JwtAudienceValidator: JwtAudienceValidator
};