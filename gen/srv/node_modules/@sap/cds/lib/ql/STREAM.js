const Whereable = require('./Whereable'), { parse } = Whereable

module.exports = class Query extends Whereable {

  static _api() {
    const $ = Object.assign
    return $((..._)  => new this()._column_or_data_or_from(..._), {
      into: (..._)   => new this().into(..._),
      from: (..._)   => new this().from(..._),
      column: (..._) => new this().column(..._),
      columns: (..._) => new this().columns(..._),
    })
  }

  _column_or_data_or_from (col, ...more) { // srv.read`title`.from`Books` or srv.read`Books` ?
    if (!col) return this
    else if (col.name) return this.from (...arguments) //> clearly a from
    else if (col.raw) { // tagged template string
      if (col[0].startsWith('from ')) { // STREAM`from ...`, with an arbitrary long CQL tail...
        Object.assign (this.STREAM, STREAM_(' ',arguments))
        return this
      } else if (col[0][0] === '{') {  // STREAM`{a,b}`... -> it's column
        let {column:c} = STREAM_('from X', arguments)
        return this._add('column',c)
      } else {                          // STREAM`Foo` -> ambiguous -> try parsing as column...
        let {column:c} = STREAM_('from X {', arguments, '}')
        if (c.length > 1 || !c[0].ref) return this._add('column',c)
        // else cols = c[0] //> goes on below...
      }
    } else { // STREAM('foo')
      if (Array.isArray(col)) return this.columns(col)
      if (typeof col === 'string') return this.column(col)
      else return this.data(col)
    }

    // return a proxy assuming it's a from and switching to
    // column on a subsequent call of .from, if any.
    const {STREAM:_} = this
    return Object.defineProperties (this.from (col, ...more), {
      from: { configurable:true, value:(...args) => { delete this.from
        return this.from (...args) .column (col, ...more)
      }}
    })
  }

  column (col) {
    this._add ('column',col)
    return this
  }

  columns (cols) {
    this._add ('columns',cols)
    return this
  }

  from (target, key, column) {
    this.STREAM.from = this._target_ref4 (...arguments)
    if (!target.raw && key) {
      this.byKey(key)
      if (typeof column === 'function') {
        const cols=[]; column (new Proxy (column,{ get: (_,p) => cols.push(p) }))
        cols.length === 1 ? this.column(cols[0]) : this.columns(cols)
      }
      else if (column) this.column(column)
    }
    return this
  }

  into (target, key) {
    this.STREAM.into = this._target_ref4 (...arguments)
    if (!target.raw && key) {
      this.byKey(key)
    }
    return this
  }

  data (x) {
    this.STREAM.data = x
    return this
  }
}


const {CQL} = parse, STREAM_ = (prefix, [ strings, ...more ], suffix) => {
  const tts = [...strings]; tts.raw = true
  if (prefix) tts[0] = `STREAM ${prefix} ${tts[0]}`
  if (suffix) tts[tts.length-1] += ` ${suffix}`
  return CQL(tts,...more).STREAM
}
