const { AsyncResource } = require('async_hooks')
const cds = require('../index')

class Query {

  constructor(_={}) { this[this.cmd] = _ }

  alias (a) {
    let _ = this[this.cmd] ;(_.from || _.into || _.entity).as = a
    return this
  }

  /** Creates a derived instance that initially inherits all properties. */
  clone (_) {
    const cmd = this.cmd || Object.keys(this)[0]
    return {__proto__:this, [cmd]: {__proto__:this[cmd],..._} }
  }

  flat (q=this) {
    let x = q.cmd || Object.keys(q)[0], y = q[x]
    let protos = [y]; for (let o=y; o.__proto__;) protos.push (o = o.__proto__)
    q[x] = Object.assign ({}, ...protos.reverse())
    if (y.columns) for (let c of y.columns) if (c.SELECT) (this||Query.prototype).flat(c)
    return q
  }

  /** Binds this query to be executed with the given service */
  bind (srv) {
    return Object.defineProperty (this,'_srv',{ value:srv, configurable:true, writable:true })
  }

  /** Turns all queries into Thenables which execute with primary db by default */
  get then() {
    const srv = this._srv || cds.db || cds.error `Can't execute query as no primary database is connected.`
    const q = new AsyncResource('await cds.query')
    return (r,e) => q.runInAsyncScope (srv.run, srv, this) .then (r,e)
  }

  _target_ref4 (target, arg2) {

    // Resolving this._target --> REVISIT: this is not reliable !!!
    Object.defineProperty (this, '_target', { value: _target4 (target,arg2), configurable:true, writable:true })

    return target && (
      typeof target === 'string' ? cds.parse.path(target) :
      target.ref    ? target :
      target.SELECT ? target :
      target.SET    ? target :
      target.raw    ? cds.parse.path(...arguments) :
      target.name   ? {ref:[target.name]} : 0
    )
    || this._expected `${{target}} to be an entity path string, a CSN definition, a {ref}, a {SELECT}, or a {SET}`
  }

  _expected (...args) {
    return cds.error.expected (...args)
  }

  _add (property, values) {
    const _ = this[this.cmd], pd = Reflect.getOwnPropertyDescriptor (_,property)
    _[property] = !pd || !pd.value ? values : [ ...pd.value, ...values ]
    return this
  }

  valueOf (cmd=this.cmd) {
    return `${cmd} ${_name(this._target.name)} `
  }

  forSQL (db = cds.db || cds) { return _flat(db.cqn4sql(this)) }
  toSQL  (db = cds.db || cds) { return _2sql(db.cqn2sql(this)) }
  toSql  (db = cds.db || cds) { return this.toSQL(db).sql }

}

// skip .cqn property when in repl
const _2sql = cds.repl ? ({sql,values}) => ({sql,values}) : (x => x)
const _flat = Query.prototype.flat

const _target4 = (target, arg2) =>  target && (
  typeof target === 'string' ? { name: target } :
  target.name ? target : //> assumed to be a linked csn definition
  target.ref ? { name: target.ref[0] } :
  target.raw ? _target4(arg2) :
  target._target || { name: undefined }
)

const _name = cds.env.sql.names === 'quoted' ? n =>`"${n}"` : n => n.replace(/[.:]/g,'_')

Object.defineProperty (Query.prototype, '_target4', { value: (
  cds.env.ql.quirks_mode === false ? Query.prototype._target_ref4
  : function (...args) {
    const {ref, as} = this._target_ref4 (...args)
    return ref.length === 1 && typeof ref[0] === 'string' && !as ? ref[0] : as ? {ref, as} : {ref}
  }
)})

module.exports = Query
