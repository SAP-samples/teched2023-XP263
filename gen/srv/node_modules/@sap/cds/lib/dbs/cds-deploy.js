const cds = require('../index'), { local } = cds.utils
const COLORS = !!process.stdout.isTTY && !!process.stderr.isTTY
const GREY = COLORS ? '\x1b[2m' : ''
const RESET = COLORS ? '\x1b[0m' : ''
const DEBUG = cds.debug('deploy')
const TRACE = cds.debug('trace')
const nativeSchevoSqls = {
  'postgres': {
    create: `CREATE table cds_model (csn text)`,
    insert: `INSERT into cds_model values ('null')`,
    drop: `DROP table if exists cds_model;`
  },
  'sqlite': {
    create: `CREATE table cds_Model (csn CLOB)`,
    insert: `INSERT into cds_Model values ('null')`,
    drop: `DROP table if exists cds_Model;`
  }
}

/**
 * Implementation of `cds.deploy` common to all databases.
 * It uses the database-specific `db.deploy` to prepare the database, e.g.
 * deploy create tables and views in case of a SQL database, then fills
 * in initial data, if present.
 */
exports = module.exports = function cds_deploy (model,options,csvs) { return {

  /** @param {cds.Service} db */
  async to (db, o = options || cds.options || {}) {
    TRACE?.time ('cds.deploy db  ')

    if (!model)  throw new Error('Must provide a model or a path to model, received: ' + model)
    if (model && !model.definitions) model = await cds.load(model).then(cds.minify)

    if (o.mocked) exports.include_external_entities_in (model)
    else exports.exclude_external_entities_in (model)

    if (!db.run) db = await cds.connect.to(db)
    if (!cds.db) cds.db = cds.services.db = db
    if (!db.model) db.model = model

    // create tables & views...
    const LOG = o.silent || !cds.log('deploy')._info ? ()=>{} : console.log
    const any = await exports.create (db,model,o)
    if (!any && !csvs) return db

    // fill in initial data...
    await exports.init (db,model,o,csvs, file => LOG (GREY,` > init from ${local(file)}`, RESET))

    // done
    let url = db.url4 (cds.context?.tenant); if (url === ':memory:') url = 'in-memory database.'
    LOG ('/> successfully deployed to', url, '\n')

    TRACE?.timeEnd ('cds.deploy db  ')
    return db
  },

  // continue to support cds.deploy() as well...
  then(n,e) { return this.to (cds.db||'db') .then (n,e) },
  catch(e) { return this.to (cds.db||'db') .catch (e) },
}}



const { fs, path, read } = cds.utils
const { readdir } = fs.promises
const isdir = (..._) => fs.isdir(path.join(..._))
const isfile = (..._) => fs.isfile(path.join(..._))

exports.include_external_entities_in = function (model) {
  if (model._mocked) return model; else Object.defineProperty(model,'_mocked',{value:true})
  for (let each in model.definitions) {
    const def = model.definitions[each]
    if (def['@cds.persistence.mock'] === false) continue
    if (def['@cds.persistence.skip'] === true) {
      DEBUG && DEBUG ('including mocked', each)
      delete def['@cds.persistence.skip']
    }
  }
  exports.exclude_external_entities_in (model)
  return model
}

exports.exclude_external_entities_in = function (csn) { // NOSONAR
  // IMPORTANT to use cds.env.requires below, not cds.requires !!
  for (let [each,{service=each,model,credentials}] of Object.entries (cds.env.requires)) {
    if (!model) continue //> not for internal services like cds.requires.odata
    if (!credentials && csn._mocked) continue //> not for mocked unbound services
    DEBUG && DEBUG ('excluding external entities for', service, '...')
    const prefix = service+'.'
    for (let each in csn.definitions) if (each.startsWith(prefix)) _exclude (each)
  }
  return csn

  function _exclude (each) {
    const def = csn.definitions[each]; if (def.kind !== 'entity') return
    if (def['@cds.persistence.table'] === true) return // do not exclude replica table
    DEBUG && DEBUG ('excluding external entity', each)
    def['@cds.persistence.skip'] = true
    // propagate to all views on top...
    for (let other in csn.definitions) {
      const d = csn.definitions[other]
      const p = d.query && d.query.SELECT || d.projection
      if (p && p.from.ref && p.from.ref[0] === each) _exclude (other)
    }
  }
}


exports.create = async function cds_deploy_create (db, csn=db.model, o) {
  // REVISIT: How to find out if we use better-sqlite?
  if (db._source === '@cap-js/sqlite') {
    // it's required to set both properties
    o.betterSqliteSessionVariables = true
    o.sqlDialect = 'sqlite'
  }

  const sqls = nativeSchevoSqls[db.options?.dialect || db.options?.kind || 'sqlite'];
  let drops, creas, schevo = db.options?.schema_evolution === 'auto' || o.schema_evolution === 'auto'
  if (schevo) {
    // REVISIT: replace by db-specific ways to read/updated recent deployed model
    let before;
    try {
      const [{csn}] = await db.read('cds.Model');
      before = JSON.parse(csn);
    } catch(e) {
      if (!e.message.includes('no such table') && !e.message.includes('relation "cds_model" does not exist')) throw e
      // TODO: Put both into one tx - read can not be part of it, as the transaction gets killed in PG once an error appears
      await db.run(sqls.create)
      await db.run(sqls.insert)
      before = null;
    }
    const { afterImage, drops:_drops, createsAndAlters:_creas } = cds.compile.to.sql.delta (csn, {...o, ...db.options}, before)
    creas = _creas.concat (o.dry ? [] : UPDATE('cds.Model').with({ csn: JSON.stringify(afterImage) }))
    drops = before ? _drops : _drops4(_creas)
  } else {
    creas = cds.compile.to.sql (csn, {...o, ...db.options})
    drops = _drops4(creas) .concat (sqls.drop)
  }
  if (!creas || creas.length === 0) return

  function _drops4 (creas) {
    return creas.map (each => {
      let [, kind, entity] = each.match(/^CREATE (TABLE|VIEW) ("[^"]+"|[^\s(]+)/im) || []
      return `DROP ${kind} IF EXISTS ${entity};`
    }).reverse()
  }

  if (o.dry) {
    console.log(); for (let each of drops) console.log(each)
    console.log(); for (let each of creas) console.log(each,'\n')
  }
  else return db.run (async tx => {
    // This runs in a new transaction if called from CLI, while joining
    // existing root tx, e.g. when called from DeploymentService.
    if (!schevo && db.kind == 'sqlite' && await tx.exists('sqlite.schema').where({name:'cds_xt_Extensions'})) {
      // Poor man's schema evolution for extensions in drop-create deployments
      drops = drops.filter(d => !d.includes('cds_xt_Extensions'))
      creas = creas.filter(c => !c.includes('cds_xt_Extensions'))
    }
    // Set the context model while deploying for cqn42sql in new db layers
    tx.model = cds.compile.for.nodejs(csn)
    await tx.run(drops)
    await tx.run(creas)
    return true
  })
}


exports.init = async function cds_deploy_init (db, csn=db.model, o, srces, log=()=>{}) {
  const t = cds.context?.tenant; if (t && t === cds.requires.multitenancy?.t0) return
  return db.run (async tx => {

    const m = tx.model = cds.compile.for.nodejs(csn) //> use correct model while deploying
    const data = await exports.data (m,srces)
    const query = _queries4 (db,m)
    const INSERT_from = INSERT_from4 (db,o)

    for await (let [ file, entity, src ] of data) {
      log (file)
      if (entity) {
        const q = INSERT_from (file) .into (entity, src)
        if (q) try { await tx.run (query(q)) } catch(e) {
          throw Object.assign (e, { message: 'in cds.deploy(): ' + e.message +'\n'+ cds.utils.inspect(q) })
        }
      } else {  //> init.js/ts case
        if (typeof src === 'function') src(tx,csn)
      }
    }
  })
}


/** Prepare input from .csv, .json, init.js, ... */
exports.data = async function cds_deploy_prepare_data (csn, srces) {
  // In case of extension deployment .csv or .json input are provided through argument `srces`.
  if (srces) return Object.entries(srces) .map (([file, src]) => {
    let e = _entity4 (path.basename(file,'.csv'), csn)
    return [ file, e, src ]
  })
  // If not, we load them from cds.deploy.resources(csn)
  const resources = await exports.resources(csn, { testdata: cds.env.features.test_data })
  return Object.entries(resources) .map (async ([file,e]) => {
    if (e === '*') {
      let init_js = await cds.utils._import (file)
      return [ file, null, init_js.default || init_js ]
    } else {
      let src = await read (file, 'utf8')
      return [ file, e, src ]
    }
  })
}


exports.resources = async function cds_deploy_resources (csn, opts) {
  if (!csn || !csn.definitions) csn = await cds.load (csn||'*') .then (cds.minify)
  const folders = await cds_deploy_resources.folders(csn, opts)
  const found={}, ts = process.env.CDS_TYPESCRIPT
  for (let folder of folders) {
    // fetching init.js files
    const init_js = ts && isfile(folder,'init.ts') || isfile(folder,'init.js')
    if (init_js) found[init_js] = '*'
    // fetching .csv and .json files
    for (let each of ['data','csv']) {
      const subdir = isdir(folder,each); if (!subdir) continue
      const files = await readdir (subdir)
      for (let fx of files) {
        if (fx[0] === '-') continue
        const ext = path.extname(fx); if (ext in {'.csv':1,'.json':2}) {
          const f = fx.slice(0,-ext.length)
          if (/[._]texts$/.test(f) && files.some(g => g.startsWith(f+'_'))) {
            // ignores 'Books_texts.csv/json' if there is any 'Books_texts_LANG.csv/json'
            DEBUG && DEBUG (`ignoring '${fx}' in favor of translated ones`)
            continue
          }
          const e = _entity4(f,csn); if (_skip(e)) continue
          if (cds.env.features.deploy_data_onconflict === 'replace' && !/[._]texts_/.test(f)) {
            const seenBefore = Object.entries(found).find(([_, entity]) => entity === e.name )
            if (seenBefore) {
              DEBUG && DEBUG(`Conflict for '${e.name}': replacing '${local(seenBefore[0])}' with '${local(path.join(subdir,fx))}'`)
              continue
            }
          }
          found[path.join(subdir,fx)] = e.name
        }
      }
    }
  }
  return found
}


exports.resources.folders = async function (csn, o={}) {
  if (!csn || !csn.definitions) csn = await cds.load (csn||'*') .then (cds.minify)
  const folders = new Set (csn.$sources.map (path.dirname) .filter (f => f !== cds.home))
  if (cds.env.folders.db) folders.add (path.resolve(cds.root, cds.env.folders.db))
  if (o.testdata) folders.add (path.resolve(cds.root,'test/'))
  return folders
}


const _entity4 = (file,csn) => {
  const name = file.replace(/-/g,'.')
  const entity = csn.definitions [name]
  if (!entity) {
    if (/(.+)[._]texts_?/.test(name)) { // 'Books.texts', 'Books.texts_de'
      const base = csn.definitions [RegExp.$1]
      return base?.elements?.texts && _entity4 (base.elements.texts.target, csn)
    }
    else return DEBUG && DEBUG (`warning: ${name} not in model`)
  }
  // We also support insert into simple views if they have no projection
  const p = entity.query && entity.query.SELECT || entity.projection
  if (p && !p.columns && p.from.ref && p.from.ref.length === 1) {
    if (csn.definitions [p.from.ref[0]])  return entity
  }
  return entity.name ? entity : { name, __proto__:entity }
}


/** Prepare special handling for new db services */
const _queries4 = (db,csn) => !db.cqn2sql ? q => q : q => {
  const { columns, rows } =  q.INSERT || q.UPSERT; if (!columns) return q // REVISIT: .entries are covered by current runtime -> should eventually also be handled here
  const entity = csn.definitions[q._target.name]

  // Fill in missing primary keys...
  const { uuid } = cds.utils
  for (let k in entity.keys) if (entity.keys[k].isUUID && !columns.includes(k)) {
    columns.push(k)
    rows.forEach(row => row.push(uuid()))
  }

  // Fill in missing managed data...
  const pseudos = { $user: 'anonymous', $now: (new Date).toISOString() }
  for (let k in entity.elements) {
    const managed = entity.elements[k]['@cds.on.insert']?.['=']
    if (managed && !columns.includes(k)) {
      columns.push(k)
      rows.forEach(row => row.push(pseudos[managed]))
    }
  }

  return q
}


const INSERT_from4 = (db,o) => {
  const schevo = db.options?.schema_evolution === 'auto' || o?.schema_evolution === 'auto'
  const INSERT_into = (schevo ? UPSERT : INSERT).into
  return (file) => ({
    '.json': { into (entity, json) {
      let records = JSON.parse(json)
      if (records.length > 0) return INSERT_into(entity).entries(records)
    }},
    '.csv': { into (entity, csv) {
      let [cols, ...rows] = cds.parse.csv(csv)
      if (rows.length > 0) return INSERT_into(entity).columns(cols).rows(rows)
    }},
  }) [path.extname(file)]
}

const _skip = e => !e || e['@cds.persistence.skip'] === true
/* eslint-disable no-console */
