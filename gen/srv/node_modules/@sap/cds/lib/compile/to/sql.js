const cds = require ('../..')
const cdsc = require ('../cdsc')
const keywords = require("@sap/cds-compiler").to.sql.sqlite.keywords

function cds_compile_to_sql (csn,_o) {
  csn = _extended(cds.minify(csn))
  const o = cdsc._options.for.sql(_o) //> used twice below...
  const all = cdsc.to.sql(csn,o) .map (each => each.replace(/^-- .+\n/,''))  //> strip comments
  const sql = cds.compile._localized.unfold_ddl(all, csn, o)
  if (o.as === 'str') return `\n${sql.join('\n\n')}\n`
  return sql
}


function cds_compile_to_hdbtable (csn,o) {
  const all = cdsc.to.hdi (cds.minify(csn),o)
  return _2many(all)
}

function cds_compile_to_deltaSql (csn, o, beforeCsn) {
  const options = cdsc._options.for.sql(o);
  const { afterImage, drops, createsAndAlters } = cdsc.to.deltaSql (csn, options, beforeCsn || {definitions: {}, $version: '2.0'} ); // FIXME: As default value in compiler API?
  return { 
    afterImage, 
    drops: cds.compile._localized.unfold_ddl(drops.map (each => each.replace(/^-- .+\n/,'')), csn, options), 
    createsAndAlters: cds.compile._localized.unfold_ddl(createsAndAlters.map (each => each.replace(/^-- .+\n/,'')), csn, options) 
  };
}

function cds_compile_to_hdbcds (csn,o) {
  const all = cdsc.to.hdbcds (cds.minify(csn),o)
  const constructFileName = (fileName) => {
    const identifier = fileName.split('.');
    const suffix = identifier.pop();
    return identifier.join('_').concat(`.${suffix}`);
  }
  return _2many(all, constructFileName);
}

function* _2many (all,_file=f=>f) {
  for (let file in all) yield [
    all[file].replace(/^(\/\/|--) generated by .+\n/,''),
    { file:_file(file) }
  ]
}

module.exports = Object.assign (cds_compile_to_sql, {
  hdbcds: cds_compile_to_hdbcds,
  hdbtable: cds_compile_to_hdbtable,
  delta: cds_compile_to_deltaSql,
  sqlite: { keywords },
})




/////////////////////////////////////////////////////////////////////////////
// UI Flex - read extensions__ to views, when ext fields are read
const _extended = (csn) => {
  const defs = cds.linked(csn).definitions
  for (let each in defs) {
    const d = defs[each], q = d.query // TODO: q may have SET instead of SELECT
    if (q && q.SELECT && q.SELECT.columns && _is_extensible(d)) {
      if (!q.SELECT.columns.some(({ref}) => ref && ref[0] === _extensions)) q.SELECT.columns.push({ref:[_extensions]})
    }
  }
  return csn
}
const _is_extensible = d => _extensions in d.elements || d.__proto__.elements && _is_extensible (d.__proto__)
const _extensions = 'extensions__'
/////////////////////////////////////////////////////////////////////////////
