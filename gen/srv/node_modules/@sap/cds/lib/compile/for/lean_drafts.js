const cds = require('../../index')

function _getBacklinkName(on) {
  const i = on.findIndex(e => e.ref && e.ref[0] === '$self')
  if (i === -1) return
  let ref
  if (on[i + 1] && on[i + 1] === '=') ref = on[i + 2].ref
  if (on[i - 1] && on[i - 1] === '=') ref = on[i - 2].ref
  return ref && ref[ref.length - 1]
}

function _isCompositionBacklink(e) {
  if (!e.isAssociation) return
  if (!e._target?.associations) return
  if (!(!e.isComposition && (e.keys || e.on))) return
  for (const anchor of Object.values(e._target.associations)) {
    if (!(anchor.isComposition && anchor.on?.length > 2)) continue
    if (_getBacklinkName(anchor.on) === e.name && anchor.target === e.parent.name) return anchor
  }
}

const IGNORED_ENTITY_ANNOTATIONS = new Set([
  '@readonly',
  '@insertonly',
  '@restrict',
])

const IGNORED_ELEMENT_ANNOTATIONS = [
  '@assert.range',
  '@assert.enum',
  '@assert.format',
  '@assert.target',
  '@mandatory',
  '@Core.Immutable',
  '@readonly',
  '@Core.Computed',
  '@Common.FieldControl.Readonly',
  '@Common.FieldControl.Mandatory',
  '@FieldControl.Mandatory',
  '@FieldControl.ReadOnly',
  '@Common.FieldControl',
  '@PersonalData.DataSubjectRole',
  '@PersonalData.EntitySemantics',
  '@PersonalData.IsPotentiallyPersonal',
  '@PersonalData.IsPotentiallySensitive',
  '@PersonalData.FieldSemantics'
  // These are still needed:
  // '@odata.etag',
  // '@cds.on.update',
  // '@cds.on.insert',
]

module.exports = function cds_compile_for_lean_drafts(csn) {
  const DRAFT_ELEMENTS = new Set([
    'IsActiveEntity',
    'HasDraftEntity',
    'HasActiveEntity',
    'DraftAdministrativeData',
    'DraftAdministrativeData_DraftUUID',
    'SiblingEntity'
  ])
  function _redirect(assoc, target, keys) {
    assoc.target = target.name
    assoc._target = target
    if (keys) assoc.on = _onCondition(assoc.name, keys)
  }

  function _onCondition(left, keys, right) {
    const on = []
    for (let k in keys)
      DRAFT_ELEMENTS.has(k) || on.push({ ref: [left, k] }, '=', { ref: right ? [right, k] : [k] }, 'and')
    on.pop()
    return on
  }

  function _isDraft(def) {
    return (
      def.associations?.DraftAdministrativeData ||
      (def.own('@odata.draft.enabled') && def.own('@Common.DraftRoot.ActivationAction'))
    )
  }

  const { Draft } = cds.linked(`
  entity ActiveEntity { key ID: UUID; }
  entity Draft {
    virtual IsActiveEntity            : Boolean; // REVISIT: these are calculated fields, aren't they?
    virtual HasDraftEntity            : Boolean; // REVISIT: these are calculated fields, aren't they?
    HasActiveEntity                   : Boolean; // This should be written !!!
    DraftAdministrativeData           : Association to DRAFT.DraftAdministrativeData;
    DraftAdministrativeData_DraftUUID : UUID;
    // SiblingEntity                  : Association to ActiveEntity; // REVISIT: Why didn't we use a managed assoc here?
  }
  entity DRAFT.DraftAdministrativeData {
    key DraftUUID         : UUID;
    LastChangedByUser     : String(256);  LastChangeDateTime : Timestamp;
    CreatedByUser         : String(256);  CreationDateTime   : Timestamp;
    InProcessByUser       : String(256);
    DraftIsCreatedByMe    : Boolean; // REVISIT: these are calculated fields, aren't they?
    DraftIsProcessedByMe  : Boolean; // REVISIT: these are calculated fields, aren't they?
  }
`).definitions
  function draftEntity(active, model) {
    const _draftEntity = active.name + '.drafts'
    const d = model.definitions[_draftEntity]
    if (d) return d
    // We need to construct a fake draft entity definition
    const draft = { __proto__: active, name: _draftEntity, elements: { ...active.elements, ...Draft.elements } }
    Object.defineProperty(model.definitions, _draftEntity, { value: draft })
    Object.defineProperty(active, 'drafts', { value: draft })
    Object.defineProperty(draft, 'actives', { value: active })
    Object.defineProperty(draft, 'isDraft', { value: true })
    draft['@cds.persistence.table'] = _draftEntity

    for (const key in draft) {
      if (IGNORED_ENTITY_ANNOTATIONS.has(key) || key.startsWith('@Capabilities') || key.startsWith('@PersonalData')) draft[key] = undefined
    }
    // Recursively add drafts for compositions
    for (const each in draft.elements) {
      const e = draft.elements[each]
      const newEl = Object.create(e)
      if (e.isComposition || (e.isAssociation && e['@odata.draft.enclosed']) || _isCompositionBacklink(e)) {
        if (e._target['@odata.draft.enabled'] === false) continue // happens for texts if @fiori.draft.enabled is not set
        _redirect(newEl, draftEntity(e._target, model))
      }
      newEl.parent = draft
      for (const ignoredAnno of IGNORED_ELEMENT_ANNOTATIONS) {
        if (newEl[ignoredAnno]) newEl[ignoredAnno] = undefined
      }
      draft.elements[each] = newEl
    }
    return draft
  }
  for (const name in csn.definitions) {
    const def = csn.definitions[name]
    if (!_isDraft(def)) continue
    ;[
      'IsActiveEntity',
      'HasDraftEntity',
      'HasActiveEntity',
      'DraftAdministrativeData_DraftUUID',
      'DraftAdministrativeData'
    ].forEach(s => {
      def.elements[s].virtual = true
    })
    // will insert drafts entities, so that others can use `.drafts` even without incoming draft requests
    draftEntity(def, csn, Draft)
  }
}
