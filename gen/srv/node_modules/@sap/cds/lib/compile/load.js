const cds = require('..')
const TRACE = cds.debug('trace')

module.exports = exports = function cds_load (files, options) {
  const all = cds.resolve(files,options)
  if (!all) return Promise.reject (new cds.error ({
    message: `Couldn't find a CDS model for '${files}' in ${cds.root}`,
    code: 'MODEL_NOT_FOUND', files,
  }))
  return this.get (all,options,'inferred')
}


exports.parsed = function cds_get (files, options, _flavor) { // NOSONAR

  TRACE?.time('cds.load model ')
  const o = typeof options === 'string' ? { flavor:options } : options || {}
  if (!files) files = ['*']; else if (!Array.isArray(files)) files = [files]
  if (o.files || o.flavor === 'files') return cds.resolve(files,o)
  if (o.sources || o.flavor === 'sources') return _sources4 (cds.resolve(files,o))

  const csn = cds.compile (files,o,
    o.parse  ? 'parsed' :
    o.plain  ? 'xtended' :
    o.clean  ? 'xtended' : // for compatibility
    o.flavor || _flavor || 'parsed'
  )
  return csn.then
    ? csn.then (_csn => _finalize(_csn,o)) // async compile
    : _finalize (csn,o) // synchronous compile
}

const _finalize = (csn,o) => {
  if (!o.silent) cds.emit ('loaded', csn)
  TRACE?.timeEnd('cds.load model ')
  return csn
}

const _sources4 = async (files) => {
  const {path:{relative},fs:{promises:{readFile}}} = cds.utils, cwd = cds.root
  const sources = await Promise.all (files.map (f => readFile(f,'utf-8')))
  return files.reduce ((all,f,i) => { all[relative(cwd,f)] = sources[i]; return all },{})
}

exports.properties = (...args) => (exports.properties = require('./etc/properties').read) (...args)
exports.yaml = (file) => (exports.yaml = require('./etc/yaml').read) (file)
exports.csv = (file) => (exports.csv = require('./etc/csv').read) (file)
