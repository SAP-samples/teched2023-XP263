const { is_mocha, is_jest } = support_jest_and_mocha()

class Test extends require('./axios') {

  /**
   * Launches a cds server with arbitrary port and returns a subclass which
   * also acts as an axios lookalike, providing methods to send requests.
   */
  run (cmd='.', ...args) {

    const {cds} = this; this.cmd = cmd, this.args = args
    if (!/^(serve|run)$/.test(cmd)) try {
      const project = cds.utils.isdir(cmd) || require.resolve (cmd+'/package.json').slice(0,-13)
      this.cmd = cmd = 'serve'; args.push ('--in-memory?')
      this.in (project)
    } catch(e) {
      throw cds.error (`No such folder or package '${process.cwd()}' -> '${cmd}'`)
    }

    // launch cds server...
    before (`launching ${cmd} ${args.join(' ')}...`, () => {
      cds.once ('listening', ({server,url}) => {
        const axp = Reflect.getOwnPropertyDescriptor(this,'axios')
        if (axp) axp.value.defaults.baseURL = url
        this.server = server
        this.url = url
      })
      try { return cds.exec (cmd, ...args, ...(args.includes('--port') ? [] : ['--port', '0'])) }
      catch (e) { if (is_mocha) console.error(e) } // eslint-disable-line no-console
    })

    // gracefully shutdown cds server...
    after (() => this.server && cds.shutdown())

    beforeEach (async () => {
      if (this.data._autoReset)  await this.data.reset()
    })

    return this
  }

  /**
   * Serving projects from subfolders under the root specified by a sequence
   * of path components which are concatenated with path.resolve().
   * Checks conflicts with cds.env loaded in other folder before.
   */
  in (...paths) {
    const {cds} = this; cds.root = require('path').resolve (cds.root, ...paths)
    // const env = Reflect.getOwnPropertyDescriptor(cds,'env')
    // if (env && env.value && env.value._home !== cds.root) {
    //   throw new Error (`[cds.test] - 'cds.env' was invoked before 'cds.test.in' from a different home:

    //   cds.env._home: ${cds.env._home}
    //   cds.test.in:   ${cds.root}

    //   > throwing this as tests would likely behave erratically.
    //   `)
    // }
    return this
  }

  /**
   * Switch on/off console log output.
   */
  verbose (v) {
    initLogging({ is_mocha, is_jest, verbose: v })
    return this
  }

  /**  Lazily loads and returns an instance of chai */
  get chai() { return super.chai = load_chai() }
  get expect() { global.describe.each || support_jest_and_mocha(); return this.chai.expect }
  get assert() { global.describe.each || support_jest_and_mocha(); return this.chai.assert }
  get sleep() { return super.sleep = require('util').promisify(setTimeout) }
  get data() { return super.data = new (require('./data'))}
  get cds() { return require('../index') }
  get spy() { return spy }

  then(r) {
    const {cds} = this
    if (this.server) {
      r({ server: this.server, url: this.url })
    } else {
      cds.once('listening', r)
    }
  }
}

function support_jest_and_mocha() {
  const is_jest = !!global.beforeAll
  const is_mocha = !!global.before
  if (is_mocha) {
    global.beforeAll = global.before
    global.afterAll = global.after
    global.test = global.it
    const { format } = require('util')
    for (let td of [ 'test', 'describe' ]) global[td].each = function(table) {
      return (title,fn) => Promise.all (table.map (each => {
        if (!Array.isArray(each))  each = [each]
        return this (format(title,...each), ()=> fn(...each))
      }))
    }
    after(()=>{
      delete global.cds
      for (let k in require.cache) delete require.cache[k] // REVISIT: Whay are we doing that?
    })
  } else if (is_jest) { // it's jest
    global.before = (msg,fn) => global.beforeAll(fn||msg)
    global.after = (msg,fn) => global.afterAll(fn||msg)
  } else { // it's none of both
    global.before = global.beforeAll = (_,fn) => fn()
    global.beforeEach = ()=>{}
    global.afterEach = ()=>{}
    global.after = global.afterAll = (fn) => {
      const repl = global.cds.repl
      repl && repl.on('exit',fn)
    }
  }
  initLogging ({ is_jest, is_mocha })
  return { is_jest, is_mocha }
}

function load_chai() {
  const require = (mod) => { try { return module.require(mod) } catch(e) {
    if (e.code === 'MODULE_NOT_FOUND') throw new Error (`
    Failed to load required package '${mod}'. Please add it thru:
    npm add -D chai chai-as-promised chai-subset
  `)}}
  const chai = require('chai')           // eslint-disable-line cds/no-missing-dependencies
  chai.use (require('chai-subset'))      // eslint-disable-line cds/no-missing-dependencies
  chai.use (require('chai-as-promised')) // eslint-disable-line cds/no-missing-dependencies
  return chai
}

function initLogging ({ verbose }={}) {
  if (verbose && global.console.logs) return global.console = global.console.__proto__
  if (process.env.CDS_TEST_SILENT) {
    const console = global.console, logs = []
    const {format} = require('util')
    global.console = { __proto__: console, logs,
      time: ()=>{}, timeEnd: (...args)=> logs.push(args),
      debug: (...args)=> logs.push(args),
      info: (...args)=> logs.push(args),
      log: (...args)=> logs.push(args),
      warn: (...args)=> logs.push(args),
      trace: (...args)=> logs.push(args),
      error: (...args)=> logs.push(args),
      dump(){ for (let each of logs) process.stdout.write (format(...each)+'\n') },
    }
    afterAll (()=> global.console = console)
  }
}

const spy = (o,f) => {
  const origin = o[f]
  const fn = function (...args) {
    ++fn.called
    return origin.apply(this,args)
  }
  fn.called = 0
  fn.restore = ()=> o[f] = origin
  return o[f] = fn
}


/** @type Test & ()=>Test */
module.exports = Object.assign (
  Object.setPrototypeOf ((..._) => (new Test).run(..._), Test.prototype),
  { Test }
)
