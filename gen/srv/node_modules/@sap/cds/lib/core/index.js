/*
	This is the inner core of cds: its type system, bootstrapped from in-place
	CSN models itself. Besides the actual root types, a set of common and
	recommended scalar types is added to builtin.types.
*/
const classes = Object.assign (
	require('./classes'),
	require('./entities'),
)


/** Type system roots -> can be used with instanceof */
const roots = _roots ({
	context: {},
	type: {},
		scalar: {type:'type'},
			string: {type:'scalar'},
			number: {type:'scalar'},
			boolean: {type:'scalar'},
			date: {type:'scalar'},
		array: {type:'type'},
		struct: {type:'type'},
			aspect: {type:'struct'},
			entity: {type:'struct'},
			event: {type:'struct'},
	Association: {type:'type'},
	Composition: {type:'Association'},
	service: {type:'context'},
	$self: {}, //> to support polymorphic self links like in: action foo( self: [many] $self, ...)
})

/**
 * Turns the given CSN definitions into linked definitions with classes.
 * @type <T>(csn:T) => T
 */
 function _roots (defs) {
	const linked = { any: classes.any.prototype }
	for (const t in defs) {
		if (t in classes) linked[t] = classes[t].prototype
		else {
			const c = class extends classes[defs[t].type || 'any'] {}
			classes[t] = Object.defineProperty (c, 'name', {value:t})
			linked[t] = Object.defineProperty (c.prototype, 'name', {value:t})
		}
	}
	return linked
}


/** Construct builtin.types as dictionary of all roots and common types */
const types = _common ({ __proto__: roots,
	UUID: {type:'string',length:36,isUUID:true},
	String: {type:'string'}, LargeString: {type:'String'},
	Binary: {type:'string'}, LargeBinary: {type:'Binary'},
	Boolean: {type:'boolean'},
	Integer: {type:'number'},
		UInt8: {type:'Integer'},
		Int16: {type:'Integer'}, Integer16: {type:'Int16'},
		Int32: {type:'Integer'}, Integer32: {type:'Int32'},
		Int64: {type:'Integer'}, Integer64: {type:'Int64'},
	Float: {type:'number'},
	Double: {type:'Float'},
	Decimal: {type:'Float'}, DecimalFloat: {type:'Decimal'},
	Date: {type:'date'},
	Time: {type:'date'},
	DateTime: {type:'date'},
	Timestamp: {type:'DateTime'},
})

/**
 * Link all definitions, essentially by: d.__proto__ = resolved (d.type),
 * and prefixes all common types with a namespace 'cds'.
 * @type <T>(csn:T) => T & roots
 */
function _common (defs) {
	const prefixed = {__proto__:defs}
	for (let [name,d] of Object.entries(defs)) {
		defs[name] = Object.defineProperty({ ...d, __proto__: defs[d.type] }, 'name', {value:name})
		Object.defineProperty (prefixed['cds.'+name] = defs[name], '_type', {value:'cds.'+name})
	}
	for (let name of ['Association','Composition']) {
		Object.defineProperty (prefixed['cds.'+name] = defs[name], '_type', {value:'cds.'+name})
	}
	return prefixed
}

;(
	/**
	 * Adds convenience functions which can be used like that:
	 * ```js
	 * var { Date, Time, DateTime } = cds.builtin.types
	 * DateTime.now()   //> 2023-02-10T14:41:36.218Z
	 * Date.now()       //> 2023-02-10T14:41:36.218Z
	 * Time.now()       //> 14:43:18
	 * Date.today()     //> 2023-02-10
	 * ```
	 */
	function _add_convenience_functions(){
		Object.defineProperties (types.Date, {
			today: { value: ()=> (new Date).toISOString().slice(0,10) },
			now: { value: ()=> (new Date).toISOString() },
		})

		Object.defineProperties (types.Time, {
			now: { value: ()=> (new Date).toISOString().slice(11,19) },
		})

		Object.defineProperties (types.DateTime, {
			now: { value: ()=> (new Date).toISOString() },
		})
	}
)()

module.exports = { types, classes }
