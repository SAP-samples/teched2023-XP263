const { extend } = require('../lazy')

class any {

  constructor(...aspects) { Object.assign (this,...aspects) }
  set name(n) { this.set('name', n, false) }
  set kind(k) { this.set('kind', k, true) }
  get kind() { return this.set('kind', this.parent ? 'element' : 'type') }
  is (kind) { return this.kind === kind || kind === 'any' }
  valueOf() { return this.name }

  own (property, ifAbsent) {
    const pd = Reflect.getOwnPropertyDescriptor (this, property)
    if (pd) return pd.value //|| pd.get(this)
    if (ifAbsent) return this.set (property, ifAbsent())
  }

  set (property, value, enumerable = false) {
    Reflect.defineProperty (this, property, { value, enumerable, writable:1, configurable:1 })
    return value
  }

  dataIn (d, prefix='') {
    return d[prefix + this.name]
  }
}

class type extends any {}
class action extends any {}
class context extends any {}

class service extends context {

  get path() { return super.path = service.path4(this) }

  /**
   * Resolve a service endpoint path to mount it to as follows...
   * Use _path or def[@path] if given with leading '/' prepended if necessary.
   * Otherwise, use the service definition name with stripped 'Service'
   */
  static path4 (srv, _path = (srv.definition || srv)['@path']) {
    if (_path) return _path.startsWith('/') ? _path : '/'+_path
    else return '/' + ( // return a sluggified variant of the service's name
      /[^.]+$/.exec(srv.name)[0]  //> my.very.CatalogService --> CatalogService
      .replace(/Service$/,'')     //> CatalogService --> Catalog
      .replace(/_/g,'-')          //> foo_bar_baz --> foo-bar-baz
      .replace(/([a-z0-9])([A-Z])/g, (_,c,C) => c+'-'+C)  //> ODataFooBarX9 --> OData-Foo-Bar-X9
      .toLowerCase()      //> FOO --> foo
    )
  }
}

class array extends type { is(kind) { return kind === 'array' || super.is(kind) }}
class aspect extends type { is(kind) { return kind === 'aspect' || super.is(kind) }}
class event extends aspect{}

class struct extends aspect {
  is(kind) { return kind === 'struct' || super.is(kind) }

  /**
   * Gets the foreign key data for a given managed association from inbound data
   * in structured form.
   *
   * @example
   * let { Books } = srv.entities
   * let { author } = Books.elements
   * let book = { // inbound data, e.g. from req.data
   *   title: 'Foo',
   *   author_ID: 111
   * }
   * let value = author.dataIn(book)
   * //> { ID: 111 }
   *
   * Actually this works for all struct-like elements, i.e., which's definitions
   * have .elements or .foreignKeys. Could be added to cds.struct/cds.Association.
   */
  dataIn (d, prefix='', _skip_root) {
    const key = prefix + this.name; if (!_skip_root && key in d) return d[key]
    const elements = this.elements || this.foreignKeys // REVISIT: .foreignKeys should be .elements
    const nested={}, key_ = _skip_root ? '' : key+'_'
    let any; for (let e in elements) {
      const v = elements[e] .dataIn (d,key_)
      if (v !== undefined) nested[any=e] = v
    }
    if (any) return !prefix && d._hull ? d._hull[key] = nested : nested
  }

  /**
   * Returns a Proxy for provided data which adds getters to return values
   * for struct elements (including Associations) in structured form.
   *
   * @example
   * let { Books } = m.entities
   * let data = Books.data ({
   *   author: {ID:111},
   *   genre_ID: 22
   * })
   * console.log ('author:', data.author) //> { ID: 111 }
   * console.log ('genre:', data.genre)  //> { ID: 22 }
   */
   data (d) {
    if (_proxy in d) return d[_proxy] //> use cached proxy, if exists

    // hull to cache calculated values without polluting original input
    const _hull = {__proto__:d}

    // allow external code to access _hull
    Object.defineProperty (_hull, '_hull', {value:_hull})

    // proxy calls def.dataIn() for defined elements, fallback hull[p]
    const {elements} = this, proxy = new Proxy (d, {
      get: (_,p) => elements[p]?.dataIn(_hull) || _hull[p],
    })

    // cache proxy with original data
    Object.defineProperty (d, _proxy, {value:proxy})

    return proxy
  }

}
const _proxy = Symbol('_proxy')


/**
 * Export is a dictionary of all builtin classes
 */
module.exports = {

  any,
  type,
  array,
  aspect,
  struct,
  context,
  service,
  action,
  event,

  /**
   * Allows to mixin functions or properties to several equally named builtin classes
   * @example
   * cds.builtin.classes.mixin (
   *  	class any { foo(){} },
   *  	class entity { bar(){} }
   * )
   */
  mixin(...classes) { for (let each of classes) {
    const clazz = this[each.name]
    if (!clazz) throw new Error(`unknown class '${each.name}'`)
    extend(clazz).with(each)
  }},
}
