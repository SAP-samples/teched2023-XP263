/** ------------------------------------------
 * This is a peg.js adaptation of the https://github.com/oasis-tcs/odata-abnf/blob/master/abnf/odata-abnf-construction-rules.txt
 * which directly constructs CQN out of parsed sources.
 *
 * NOTE:
 * In contrast to the OData ABNF source, which uses very detailed semantic rules,
 * this adaptation uses rather generic syntactic rules only, e.g. NOT distinguishing
 * between Collection Navigation or NOT knowing individual function names.
 * This is to be open to future enhancements of the OData standard, as well as
 * to improve error messages. For example a typo in a function name could be
 * reported specifically instead of throwing a generic parser error.
 *
 * See also: https://docs.microsoft.com/en-us/odata/concepts/queryoptions-overview
 * Future test cases http://docs.oasis-open.org/odata/odata/v4.0/errata03/os/complete/abnf/odata-abnf-testcases.xml
 *
 * Limitations: Type, Geo functions are NOT supported,
 * maxdatetime, mindatetime, fractionalseconds,
 * totaloffsetminutes, date, totalseconds,
 * floor, ceiling also are NOT supported by CAP
 *
 * Examples:
 * Books
 * Books/201
 * Books?$select=ID,title&$expand=author($select=name)&$filter=stock gt 1&$orderby=title
 */

//
// ---------- JavaScript Helpers -------------
  {

    const $ = Object.assign
    const { strict, minimal } = options
    const stack = []
    let SELECT, count
    const TECHNICAL_OPTS = ['$value'] // odata parts to be handled somewhere else
    // we keep that here to allow for usage in https://pegjs.org/online
    const safeNumber =
      options.safeNumber ||
      function (str) {
        const n = Number(str)
        return Number.isSafeInteger(n) ? n : str
      }
    const skipToken = options.skipToken
    const standardBase64 =
      options.standardBase64 ||
      function (str) {
        // convert url-safe to standard base64 (with padding, if necessary)
        return Buffer.from(str, 'base64').toString('base64')
      }
    const _compareRefs = col => exp =>
      col === exp ||
      (col.as && exp.as && col.as === exp.as) ||
      (exp.as && col.ref && exp.as === col.ref[col.ref.length - 1]) ||
      (col.ref && exp.ref && col.ref.join('') === exp.ref.join(''))
    const _remapFunc = columns => c => {
      if (Array.isArray(c)) return c.map(_remapFunc(columns))
      const fnObj = c.ref && columns.find(col => col.as && col.func && col.as === c.ref[0])
      if (fnObj) return fnObj
      return c
    }
    const _replaceNullRef = groupBy => c => {
      if (Array.isArray(c)) return c.map(_replaceNullRef(groupBy))
      if (c.ref && !groupBy.find(_compareRefs(c))) return { val: null }
      return c
    }
    const _expand = (columns, col) => {
      if (col.ref.length === 1) {
        if (!columns.find(_compareRefs(col))) columns.push(col)
      } else {
        const assoc = col.ref.shift()
        const exp = columns.find(c => c.ref && c.ref[0] === assoc)
        if (exp) {
          _expand(exp.expand, col)
        } else {
          const exp = {
            ref: [assoc],
            expand: []
          }
          _expand(exp.expand, col)
          columns.push(exp)
        }
      }
    }
    const _handleApply = (cqn, apply, onlyColumnsFromExpand = false) => {
      let newCqn = _convertApply({ from: cqn.from }, apply, onlyColumnsFromExpand)
      if (Array.isArray(newCqn)) {
        for (let i = 0; i < newCqn.length; i++) {
          newCqn[i] = _addNormalQueryOptions(newCqn[i], cqn, onlyColumnsFromExpand)
        }
      } else newCqn = _addNormalQueryOptions(newCqn, cqn, onlyColumnsFromExpand)

      return newCqn
    }
    const _addNormalQueryOptions = (cqn, topCqn, onlyColumnsFromExpand) => {
      if (!topCqn) return cqn
      if (topCqn.apply) delete topCqn.apply
      let newCqn = {}
      if (
        (topCqn.columns && topCqn.columns[0].as === '$count') ||
        (cqn.SELECT.where && topCqn.where) ||
        (cqn.SELECT.limit && topCqn.limit) ||
        (cqn.SELECT.orderBy && topCqn.orderBy) ||
        (cqn.SELECT.search && topCqn.search)
      ) {
        newCqn.from = cqn
      } else newCqn = cqn.SELECT
      for (const queryOption in topCqn) {
        if (queryOption === 'columns') {
          topCqn.columns = topCqn.columns.map(topCol => {
            if (newCqn.columns)
              return (
                newCqn.columns.find(
                  col =>
                    (topCol.ref && topCol.ref[0] === col.as) ||
                    (col.ref && topCol.ref && topCol.ref[0] === col.ref[0] && !topCol.expand)
                ) || topCol
              )
            return topCol
          })
          if (newCqn.columns && newCqn.groupBy)
            topCqn.columns.push(
              ...(newCqn.columns.filter(
                col =>
                  onlyColumnsFromExpand &&
                  newCqn.groupBy.find(group => col.ref && col.ref[0] === group.ref[0]) &&
                  !topCqn.columns.some(
                    topCol =>
                      (topCol.ref && topCol.ref[0] === col.as) ||
                      (topCol.ref && col.ref && topCol.ref[0] === col.ref[0]) ||
                      (topCol.as && topCol.as === col.as)
                  )
              ) || [])
            )
          newCqn.columns = topCqn.columns
        } else if (queryOption !== 'from') newCqn[queryOption] = topCqn[queryOption]
      }
      const aggregatedColumns = [
        ...((newCqn.columns &&
          newCqn.columns.filter(
            col => newCqn.groupBy && newCqn.groupBy.find(group => col.ref && col.ref[0] === group.ref[0])
          )) ||
          []),
        ...((newCqn.columns && newCqn.columns.filter(col => col && typeof col === 'object' && 'func' in col)) || [])
      ]
      _handleAggregatedColumns(newCqn, aggregatedColumns, onlyColumnsFromExpand)
      return { SELECT: newCqn }
    }
    const _handleAggregatedColumns = (cqn, aggregatedColumns, onlyColumnsFromExpand) => {
      if (aggregatedColumns.length) {
        cqn.columns =
          cqn.columns && !onlyColumnsFromExpand
            ? // using .reduce instead of .filter since columns order might be important
              cqn.columns.reduce((columns, col) => {
                const aggregatedColumn = aggregatedColumns.find(_compareRefs(col))
                if (aggregatedColumn) columns.push(aggregatedColumn)
                return columns
              }, [])
            : aggregatedColumns
        if (cqn.where) {
          cqn.where = cqn.where.map(_remapFunc(cqn.columns))
          if (cqn.groupBy) {
            cqn.having = cqn.where.map(_replaceNullRef(cqn.groupBy))
            delete cqn.where
          }
        }
        // expand navigation refs in aggregated columns
        cqn.columns = cqn.columns.reduce((columns, col) => {
          if (col.ref && col.ref.length > 1 && aggregatedColumns.find(_compareRefs(col))) {
            _expand(columns, { ref: [...col.ref] })
          } else columns.push(col)
          return columns
        }, [])
      }
    }
    const _convertApply = (cqn, apply, onlyColumnsFromExpand) => {
      if (!apply) return
      if (cqn.apply) delete cqn.apply
      if (apply.identity && cqn.from.SELECT) cqn = cqn.from.SELECT
      if (
        apply.apply ||
        (apply.where && cqn.where) ||
        (apply.search && cqn.search) ||
        (apply.limit && cqn.limit) ||
        (apply.orderBy && cqn.orderBy)
      ) {
        cqn.from = { SELECT: { ...cqn } }
      }
      if (apply.where) cqn.where = apply.where
      if (apply.search) cqn.search = apply.search
      if (apply.groupBy) {
        cqn.groupBy = []
        for (const col of apply.groupBy) {
          if (!cqn.groupBy.find(_compareRefs(col))) cqn.groupBy.push(col)
        }
      }
      if (apply.limit) cqn.limit = apply.limit
      if (apply.orderBy) cqn.orderBy = apply.orderBy
      const aggregatedColumns = [...(cqn.groupBy || []), ...(apply.aggregate || [])]
      _handleAggregatedColumns(cqn, aggregatedColumns, onlyColumnsFromExpand)
      
      if (apply.apply && cqn.from) _convertApply(cqn.from.SELECT, apply.apply)
      
      if (apply.concat && Array.isArray(apply.concat)) {
        const additionalQueries = []
        for (let select of apply.concat) {
          select.from =
            Object.keys(cqn).length === 1
              ? cqn.from
              : { SELECT: cqn } 
          const nextCqn = _convertApply(select, select.apply)
          if (Array.isArray(nextCqn)) additionalQueries.push(...nextCqn)
          else additionalQueries.push(nextCqn)
        }
        cqn = additionalQueries
      }
      
      if (Array.isArray(cqn)) return cqn
      return { SELECT: cqn }
    }
    const _setLimitOffset = val => {
      if (SELECT.limit && SELECT.limit.offset && SELECT.limit.offset.val) {
        val += SELECT.limit.offset.val
      }
      ;(SELECT.limit || (SELECT.limit = {})).offset = { val }
    }
    //Second parameter needed, to assure that order is correct
    const _setOrderBy = (appendObj, first = false) => {
      SELECT.orderBy = SELECT.orderBy
        ? first
          ? [appendObj, ...SELECT.orderBy]
          : [...SELECT.orderBy, appendObj]
        : [appendObj]
    }
    const _removeLambdaPrefix = (prefix, elements) => {
      for (const e of elements) {
        // remove the prefix identifier
        if (e.ref && e.ref[0] === prefix) e.ref.shift()
        if (e.func) _removeLambdaPrefix(prefix, e.args)
      }
      return elements
    }

    const _replaceAliasedInWhere = (where, alias, value, isFromWhere = false) =>  {
      where?.forEach(element => {
        if (element.val === alias) {
          // TODO check if we want to store replaced aliases/values for req.data in actions/functions in CQN 
          element.val = value.val
        } else if (element.list === alias) {
          element.list = value.list
        } else if (element.func) {
          element.args.forEach((arg, i) => {
            if (arg.val === alias) {
              arg.val = value.val
            } else if (arg.func) {
              _replaceAliasedInWhere(arg.args, alias, value, isFromWhere)
            }
          })
        } else if (element.SELECT) {
          _replaceAliased(element.SELECT, alias, value, isFromWhere)
        }
      });
    }
    const _replaceAliased = (select, alias, value, isFromWhere = false) =>  {
      const {where, from} = select
      _replaceAliasedInWhere(where, alias, value);

      from?.ref?.forEach(element => {
        _replaceAliasedInWhere(element.where, alias, value, true);
      })
    }
  }

// ---------- Entity Paths ---------------

  ODataRelativeURI // Note: case-sensitive!
    = '/'? (p:path { SELECT = p })
    ( o"?"o (QueryOption ( o'&'o QueryOption )*)? )? o {
      if (count) {
        // columns set because of $count: ignore $select, $expand, $top, $skip, $orderby
        // REVISIT: don't ignore query options but throw bad request (as okra did)?
        SELECT.columns = [{ args: [{ val: 1 }], as: '$count', func: 'count' }]
        delete SELECT.expand
        delete SELECT.limit
        delete SELECT.orderBy
        if (SELECT.apply)
          return _handleApply(SELECT, SELECT.apply)
        return { SELECT }
      }
      let onlyColumnsFromExpand
      if (SELECT.expand) {
        // Books?$expand=author w/o $select=author
        if (!SELECT.columns) {
          SELECT.columns = ['*']
          onlyColumnsFromExpand = true
        }
        for (const exp of SELECT.expand) {
          const idx = SELECT.columns.findIndex(_compareRefs(exp))
          if (idx > -1) SELECT.columns.splice(idx, 1)
          SELECT.columns.push(exp)
        }
        delete SELECT.expand
      }
      if (SELECT.count && SELECT.apply) 
        SELECT.__countAggregated = true
      if(SELECT.apply)
        return _handleApply(SELECT, SELECT.apply, onlyColumnsFromExpand)
      return { SELECT }
    }

  path
    = "$count" {count = true}
    / rv:$("$ref"/"$value") {return !TECHNICAL_OPTS.includes(rv) && {from: {ref: [rv]}}}
    / head:(
      (identifier filter:(OPEN CLOSE/OPEN args CLOSE)? !segment) / val:segment{return [val]}
    )? tail:((s:"/" {return s;}) path?)? {
      tail = tail && tail[1]
      if (!head && !tail) {
        return {from: {ref: ['']}}
      } else if (!head && tail && tail.from) {
        tail.from.ref.unshift('')
        return tail
      } 
      const [id, filter] = head
      // minimal: val also as path segment
      const ref = []
      if (filter) {
        if (filter.length > 2) {
          ref.push({ id, where: filter[1].map(f => f.val && f.val.match && f.val.match(/^"(.*)"$/) ? { val: f.val.match(/^"(.*)"$/)[1] } : f) })
        } else {
          ref.push({ id, where: [] })
        }
      } else {
        if (minimal) {
          ref.push(`${typeof id === 'object' && 'val' in id ? id.val : id}`)
        } else {
          // REVISIT: keep 123 as number?
          if (typeof id === 'object' && typeof id.val === 'string' && id.val.match(/^[1-9]\d*$|^0$/)) {
            ref.push({ val: safeNumber(id.val) })
          } else {
            ref.push(id)
          }
        }
      }
      if (tail && tail.from) {
        const more = tail.from.ref
        if (Object.prototype.hasOwnProperty.call(more[0], 'val')) ref[ref.length-1] = { id:ref[ref.length-1], where:[more.shift()] }
        ref.push (...more)
      }
      const res = {from: {ref}}
      if (tail && tail.columns) res.columns = tail.columns
      return res
    }

  args
    = val:val {return [val]}
    / ref:ref o"="o val:val more:( COMMA args )? {
      const args = [ ref, '=', val ]
      if (more) args.push ('and', ...more[1])
      return args
    }

//
// ---------- Query Options ------------

  QueryOption = option:ExpandOption { if(option && option.apply) SELECT.apply = option.apply} /
    "$skiptoken="   o skiptoken /
    temporal /
    format /
    custom /
    aliasedParamEqualsVal
  // @OData spec for $expand:
  // "Allowed system query options are $filter, $select, $orderby, $skip, $top, $count, $search, $expand and 
  // $apply (https://go.sap.corp/0jzs)."
  ExpandOption =
    "$select="      o select ( COMMA select )* /
    "$expand="      o expand ( COMMA expand )* expandCount? /
    "$filter="      o f:filter { SELECT.where = f } /
    "$orderby="     o o:orderby ( COMMA o2:orderby{_setOrderBy(o2)} )* {_setOrderBy(o,true)} /
    "$top="         o val:top { (SELECT.limit || (SELECT.limit={})).rows = {val} } /
    "$skip="        o val:skip { _setLimitOffset(val) } /
    "$search="      o s:search { if (s) SELECT.search = s } /
    "$count="       o count /
    "$apply="       o trafos:transformations { return trafos }

  temporal = ("$at" / "$from" / "$toInclusive" / "$to") "=" date

  select
    = col:('*' / ref) {
      SELECT.columns = Array.isArray(SELECT.columns) ? SELECT.columns : []
      if (!SELECT.columns.find(_compareRefs(col))) SELECT.columns.push(col)
      return col
    }

  expandCount 
    = "/$count" {
      const err = new Error('"/$count" is not supported for expand operation');
      err.statusCode=501;
      throw err;
    }

  expandQueryOptions
   = (
      expandOptions:(option:ExpandOption o ";"? { return option })*
      {
      	if (expandOptions.find(option => option && option.apply !== undefined)) {
        	const err = new Error('"$apply" is not supported for expand operation');
      		err.statusCode=501;
      		throw err;
        }
        if (SELECT.columns) {
          for (const col of SELECT.columns) {
            if (!SELECT.expand.find(_compareRefs(col))) SELECT.expand.push(col)
          }
          delete SELECT.columns
        } else {
          if (Array.isArray(SELECT.expand) && SELECT.expand.indexOf('*') === -1) SELECT.expand.unshift('*')
        }
      }
      )

  expandQueryOption
   = (OPEN {
        stack.push (SELECT)
        SELECT = SELECT.expand[SELECT.expand.length-1]
        SELECT.expand = []
      }) 
      expandQueryOptions? 
      (CLOSE {
        if (!SELECT.expand.length) {
          SELECT.expand.push('*') // by default expand everything
        }
        SELECT = stack.pop()
      })
    

//REVISIT: per OData spec $apply should be also supported inside of $expand
  expand
  = (
      c:('*' / ref) {
        const col = c === '*' ? {} : c
        col.expand = ['*']
        if (!Array.isArray(SELECT.expand)) SELECT.expand = []
        if (!SELECT.expand.find(_compareRefs(col))) SELECT.expand.push(col)
        return col
      }
    )
    expandQueryOption?

  top
    = val:integer { return val }

  skiptoken
    = skiptoken:skiptokenChars? {
      skipToken(skiptoken, { SELECT })
    }

  skip
    = val:integer { return val }

  search
    = p:search_clause {return p}
      / o // Do not add search property for space only

  search_clause
    = p:( n:NOT? {return n?[n]:[]} )(
      OPEN xpr:search_clause CLOSE {p.push({xpr})}
      / (
          val:doubleQuotedString {p.push({val})} /
          val:string {p.push({val})} /
          val:word {p.push({val})}
        )
    )( ao:(AND/OR/AND_SPACE) more:search_clause {p.push(ao,...more)} )*
    { return p }

  filter
    = p:where_clause { return p }

  where_clause = p:( n:NOT? {return n?[n]:[]} )(
      OPEN xpr:where_clause CLOSE {p.push({xpr})}
      / comp:comparison {p.push(...comp)}
      / lambda:lambda {
        if (p[p.length - 1] === 'not' && lambda[0] === 'not') {
          p.push('(', ...lambda, ')')
        } else {
          p.push(...lambda)
        }
      }
      / func:boolish {p.push(func)}
      / val:bool {p.push({val})}
      / list:listFilter {p.push(...list)}
    )( ao:(AND/OR) more:where_clause {p.push(ao,...more)} )*
    { return p }

  lambda =
    nav:( n:identifier {return[n]} ) '/' ( n:identifier '/' {nav.push(n)} )*
    xpr:(
      any:any {
        let id = nav.pop()
        if (!any) return ['exists', { ref: [...nav, { id }] }]
        let xpr = []
        for (let i=0, k=0; i<any.length; ++i) {
          let each = any[i]
          if (each.ref && each.ref.length === 0 && any[i+1] === '=') {
            xpr[k++] = { func:'contains', args:[{ref:[id]}, any[i+=2]] }
          } else {
            xpr[k++] = each
          }
        }
        if (xpr.length < any.length) {
          if (!nav.length) {
            // no navigation
            return xpr
          }
          id = nav.pop()
          return ['exists', { ref: [...nav, { id, where: xpr }] }]
        } else {
          return ['exists', { ref: [...nav, { id, where: any }] }]
        }
      }
      / all:all {
        let id = nav.pop()
        return ['not', 'exists', { ref: [...nav, { id, where: ['not', { xpr: [...all] }] }] }]
      }
    )
    { return xpr }

  inner_lambda =
    p:( n:NOT? { return n ? [n] : [] } )(
      OPEN xpr:inner_lambda CLOSE { p.push('(', ...xpr, ')') }
      / comp:comparison { p.push(...comp) }
      / func:function { p.push(func) }
      / lambda:lambda { p.push(...lambda)}
      / list:listFilter { p.push(...list) }
    )
    ( ao:(AND/OR) more:inner_lambda { p.push(ao, ...more) } )*
    { return p }

  lambda_clause =
    prefix:identifier ":" inner:inner_lambda {
      return _removeLambdaPrefix(prefix, inner)
    }

  any =
   "any" OPEN p:lambda_clause? CLOSE { return p }

  all =
   "all" OPEN p:lambda_clause CLOSE { return p }

  orderby
    = ref:(
        lambda {
          const err = new Error('"$orderby" does not support lambda');
          err.statusCode=501;
          throw err;
        } /
        function /
        ref
      ) 
      sort:( _ s:$("asc" / "desc") { return s })? {
        // TODO: Lambda support
        const appendObj = $(ref, sort && {sort});
        return appendObj;
    }

  count
    = val:bool { if(val) SELECT.count = true }

  transformations
    = mainTransformation:trafo additionalTransformation:("/" t2:trafo {
      return t2
    })* {
    	if(mainTransformation === undefined) return
      additionalTransformation = (Array.isArray(additionalTransformation)) ? additionalTransformation : [additionalTransformation] 
      //Loop through additionalTransformation
      //Loop through each element, add it to current level, if element is already part of result, increase level
      for(let trafos of additionalTransformation) {
        for(const trafo in trafos) {
          if (trafo === 'limit' && trafos.limit && mainTransformation.limit && mainTransformation.limit.offset && trafos.limit.rows)
            mainTransformation.limit.rows = trafos.limit.rows
          else if(
          	mainTransformation[trafo] || 
            (trafo === 'groupBy' && (mainTransformation.where || mainTransformation.search)) || 
            (trafo === 'aggregate' && 'groupBy' in mainTransformation && !('groupBy' in trafos))
          ) {
            let _apply = mainTransformation
            mainTransformation = { apply: _apply } 
            if (trafo === 'limit' && trafos[trafo].offset && _apply.limit && _apply.limit.offset && _apply.limit.offset.val)
              trafos[trafo].offset += _apply.limit.offset.val
            
            _apply = mainTransformation
            _apply[trafo] = trafos[trafo]
          } else {
            mainTransformation[trafo] = trafos[trafo]
          }
        }
      }
      return {apply: mainTransformation}
    }

  aliasedParamVal = val / jsonObject / jsonArray / "[" list:innerList "]" { return { list } }

  custom
    = [a-zA-Z0-9-_.~]+ "=" [^&]*
  aliasedParam "an aliased parameter (@param)" = "@" i:identifier { return "@" + i }
  aliasedParamEqualsVal = alias:aliasedParam "=" !aliasedParam value:aliasedParamVal {
    _replaceAliased(SELECT, alias, value);
  }

  format = "$format=" f:$([^&]*) {
    if (f.toLowerCase() !== "json") {
      const err = new Error('Only query parameter "json" is allowed in "$format".')
      err.statusCode = 501
      throw err;
    }
  }

//
// ---------- Expressions ------------
  comparison
    = a:operand _ o:$("eq" / "ne" / "lt" / "gt" / "le" / "ge") _ b:operand {
      const op = { eq:'=', ne:'!=', lt:'<', gt:'>', le:'<=', ge:'>=' }[o] || o
      return [ a, op, b ]
    }

  listFilterParam = aliased:aliasedParam { return { list: aliased } } / listRoundBrackets

  listFilter
    = a:operand _ "in" _ b:listFilterParam {
      return [ a, "in", b ]
    }

  mathCalc
    = operand (_ ("add" / "sub" / "mul" / "div" / "mod") _ operand)*
  
  operand
    = navigationCount / function / val / ref / jsonObject / jsonArray / list
  
  navigationCount "navigation with $count"
  = navigationPath:(head:identifier key:(OPEN keyArgs:args CLOSE {return keyArgs;})? '/' {
    if (key) {
      // we have key in xpr
      return {id: head, where: key}
    }
    return head;
  })+ count: '$count'
    { return {func: 'count', as: '$count', args: [{ref: navigationPath}]} }
  
  ref "a reference"
    = head:identifier tail:( '/' n:identifier {return n})*
    {
      if (head === "null") {
        return { val: null }
      }
      return { ref:[ head, ...tail ] }
    }

  val
    = val:(bool / date) {return {val}}
    / val:guid {return {val}}
    / val:number {return typeof val === 'number' ? {val} : { val, literal:'number' }}
    / val:string {return {val}}
    / val:binary {return {val}}
    / val:aliasedParam {return {val}}
    / null

  null "null" =  "null" {return {val: null }}
  
  // REVISIT why not JSON.parse() and return JS object?
  jsonObject "a json object"
    = val:$("{" (jsonObject / [^}])* "}") {return {val}}
  
  // REVISIT why not JSON.parse() and return JS array?
  jsonArray "a json array"
    = val:$("[" o "]" / "[" o "{" (jsonArray / [^\]])* "]") {return {val}}

  // REVISIT: only used for contains(identifier, ["searchterm"]) <- use innerList instead?
  list "a list"
    = "[" any:$([^\]])* "]" // > needs improvment
    { return { list: any.replace(/"/g,'').split(',').map(ele => ({ val: ele })) } }

  innerList = (val1:val val2:("," v:val { return v })* { return [val1, ...val2] })

  listRoundBrackets "a list"
    = OPEN list:innerList CLOSE // > needs improvment
    { return {list} }

  
  functionName "a function name"
  = $[a-zA-Z]+

  function 
    = func:functionName OPEN args:functionArgs CLOSE {
      if (strict && !(func.toLowerCase() in strict.functions)) {
        throw Object.assign(new Error(`"${func}" is an unknown function in OData URL spec (strict mode)`), { statusCode: 400 })
      }
      return { func: func.toLowerCase(), args }
    }

  functionArgs
    = args:(a:operand more:( COMMA o:operand { return o } )* { return [ a, ...more ] })* { return args.length ? args[0] : args }

  boolish
    = func:("contains"i/"endswith"i/"startswith"i) OPEN a:operand COMMA b:operand CLOSE
    { return { func: func.toLowerCase(), args:[a,b] }}

  NOT = o "NOT"i _ {return 'not'}
  AND = _ "AND"i _ {return 'and'}
  AND_SPACE =    _ {return 'and'}
  OR  = _  "OR"i _ {return 'or'}


//
// ---------- Transformations ------------
// Odata spec: http://docs.oasis-open.org/odata/odata-data-aggregation-ext/v4.0/odata-data-aggregation-ext-v4.0.html

  trafo
    = (
      "aggregate" agg:aggregateTrafo{return agg} /
      "groupby" group:groupbyTrafo{return group} /
      "filter" filter:filterTrafo{return filter} /

      // REVISIT: All transformations below need improvment
      "search" search:searchTrafo{return search} /
      "concat" con:concatTrafo{return con} / //Return con so that concat string is not returned
      "compute" compute:computeTrafo{return compute} /
      "top" top:topTrafo{return top} /
      "skip" skip:skipTrafo{return skip} /
      "orderby" order:orderbyTrafo{return order} /
      func:("topcount"i/"bottomcount"i/"topsum"i/"bottomsum"i/"toppercent"i/"bottompercent"i) args:commonFuncTrafo {
        const SUPPORTED_APPLY_TRANSFORMATIONS = {
          "topcount": true,
          "bottomcount": true,
          "topsum": false,
          "bottomsum": false,
          "toppercent": false,
          "bottompercent": false
        }
        func = func.toLowerCase()
        if (!SUPPORTED_APPLY_TRANSFORMATIONS[func]) {
          throw Object.assign(new Error(`Transformation "${func}" in $apply is not yet supported.`), { statusCode: 501 })
        }        
        return {aggregate: [{ func, args }]}
      } /
      identity: identityTrafo {return identity}
      // customFunction
    )

  aggregateTrafo
    = OPEN o head:aggregateItem tail:(o COMMA o p:aggregateItem {return p})* o CLOSE {
      let response = {aggregate: [head,...tail]}
      return response
    }
  aggregateItem
    = res:("$count" as:asAlias { return { func: 'count', args: [{ val: 1 }], as } }
           / aggregateExpr
          ) { return res }
  aggregateExpr
    = path:(
        ref
     // / mathCalc - needs CAP support
      )
      func:aggregateWith? aggregateFrom? as:asAlias?
        { return { func, args: [ path ], as } }
      / identifier OPEN aggregateExpr CLOSE // needs CAP support
   // / customAggregate // needs CAP support
  aggregateWith
    = _ "with" _ func:$[a-zA-Z]+ { return func.toLowerCase(); }
  aggregateFrom
    = _ "from" _ ref aggregateWith aggregateFrom? // needs CAP support
  asAlias
    = _ "as" _ alias:identifier { return alias; }

  groupbyTrafo
    = OPEN OPEN head:groupByElem tail:(COMMA p:groupByElem {return p})* (CLOSE {
      
      return { groupBy: [head, ...tail] }
    }) trafos:(COMMA t:transformations {return t})? CLOSE {
    	  let apply = {}
        apply = (trafos) ? {groupBy: [head, ...tail], ...trafos.apply} : {groupBy: [head, ...tail]} 
        return apply
    }
  groupByElem
    = c:(rollupSpec / ref) { return c }
  rollupSpec // TODO fix this + add CAP support
    = rollup:("rollup" OPEN o ('$all' / ref) (o COMMA ref)+ o CLOSE) {
        const err = new Error("Rollup in groupby is not supported yet.");
        err.statusCode=501;
        throw err;
      }

  filterTrafo = OPEN o where:(where:filter{
    return where
  }) o CLOSE {
  	return {where: where}
  }

  searchTrafo = OPEN o search:(search:search{
    if (!search) return
    return search
  }) o CLOSE {
    return {search: search}
  }

  concatTrafo = OPEN o trafo1:transformations trafo2:(o COMMA o trafos:transformations{ return trafos })+ o CLOSE {
    return {concat: [trafo1, ...trafo2]}
  }

  // REVISIT: support compute - current implementation is deviating from odata
  computeTrafo = OPEN o computeExpr (o COMMA o computeExpr)* o CLOSE

  computeExpr = where_clause asAlias

  commonFuncTrafo = OPEN o first:operand o COMMA o second:operand o CLOSE { return [first, second] }

  // REVISIT: support identity
  identityTrafo = "identity" {return {identity: true }}

  topTrafo
    = OPEN o val:top o CLOSE {
      return {limit: {rows: {val}}}
    }

  skipTrafo
    = OPEN o val:skip o CLOSE {
      return {limit: {offset: {val}}}
    }

  orderbyTrafo
    = OPEN o o:orderby o2:( COMMA o2:orderby{return o2} )* o CLOSE {
      return {orderBy: [o,...o2]}
    }
//
// ---------- Literals -----------

  bool "a boolean"
    = b:("true" / "false") { return b === 'true'}

  string "a single quoted string" // "Edm.String"
    = "'" s:$("''" / [^'])* "'" // 'A user''s story'
    {return s.replace(/''/g,"'")}

  doubleQuotedString "a doubled quoted string"
    = '"' s:$('\\"'/[^"])* '"'
    {return s.replace(/\\\\/g,"\\").replace(/\\"/g,'"')}

  word "a string"
    = $([^ \t\n()"&;]+)

  date "a date"
    = s:$( [0-9]+"-"[0-9][0-9]"-"[0-9][0-9] // date
      ( "T"[0-9][0-9]":"[0-9][0-9](":"[0-9][0-9]("."[0-9]+)?)? // time
      ( "Z" / (("+" / "-")[0-9][0-9]":"[0-9][0-9]) )? // timezone (Z or +-hh:mm)
    )?) {
      if (s.split('-')[0].length > 4)
        throw Object.assign(new Error(`The type 'Edm.DateTimeOffset' is not compatible with '${s}'`), { statusCode: 400 })
      return s
    }

  // to avoid 123-123-123 being matched as number and showing error for "-123-123"
  endsWithMinus
    = [0-9]+ "-"

  number "a number"
    = !endsWithMinus s:$( [+-]? [0-9]+ ("."[0-9]+)? ("e"[0-9]+)? ) { return safeNumber(s) }

  integer "an integer"
    = s:$( [+-]? [0-9]+ ) { return parseInt(s) }

  identifier "an identifier"
    = !bool !guid s:$([_a-zA-Z][_a-zA-Z0-9"."]*) { return s }

  guid "a guid"
    = $( hex16 hex16 "-"? hex16 "-"? hex16 "-"? hex16 "-"? hex16 hex16 hex16 )

  hex16 "a hex value"
    = $( [0-9a-fA-F][0-9a-fA-F][0-9a-fA-F][0-9a-fA-F] )

  segment // > everything except / and ?
    = val:$( [^/?]+ ) { return { val } }

  skiptokenChars
    = $( [a-zA-Z0-9-"."_~!$'()*+,;=:@"/""?"]+ )

  binary "a binary" // > url-safe base64
    = "binary'" s:$([a-zA-Z0-9-_]+ ("=="/"=")?) "'" { return standardBase64(s) }

//
// ---------- Punctuation ----------

  COLON = o":"o
  COMMA = o","o
  SEMI  = o";"o
  OPEN  = o"("o
  CLOSE = o")"

//
// ---------- Whitespaces -----------

  o "an optional whitespace" = $[ \t\n]*
  _ "a whitespace" = $[ \t\n]+

//
// ------------------------------------
