const cds = require('../cds')
const LOG = cds.log('remote')

const { resolveView, getTransition, restoreLink, findQueryTarget } = require('../common/utils/resolveView')
const { postProcess } = require('../common/utils/postProcessing')
const { getKind, run, getDestination, getAdditionalOptions, getReqOptions } = require('./utils/client')
const { formatVal } = require('../../odata/utils')
const { hasAliasedColumns } = require('./utils/data')

let _cloudSdkConnectivity
const cloudSdkConnectivity = () => {
  if (_cloudSdkConnectivity) return _cloudSdkConnectivity
  // eslint-disable-next-line cds/no-missing-dependencies -- needs to be added by app dev
  _cloudSdkConnectivity = require('@sap-cloud-sdk/connectivity')
  return _cloudSdkConnectivity
}

const _isSimpleCqnQuery = q => typeof q === 'object' && q !== null && !Array.isArray(q) && Object.keys(q).length > 0

const _setHeaders = (defaultHeaders, req) => {
  return Object.assign(
    defaultHeaders,
    Object.keys(req.headers).reduce((acc, cur) => {
      acc[cur.toLowerCase()] = req.headers[cur]
      return acc
    }, {})
  )
}

const _setCorrectValue = (el, data, params, kind) => {
  return typeof data[el] === 'object' && kind !== 'odata-v2'
    ? JSON.stringify(data[el])
    : formatVal(data[el], el, { elements: params }, kind)
}

// v4: builds url like /function(p1=@p1,p2=@p2,p3=@p3)?@p1=val&@p2={...}&@p3=[...]
// v2: builds url like /function?p1=val1&p2=val2 for functions and actions
const _buildPartialUrlFunctions = (url, data, params, kind = 'odata-v4') => {
  const funcParams = []
  const queryOptions = []

  // REVISIT: take params from params after importer fix (the keys should not be part of params)
  for (const param in _extractParamsFromData(data, params)) {
    if (kind === 'odata-v2') {
      funcParams.push(`${param}=${_setCorrectValue(param, data, params, kind)}`)
    } else {
      funcParams.push(`${param}=@${param}`)
      queryOptions.push(`@${param}=${_setCorrectValue(param, data, params, kind)}`)
    }
  }

  return kind === 'odata-v2'
    ? `${url}?${funcParams.join('&')}`
    : `${url}(${funcParams.join(',')})?${queryOptions.join('&')}`
}

const _extractParamsFromData = (data, params = {}) => {
  return Object.keys(data).reduce((res, el) => {
    if (params[el]) Object.assign(res, { [el]: data[el] })
    return res
  }, {})
}

const _buildKeys = (req, kind) => {
  const keys = []

  if (req.params && req.params.length > 0) {
    const p1 = req.params[0]
    if (typeof p1 !== 'object') return [p1]

    for (const key in req.target.keys) {
      keys.push(`${key}=${formatVal(p1[key], key, req.target, kind)}`)
    }
  } else {
    // REVISIT: shall we keep that or remove it?
    for (const key in req.target.keys) {
      keys.push(`${key}=${formatVal(req.data[key], key, req.target, kind)}`)
    }
  }

  return keys
}

const _handleBoundActionFunction = (srv, def, req, url) => {
  if (def.kind === 'action') {
    return srv.post(url, def.params ? _extractParamsFromData(req.data, def.params) : {})
  }

  if (def.params) {
    const data = _extractParamsFromData(req.data, def.params)
    url = _buildPartialUrlFunctions(url, data, def.params)
  } else url = `${url}()`

  return srv.get(url)
}

const _handleUnboundActionFunction = (srv, def, req, event) => {
  if (def.kind === 'action') {
    // REVISIT: only for "rest" unbound actions/functions, we enforce axios to return a buffer
    // required by cds-mt
    const isBinary =
      srv.kind === 'rest' &&
      def &&
      def.returns &&
      (def.returns.type === 'cds.LargeBinary' || def.returns.type === 'cds.Binary')

    return srv.send({ method: 'POST', path: `/${event}`, data: req.data, _binary: isBinary })
  }

  const url =
    Object.keys(req.data).length > 0 ? _buildPartialUrlFunctions(`/${event}`, req.data, def.params) : `/${event}()`
  return srv.get(url)
}

const _sendV2RequestActionFunction = (srv, def, url) => {
  return def.kind === 'function'
    ? srv.send({ method: 'GET', path: url, _returnType: def.returns })
    : srv.send({ method: 'POST', path: url, data: {}, _returnType: def.returns })
}

const _handleV2ActionFunction = (srv, def, req, event, kind) => {
  const url =
    Object.keys(req.data).length > 0 ? _buildPartialUrlFunctions(`/${event}`, req.data, def.params, kind) : `/${event}`
  return _sendV2RequestActionFunction(srv, def, url)
}

const _handleV2BoundActionFunction = (srv, def, req, event, kind) => {
  const params = []
  const data = req.data

  // REVISIT: take params from def.params, after importer fix (the keys should not be part of params)
  for (const param in _extractParamsFromData(req.data, def.params)) {
    params.push(`${param}=${formatVal(data[param], param, { elements: def.params }, kind)}`)
  }

  const keys = _buildKeys(req, this.kind)
  if (keys.length === 1 && typeof req.params[0] !== 'object') {
    params.push(`${Object.keys(req.target.keys)[0]}=${keys[0]}`)
  } else {
    params.push(...keys)
  }

  const url = `${`/${event}`}?${params.join('&')}`
  return _sendV2RequestActionFunction(srv, def, url)
}

const _addHandlerActionFunction = (srv, def, target) => {
  const event = def.name.match(/\w*$/)[0]

  if (target) {
    srv.on(event, target, async function (req) {
      const shortEntityName = req.target.name.replace(`${this.namespace}.`, '')
      if (this.kind === 'odata-v2') return _handleV2BoundActionFunction(srv, def, req, event, this.kind)
      const url = `/${shortEntityName}(${_buildKeys(req, this.kind).join(',')})/${this.namespace}.${event}`
      return _handleBoundActionFunction(srv, def, req, url)
    })

    return
  }

  srv.on(event, async function (req) {
    if (this.kind === 'odata-v2') return _handleV2ActionFunction(srv, def, req, event, this.kind)
    return _handleUnboundActionFunction(srv, def, req, event)
  })
}

const _selectOnlyWithAlias = q => q?.SELECT && !q.SELECT._transitions && q.SELECT?.columns?.some(hasAliasedColumns)

const resolvedTargetOfQuery = q => {
  const transitions = (typeof q === 'object' && (q.SELECT || q.INSERT || q.UPDATE || q.DELETE)._transitions) || []
  return transitions.length && [transitions.length - 1].target
}

let logged
let sdkLoggerDisabled

const _resolveSelectionStrategy = options => {
  if (typeof options?.selectionStrategy !== 'string') return
  options.selectionStrategy = cloudSdkConnectivity().DestinationSelectionStrategies[options.selectionStrategy]

  if (typeof options?.selectionStrategy !== 'function') {
    throw new Error(`Unsupported destination selection strategy "${options.selectionStrategy}".`)
  }
}

class RemoteService extends cds.Service {
  init() {
    this.kind = getKind(this.options) // TODO: Simplify

    /*
     * set up connectivity stuff if credentials are provided
     * throw error if no credentials are provided and the service has at least one entity or one action/function
     */
    if (this.options.credentials) {
      this.datasource = this.options.datasource
      this.destinationOptions = this.options.destinationOptions
      _resolveSelectionStrategy(this.destinationOptions)
      this.destination =
        this.options.credentials.destination ??
        getDestination(this.definition?.name ?? this.datasource, this.options.credentials)
      this.path = this.options.credentials.path

      this.requestTimeout = this.options.credentials.requestTimeout
      if (this.requestTimeout == null) this.requestTimeout = 60000

      // REVISIT: remove cds.env.features.fetch_csrf in next major ^7
      this.csrf = cds.env.features.fetch_csrf ?? this.options.csrf
      this.csrfInBatch = this.options.csrfInBatch
      if (cds.env.features.fetch_csrf && !logged) {
        // for logging once for all remote services
        logged = true
        LOG._warn &&
          LOG.warn(
            'Configuration option "cds.env.features.fetch_csrf" is deprecated.\n Please use "csrf"/"csrfInBatch" as described in https://cap.cloud.sap/docs/node.js/remote-services'
          )
      }

      // REVISIT: use cds.log's logger in cloud sdk

      // disable sdk logger if not in debug mode
      if (!LOG._debug && !sdkLoggerDisabled) {
        try {
          // eslint-disable-next-line cds/no-missing-dependencies -- needs to be added by app dev
          const sdkUtils = require('@sap-cloud-sdk/util')
          sdkUtils.setGlobalLogLevel('error')

          // disable sdk logger once
          sdkLoggerDisabled = true
        } catch (err) {
          /* might fail in cds repl due to winston's exception handler, see cap/issues#10134 */
        }
      }
    } else if ([...this.entities].length || [...this.operations].length) {
      throw new Error(`No credentials configured for "${this.name}".`)
    }

    const clearKeysFromData = function (req) {
      if (req.target && req.target.keys) for (const k of Object.keys(req.target.keys)) delete req.data[k]
    }
    this.before('UPDATE', '*', Object.assign(clearKeysFromData, { _initial: true }))

    for (const each of this.entities) {
      for (const a in each.actions) {
        _addHandlerActionFunction(this, each.actions[a], each)
      }
    }

    for (const each of this.operations) {
      _addHandlerActionFunction(this, each)
    }

    this.on('*', async (req, next) => {
      const { query } = req
      if (!query && !(typeof req.path === 'string')) return next()

      const resolvedTarget = resolvedTargetOfQuery(query) || getTransition(req.target, this).target
      const reqOptions = getReqOptions(req, query, this)
      reqOptions.headers = _setHeaders(reqOptions.headers, req)
      const returnType = req._returnType
      const additionalOptions = getAdditionalOptions(
        req,
        this.destination,
        this.kind,
        resolvedTarget,
        returnType,
        this.destinationOptions,
        this.csrf,
        this.csrfInBatch
      )

      // hidden compat flag in order to suppress logging response body of failed request
      if (req._suppressRemoteResponseBody) {
        additionalOptions.suppressRemoteResponseBody = req._suppressRemoteResponseBody
      }

      let result = await run(reqOptions, additionalOptions)
      result = typeof query === 'object' && query.SELECT?.one && Array.isArray(result) ? result[0] : result
      return result
    })
  }

  // FIXME: This is a dirty hack for this situation:
  // - This PR has cds.Service.model setter to always consistently apply cds.compile.for.odata, also for RemoteServices, which wasn't the case before
  // - because of that tests/_runtime/remote/__tests__/integration/odata.test.js fails, which relies on the former behavoir of RemoteServices
  // NOTE: that test would never have worked for RemoteServices bootstrapped from single cds.model, which is always cds.compiled.for.odata
  // REVISIT: should become obsolete with Universal CSN
  // set model(m) {
  //   const fn = cds.compile.for.odata
  //   try {
  //     cds.compile.for.odata = m => m
  //     super.model = m
  //   } finally {
  //     cds.compile.for.odata = fn
  //   }
  // }

  // Overload .handle in order to resolve projections up to a definition that is known by the remote service instance.
  // Result is post processed according to the inverse projection in order to reflect the correct result of the original query.
  async handle(req) {
    // compat mode
    if (req._resolved || cds.env.features.resolve_views === false) return super.handle(req)

    if (req.target && req.target.name && this.definition && req.target.name.startsWith(this.definition.name + '.')) {
      const result = await super.handle(req)
      // only post process if alias was explicitly set in query
      if (_selectOnlyWithAlias(req.query)) {
        return postProcess(req.query, result, this, true)
      }
      return result
    }

    // req.query can be:
    // - empty object in case of unbound action/function
    // - undefined/null in case of plain string queries
    if (_isSimpleCqnQuery(req.query) && this.model) {
      const q = resolveView(req.query, this.model, this)
      const t = findQueryTarget(q) || req.target

      // compat
      restoreLink(req)

      // REVISIT: We need to provide target explicitly because it's cached already within ensure_target
      const newReq = new cds.Request({ query: q, target: t, headers: req.headers, _resolved: true, method: req.method })
      const result = await super.dispatch(newReq)
      return postProcess(q, result, this, true)
    }

    return super.handle(req)
  }
}

RemoteService.prototype.isExternal = true
module.exports = RemoteService
