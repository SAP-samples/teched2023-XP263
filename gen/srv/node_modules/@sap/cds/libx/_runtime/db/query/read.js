const { timestampToISO } = require('../data-conversion/timestamp')
const { deepCopyObject } = require('../../common/utils/copy')
const getError = require('../../common/error')

function _arrayWithCount(a, count) {
  const _map = a.map
  const map = (..._) => _arrayWithCount(_map.call(a, ..._), count)
  return Object.defineProperties(a, {
    $count: { value: count, enumerable: false, configurable: true, writable: true },
    map: { value: map, enumerable: false, configurable: true, writable: true }
  })
}

function _createCountQuery(query) {
  // REVISIT: Use query.clone() instead
  let _query = { SELECT: deepCopyObject(query.SELECT) }
  delete _query.SELECT.orderBy // not necessary to keep that
  delete _query.SELECT.limit
  // Also change columns in sub queries
  if (_query.SELECT.from.SET) {
    _query.SELECT.from.SET.args.forEach(subCountQuery => {
      subCountQuery.SELECT.columns = [{ val: 1 }]
    })
  }
  if (query.SELECT.__countAggregated) {
    _query = SELECT.from(_query)
  }
  _query.SELECT.columns = [{ func: 'count', args: [{ val: 1 }], as: '$count' }]
  if (query.SELECT._4odata) _query.SELECT._4odata = true
  return _query
}

const countValue = countResults => {
  if (!countResults.length) return 0
  const countResult = countResults[0]
  if (countResult._counted_ != null) return countResult._counted_
  if (countResult.$count != null) return countResult.$count
}

const read = (executeSelectCQN, executeStreamCQN) => (model, dbc, query, req) => {
  const { user, locale, timestamp } = req
  const isoTs = timestampToISO(timestamp)

  if (query._streaming) {
    if (!query.SELECT || (query.SELECT && !query.SELECT.columns)) {
      throw getError(500, 'Invalid SELECT statement for streaming')
    }
    return executeStreamCQN(model, dbc, query, user, locale, isoTs)
  }

  // needed in case of expand
  if (query._target !== req.target) query._target = req.target

  if (query.SELECT.count) {
    if (query.SELECT.limit) {
      const countQuery = _createCountQuery(query)
      const countResultPromise = executeSelectCQN(model, dbc, countQuery, user, locale, isoTs)
      if (query.SELECT.limit.rows && query.SELECT.limit.rows.val === 0) {
        // We don't need to perform our result query
        return countResultPromise.then(countResults => _arrayWithCount([], countValue(countResults)))
      } else {
        const resultPromise = executeSelectCQN(model, dbc, query, user, locale, isoTs)
        return Promise.all([countResultPromise, resultPromise]).then(([countResults, result]) =>
          _arrayWithCount(result, countValue(countResults))
        )
      }
    } else {
      return executeSelectCQN(model, dbc, query, user, locale, isoTs).then(result =>
        _arrayWithCount(result, result.length)
      )
    }
  }

  return executeSelectCQN(model, dbc, query, user, locale, isoTs)
}

module.exports = read
