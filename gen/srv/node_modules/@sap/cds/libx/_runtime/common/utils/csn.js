const cds = require('../../cds')
const resolveStructured = require('../../common/utils/resolveStructured')

const getEtagElement = entity => {
  return Object.values(entity.elements).find(element => element['@odata.etag'])
}

const getComp2oneParents = (entity, model) => {
  if (!entity) return []
  return _getUps(entity, model).filter(element => element.is2one && element.isComposition)
}

const setEntityContained = (entity, model, isContained) => {
  if (!entity || entity.kind !== 'entity') return entity
  if ('_isContained' in entity && !isContained) return entity
  if ('_isContained' in entity) delete entity._isContained
  return Object.defineProperty(entity, '_isContained', {
    get() {
      return (
        isContained ||
        !!_getUps(entity, model).find(element => element._isContained && element.parent.name !== entity.name)
      )
    },
    configurable: true
  })
}

const _getUps = (entity, model) => {
  if (entity.own('__parents')) return entity.__parents
  const ups = []
  for (const def of Object.values(model.definitions)) {
    if (def.kind !== 'entity' || !def.associations) continue
    for (const element of Object.values(def.associations)) {
      if (element.target !== entity.name || element._isBacklink) continue
      if (element.name === 'SiblingEntity') continue
      ups.push(element)
    }
  }
  return entity.set('__parents', ups)
}

const _ifDataSubject = (entity, role) => {
  return entity['@PersonalData.EntitySemantics'] === 'DataSubject' && entity['@PersonalData.DataSubjectRole'] === role
}

const _getDataSubjectUp = (role, model, entity, prev, next, result) => {
  for (const element of _getUps(entity, model)) {
    const me = { entity, relative: element.parent, element }
    if (prev) prev.next = me
    if (_ifDataSubject(element.parent, role)) {
      if (!result) result = { dataSubjectEntity: element.parent, subs: [] }
      result.subs.push(next || me)
      return result
    } else {
      // dfs is a must here
      result = _getDataSubjectUp(role, model, element.parent, me, next || me, result)
    }
  }
  return result
}

const _getDataSubjectDown = (role, entity, prev, next) => {
  const associations = Object.values(entity.associations || {}).filter(e => !e._isBacklink)
  for (const element of associations) {
    const me = { entity, relative: entity, element }
    if (_ifDataSubject(element._target, role)) {
      if (prev) prev.next = me
      return { dataSubjectEntity: element._target, subs: [next || me] }
    }
  }
  // bfs makes more sense here
  for (const element of associations) {
    const me = { entity, relative: entity, element }
    if (prev) prev.next = me
    const dataSubject = _getDataSubjectDown(role, element._target, me, next || me)
    if (dataSubject) return dataSubject
  }
}

const getDataSubject = (entity, model, role) => {
  const hash = '__dataSubject4' + role
  if (entity.own(hash)) return entity[hash]
  // entities with EntitySemantics 'DataSubjectDetails' or 'Other' must not necessarily
  // be always below or always above 'DataSubject' entity in CSN tree
  let dataSubject = _getDataSubjectUp(role, model, entity)
  if (!dataSubject) {
    dataSubject = _getDataSubjectDown(role, entity)
  }
  return entity.set(hash, dataSubject)
}

const _resolve = (edmName, model, namespace) => {
  const resolved = model._edmToCSNNameMap[namespace][edmName.replace(/\./g, '_')]
  // the edm name has an additional suffix 'Parameters' in case of views with parameters
  if (!resolved && edmName.endsWith('Parameters')) {
    const viewWithParam = model._edmToCSNNameMap[namespace][edmName.replace(/Parameters$/, '').replace(/\./g, '_')]
    if (!viewWithParam || !viewWithParam.params) return
    return viewWithParam
  }
  return resolved
}

const _findCsnTarget = (edmName, model, namespace) => {
  let target = _resolve(edmName, model, namespace)
  if (target) return target

  if (!cds.env.effective.odata.structs) return

  // navigation to structured like `StructuredTypes_structured_nested_` (edmx)
  const parts = edmName.split('_')
  let i = parts.length
  let name = edmName
  while (!target && i > 1) {
    // Traverse to find the longest entity name.
    // All weird namings with `.` and `_` are already covered by cache.
    name = name.replace(/_[^_]*$/, '')
    target = _resolve(name, model, namespace)
    i--
  }
  // something left in navigation path => resolving within found entity
  if (i > 0 && target) {
    const left = parts.slice(i - parts.length)
    while (target && left.length) {
      let elm = left.shift()
      while (!target.elements[elm]) elm = `${elm}_${left.shift()}`
      target = target.elements[elm]
    }
  }
  return target
}

const _initializeCache = (model, namespace) => {
  const cache = {}
  for (const name in model.definitions) {
    // do no cache entities within different namespace
    if (!name.startsWith(`${namespace}.`)) continue
    // cut off namespace and underscoreify entity name (OData does not allow dots)
    cache[name.replace(new RegExp(`^${namespace}\\.`), '').replace(/\./g, '_')] = model.definitions[name]
  }
  return cache
}

const findCsnTargetFor = (edmName, model, namespace) => {
  const cache = model._edmToCSNNameMap || (model._edmToCSNNameMap = {})
  const edm2csnMap = cache[namespace] || (cache[namespace] = _initializeCache(model, namespace))

  if (edm2csnMap[edmName]) return edm2csnMap[edmName]

  const target = _findCsnTarget(edmName, model, namespace)

  // remember edm <-> csn
  if (target && !edm2csnMap[edmName]) {
    edm2csnMap[edmName] = target
  }

  return edm2csnMap[edmName]
}

const getElementDeep = (entity, ref) => {
  let current = entity
  for (const r of ref) {
    current = current && current.elements && current.elements[r]
  }
  return current
}

const _setAlias2ref = entity => {
  const _ref2alias = {}
  const _alias2ref = {}
  const keys = entity.keys
  for (const key in keys) {
    const structKeys = resolveStructured({ element: keys[key], structProperties: [] }, false, true)
    for (const structKey of structKeys) {
      if (_alias2ref[structKey.key] != null) {
        // key clash, aliasing not possible
        return entity
      }
      _alias2ref[structKey.key] = structKey.resolved
      _ref2alias[structKey.resolved.join('/')] = key
    }
  }
  entity._alias2ref = Object.defineProperty(_alias2ref, '__2alias', { value: _ref2alias, configurable: true })
  return entity
}

function _alias2RefRest(service) {
  for (const each of service.entities) {
    _setAlias2ref(each)
  }
}

const prefixForStruct = element => {
  const prefixes = []
  let parent = element.parent
  while (parent && parent.kind !== 'entity') {
    prefixes.push(parent.name)
    parent = parent.parent
  }
  return prefixes.length ? prefixes.reverse().join('_') + '_' : ''
}

function alias2ref(service, edm) {
  if (!edm) {
    return _alias2RefRest(service)
  }
  const defs = edm[service.definition.name]
  for (const each of service.entities) {
    const def = defs[each.name.replace(service.definition.name + '.', '').replace(/\./g, '_')]
    if (!def || !def.$Key || def.$Key.every(ele => typeof ele === 'string')) continue
    each._alias2ref = Object.defineProperty({}, '__2alias', { value: {}, configurable: true })
    for (const mapping of def.$Key.filter(ele => typeof ele !== 'string')) {
      for (const [key, value] of Object.entries(mapping)) {
        each._alias2ref[key] = value.split('/')
        each._alias2ref.__2alias[value] = key
      }
    }
  }
}

function getDraftTreeRoot(entity, model) {
  if (entity.own('__draftTreeRoot')) return entity.__draftTreeRoot

  let parent
  let current = entity
  while (current && !current['@Common.DraftRoot.ActivationAction']) {
    const parents = []
    for (const k in model.definitions) {
      const e = model.definitions[k]
      if (e.kind !== 'entity' || !e.compositions) continue
      for (const c in e.compositions)
        if (
          e.compositions[c].target === current.name ||
          e.compositions[c].target === current.name.replace(/\.drafts/, '')
        )
          parents.push(e)
    }
    if (parents.length > 1 && parents.some(p => p !== parents[0])) {
      // > unable to determine single parent
      parent = undefined
      break
    }
    current = parent = parents[0]
  }

  return entity.set('__draftTreeRoot', parent)
}

module.exports = {
  getEtagElement,
  findCsnTargetFor,
  getElementDeep,
  getDataSubject,
  alias2ref,
  getComp2oneParents,
  prefixForStruct,
  getDraftTreeRoot,
  setEntityContained
}
