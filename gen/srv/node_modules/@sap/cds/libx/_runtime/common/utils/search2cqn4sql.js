const { computeColumnsToBeSearched } = require('../../../../libx/_runtime/cds-services/services/utils/columns')
const searchToLike = require('./searchToLike')
const { getEntityNameFromCQN } = require('./entityFromCqn')

const _targetFrom = (cqn, options) => {
  if (options && options.entityName) return options
  return getEntityNameFromCQN(cqn)
}

// convert $search system query option to WHERE/HAVING clause using
// the operator LIKE or CONTAINS
const search2cqn4sql = (query, model, options = {}) => {
  const cqnSearchPhrase = query.SELECT.search
  if (!cqnSearchPhrase) return
  const { search2cqn4sql } = options
  const { entityName, alias } = _targetFrom(query.SELECT.from, options)
  const entity = model.definitions[entityName]
  const localizedAssociation = entity.associations?.localized
  // Call custom (optimized search to cqn for sql implementation) that tries
  // to optimize the search behavior for a specific database service.
  // REVISIT: $search query option combined with $count is not currently optimized
  if (
    typeof search2cqn4sql === 'function' &&
    !query.SELECT.count &&
    localizedAssociation &&
    !(query._aggregated || /* new parser */ query.SELECT.groupBy)
  ) {
    const search2cqnOptions = { columns: computeColumnsToBeSearched(query, entity), locale: options.locale }
    return search2cqn4sql(query, entity, search2cqnOptions)
  } else {
    const columnsToBeSearched = computeColumnsToBeSearched(query, entity, alias)
    const expression = columnsToBeSearched?.length
      ? searchToLike(cqnSearchPhrase, columnsToBeSearched)
      : [{ val: 0 }, '=', { val: 1 }]

    // REVISIT: find out here if where or having must be used
    query._aggregated || /* if new parser */ query.SELECT.groupBy ? query.having(expression) : query.where(expression)
  }
}

module.exports = search2cqn4sql
