const { where2obj } = require('./cqn')
const { deepCopyArray } = require('./copy')
const { getOnCond } = require('./generateOnCond')

function _getOnCondElements(onCond, onCondElements = []) {
  const andIndex = onCond.indexOf('and')

  const ref0 = onCond[0].ref
  const ref1 = onCond[2].ref

  let entityRef, targetRef
  if (ref0 && ref0[0] === 'target') {
    targetRef = ref0
    entityRef = ref1
  } else if (ref1 && ref1[0] === 'target') {
    targetRef = ref1
    entityRef = ref0
  }

  const entityKey = entityRef && entityRef.slice(1).join('.')
  const targetKey = targetRef && targetRef.slice(1).join('.')
  onCondElements.push({ entityKey, targetKey })

  if (andIndex !== -1) {
    _getOnCondElements(onCond.slice(andIndex + 1), onCondElements)
  }
  return onCondElements
}

function _mergeWhere(base, additional) {
  if (additional?.length) {
    // copy where else query will be modified
    const whereCopy = deepCopyArray(additional)
    if (base.length > 0) base.push('and')
    base.push(...whereCopy)
  }
  return base
}

function _modifyWhereWithNavigations(where, newWhere, entityKey, targetKey) {
  _mergeWhere(newWhere, where)

  newWhere.forEach(element => {
    if (element.ref && element.ref[0] === targetKey) {
      element.ref = [entityKey]
    }
  })
}

function _buildWhereForNavigations(ref, newWhere, model, target) {
  const currentRef = ref[0]
  const nextRef = ref[1]

  if (nextRef) {
    const csnEntity = target || model.definitions[currentRef.id || currentRef]
    const navigationElement = csnEntity && csnEntity.elements[nextRef.id || nextRef]

    if (!navigationElement || !navigationElement.on) return

    const onCond = getOnCond(navigationElement, [], { select: 'source', join: 'target' })
    const nextKeys = _getOnCondElements(onCond[0].xpr)

    // only add where once in _modifyWhereWithNavigations
    let whereAdded = false
    for (const key of nextKeys) {
      const targetKeyElement = navigationElement._target.elements[key.entityKey]

      if (targetKeyElement && (targetKeyElement.isAssociation || targetKeyElement._foreignKey4)) {
        _modifyWhereWithNavigations(!whereAdded && currentRef.where, newWhere, key.entityKey, key.targetKey, whereAdded)
        whereAdded = true
      }
    }
    _buildWhereForNavigations(ref.slice(1), newWhere, model, navigationElement._target)
  }
}

function _getWhereFromInsert(query, target, model) {
  const where = []
  if (query.INSERT.into.ref && query.INSERT.into.ref.length > 1) {
    _buildWhereForNavigations(query.INSERT.into.ref, where, model)
  }
  return where
}

function _getWhereFromUpdate(query, target, model) {
  if (query.UPDATE.entity.ref && query.UPDATE.entity.ref.length > 1) {
    const where = []
    _buildWhereForNavigations(query.UPDATE.entity.ref, where, model)

    return where
  }

  const where = query.UPDATE.where || []
  if (query.UPDATE.entity.ref?.length === 1 && query.UPDATE.entity.ref[0].where)
    return _mergeWhere(query.UPDATE.entity.ref[0].where, where)
  return where
}

// params: data, req, service/tx
function enrichDataWithKeysFromWhere(data, { query, target }, { model }) {
  if (query.INSERT) {
    const where = _getWhereFromInsert(query, target, model)
    if (!where || !where.length) return
    if (!Array.isArray(data)) data = [data]
    for (const d of data) Object.assign(d, where2obj(where, target))
  } else if (query.UPDATE) {
    const where = _getWhereFromUpdate(query, target, model)
    if (!where || !where.length) return
    // REVISIT: We should not expect data to be present always!
    if (!data) data = query.UPDATE.data = {}
    Object.assign(data, where2obj(where, target))
  }
}

module.exports = {
  where2obj,
  enrichDataWithKeysFromWhere
}
