const cds = require('../../cds')

const { SELECT } = cds.ql

const { isNavigationToMany } = require('../utils/req')
const { getKeysCondition, removeIsActiveEntityRecursively } = require('../utils/where')
const { ensureNoDraftsSuffix, ensureDraftsSuffix, draftIsLocked } = require('../utils/handler')

const { DRAFT_COLUMNS_ADMIN_MAP } = require('../../common/constants/draft')
const { deepCopyArray } = require('../../common/utils/copy')
const DRAFT_COLUMNS_ADMIN = Object.keys(DRAFT_COLUMNS_ADMIN_MAP)
const PREFIX_DRAFT_COLUMNS = DRAFT_COLUMNS_ADMIN.map(col => ({ ref: ['DRAFT_DraftAdministrativeData', col] }))

/**
 * Provide information about the parent entity, i.e. the entity that has the to-many composition element.
 * Limitation: only works for one key (besides IsActiveEntity)
 *
 * @param service
 * @param req
 * @returns {object}
 * @private
 */

const _validateDraft = (req, draftResult, isBoundAction) => {
  if (!draftResult || draftResult.length === 0) req.reject(404)
  const draftAdminData = draftResult[0]

  // the same user that locked the entity can always delete/update it
  if (draftAdminData.InProcessByUser === req.user.id) return

  // proceed with the delete/update action only if it was initiated by a different
  // user than the one who locked the entity and the configured drafts cancellation
  // timeout timer has expired
  if (draftIsLocked(draftAdminData.LastChangeDateTime)) {
    req.reject(403, 'DRAFT_LOCKED_BY_ANOTHER_USER', [draftAdminData.CreatedByUser])
  }

  // At this point, the request user ID isn't the owner of the draft.
  if (isBoundAction) req.reject(403)
}

const _addDraftDataToContext = (req, result) => {
  if (!result || result.length === 0) return
  if (req.rejected) return
  if (!req._draftMetadata) req._draftMetadata = {}

  DRAFT_COLUMNS_ADMIN.forEach(column => {
    if (column in result[0]) req._draftMetadata[column] = result[0][column]
  })

  req.data.DraftAdministrativeData_DraftUUID = result[0].DraftUUID
}

const _getSelectDraftDataCqn = (entityName, where) => {
  return SELECT.from(ensureDraftsSuffix(entityName), PREFIX_DRAFT_COLUMNS)
    .join('DRAFT.DraftAdministrativeData')
    .on('DraftAdministrativeData_DraftUUID =', { ref: ['DRAFT.DraftAdministrativeData', 'DraftUUID'] })
    .where(where)
}

const _getRoot = req => {
  if (!req.query) return

  const refObj = req.query.SELECT?.from || req.query.UPDATE?.entity || req.query.INSERT?.into || req.query.DELETE?.from
  const ref0 = refObj.ref[0]

  const root = {
    entityName: ensureDraftsSuffix(ref0.id),
    where: removeIsActiveEntityRecursively(deepCopyArray(ref0.where))
  }

  for (const item of ref0.where) {
    if (item.ref && item.ref[item.ref.length - 1] === 'IsActiveEntity') {
      const index = ref0.where.indexOf(item)
      root.IsActiveEntity = ref0.where[index + 2].val
      break
    }
  }

  return root
}

const _getDraftDataFromExistingDraft = async (req, root, isBoundAction) => {
  if (!cds.db) req.reject('NO_DATABASE_CONNECTION')
  if (!root) return []
  if (root?.IsActiveEntity === false) {
    const query = _getSelectDraftDataCqn(root.entityName, root.where)
    const result = await cds.tx(req).run(query)
    return result
  }

  // do not expect validate draft ownership for action call on active instances
  if (isBoundAction) return []

  const rootWhere = getKeysCondition(req)
  const query = _getSelectDraftDataCqn(ensureNoDraftsSuffix(req.target.name), rootWhere)
  const result = await cds.tx(req).run(query)
  return result
}

const _addDraftDataFromExistingDraft = async req => {
  const root = _getRoot(req)
  const result = await _getDraftDataFromExistingDraft(req, root)

  if (!root) return []
  if (root.IsActiveEntity === false) {
    _validateDraft(req, result)
    _addDraftDataToContext(req, result)
    return result
  }

  if (result && result.length > 0) _validateDraft(req, result)
  _addDraftDataToContext(req, result)
  return result
}

/**
 * Generic Handler for before NEW requests.
 */
const _new = async function (req) {
  if (isNavigationToMany(req)) {
    const result = await _addDraftDataFromExistingDraft(req)

    // in order to fix corner case where active subitems are created in draft case
    if (result.length === 0) req.reject(404)

    return
  }

  req._draftMetadata = req._draftMetadata || {}
  req.data.DraftAdministrativeData_DraftUUID = cds.utils.uuid()
  req._draftMetadata.DraftUUID = req.data.DraftAdministrativeData_DraftUUID
}

/**
 * Generic Handler for before PATCH and UPDATE requests.
 */
const _patch = async function (req) {
  const result = await _addDraftDataFromExistingDraft(req)

  // no result means that the draft does not exist
  if (result.length === 0) req.reject(404)
}

/**
 * Generic Handler for before DELETE and CANCEL requests.
 */
const _cancel = async function (req) {
  await _addDraftDataFromExistingDraft(req)
}

const _validateDraftBoundAction = async function (req) {
  const isBoundAction = true
  const result = await _getDraftDataFromExistingDraft(req, _getRoot(req), isBoundAction)
  if (result && result.length > 0) _validateDraft(req, result, isBoundAction)
}

const _allowEntityCollectionOnAction = action => {
  return (
    action['@cds.odata.bindingparameter.collection'] ||
    (action.params && Object.values(action.params).some(e => e?.items?.type === '$self'))
  )
}

const _registerBoundActionHandlers = function (entityName, actions) {
  if (!actions) return

  const boundActions = Object.values(actions).filter(
    action =>
      action.kind === 'action' &&
      action.name !== 'draftPrepare' &&
      action.name !== 'draftEdit' &&
      action.name !== 'draftActivate' &&
      !_allowEntityCollectionOnAction(action)
  )

  for (const action of boundActions) {
    this.before(action.name, entityName, req => _validateDraftBoundAction(req))
  }
}

_new._initial = true
_patch._initial = true
_cancel._initial = true

module.exports = cds.service.impl((srv, entity) => {
  srv.before('NEW', entity, _new)
  srv.before('PATCH', entity, _patch)
  srv.before('CANCEL', entity, _cancel)
  _registerBoundActionHandlers.call(srv, entity.name, entity.actions)
})
