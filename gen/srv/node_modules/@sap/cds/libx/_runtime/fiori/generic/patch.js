const cds = require('../../cds')
const { UPDATE, SELECT } = cds.ql

const { getUpdateDraftAdminCQN, ensureDraftsSuffix } = require('../utils/handler')
const { removeIsActiveEntityRecursively } = require('../utils/where')
const { deepCopyArray } = require('../../common/utils/copy')
const { cqn2cqn4sql } = require('../../common/utils/cqn2cqn4sql')

const _getSelectCQN = ({ query }) => {
  const fromRef = deepCopyArray(query.UPDATE.entity.ref)
  for (const item of fromRef) {
    if (item.where) {
      item.where = removeIsActiveEntityRecursively(item.where)
    }
  }
  fromRef[0].id = ensureDraftsSuffix(fromRef[0].id)
  const from = { ref: fromRef }

  return SELECT.from(from)
}

const _getUpdateDraftCQN = ({ query }, where, targetRef) => {
  const set = {}

  for (const entry in query.UPDATE.data) {
    if (entry === 'DraftAdministrativeData_DraftUUID') {
      continue
    }

    set[entry] = query.UPDATE.data[entry]
  }

  if (set.IsActiveEntity) set.IsActiveEntity = false

  return UPDATE(targetRef).data(set).where(where)
}

const _joinDraftAdministrativeData = (selectResolved, target) => {
  const columns = []
  columns.push({ ref: ['DRAFT.DraftAdministrativeData', 'inProcessByUser'], as: 'draftAdmin_inProcessByUser' })
  columns.push({ ref: [target, 'DraftAdministrativeData_DraftUUID'] })

  return selectResolved
    .columns(columns)
    .join('DRAFT.DraftAdministrativeData')
    .on([
      { ref: [target, 'DraftAdministrativeData_DraftUUID'] },
      '=',
      { ref: ['DRAFT.DraftAdministrativeData', 'DraftUUID'] }
    ])
}

/**
 * Generic Handler for PATCH requests in the context of draft.
 * In case of success it returns the updated entry.
 * If the entry to be updated does not exist, it rejects with error to return a 404.
 * If a draft is already in process of another user it rejects with 403.
 *
 * @param req
 */
const fioriGenericPatch = async function (req) {
  if (req.data.IsActiveEntity === true) req.reject(400, 'Patch can only be applied to a draft entity')

  if (!cds.db) req.reject('NO_DATABASE_CONNECTION')

  const dbtx = cds.tx(req)

  const selectResolved = cqn2cqn4sql(_getSelectCQN(req), this.model)

  const targetName = selectResolved.SELECT.from.ref[selectResolved.SELECT.from.ref.length - 1]
  const alias = selectResolved.SELECT.from.as
  const selectWithAdmin = _joinDraftAdministrativeData(selectResolved, alias || targetName)
  const results = await dbtx.run(selectWithAdmin)

  if (results.length === 0) req.reject(404)

  const result = results[0]

  // Potential timeout scenario supported
  if (result.draftAdmin_inProcessByUser && result.draftAdmin_inProcessByUser !== req.user.id) {
    // REVISIT: security log?
    req.reject(403)
  }
  const updateDraftCQN = _getUpdateDraftCQN(req, selectResolved.SELECT.where, {
    ref: [targetName],
    as: alias || targetName
  })
  const updateDraftAdminCQN = getUpdateDraftAdminCQN(req, result.DraftAdministrativeData_DraftUUID)

  await Promise.all([dbtx.run(updateDraftCQN), dbtx.run(updateDraftAdminCQN)])
  req._.readAfterWrite = true

  return { ...req.data, IsActiveEntity: false }
}

module.exports = cds.service.impl(function (srv, entity) {
  srv.on('PATCH', entity, fioriGenericPatch)
})
