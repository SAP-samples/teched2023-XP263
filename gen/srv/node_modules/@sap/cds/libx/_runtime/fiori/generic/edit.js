const cds = require('../../cds')
const { INSERT, SELECT, DELETE } = cds.ql

const { getCompositionTree } = require('../../common/composition')
const { getColumns } = require('../../cds-services/services/utils/columns')
const { getTransition } = require('../../common/utils/resolveView')
const { draftIsLocked, ensureDraftsSuffix, ensureNoDraftsSuffix, getSubCQNs, filterKeys } = require('../utils/handler')
const { isActiveEntityRequested, getKeyData } = require('../utils/where')

const _getDraftColumns = draftUUID => ({
  IsActiveEntity: false,
  HasDraftEntity: false,
  HasActiveEntity: true,
  DraftAdministrativeData_DraftUUID: draftUUID
})

const _getAdminData = ({ user }, draftUUID, time) => {
  const currentUser = user.id || null
  return {
    DraftUUID: draftUUID,
    CreationDateTime: time,
    CreatedByUser: currentUser,
    LastChangeDateTime: time,
    LastChangedByUser: currentUser,
    DraftIsCreatedByMe: true,
    DraftIsProcessedByMe: true,
    InProcessByUser: currentUser
  }
}

const _getInsertAdminDataCQN = ({ user }, draftUUID, time) => {
  return INSERT.into('DRAFT.DraftAdministrativeData').entries(_getAdminData({ user }, draftUUID, time))
}

const _getLockWhere = (where, columnsMap) => {
  if (columnsMap.size === 0) {
    return where
  }

  const whereKeys = Object.keys(where)
  const lockWhere = {}

  whereKeys.forEach(key => {
    const mappedKey = columnsMap.get(key)
    const lockKey = mappedKey ? mappedKey.ref[0] : key // REVISIT: Why the mapped key is empty?
    lockWhere[lockKey] = where[key]
  })

  return lockWhere
}

const _select = async (lockRecordCQN, draftExistsCQN, selectCQNs, req, dbtx) => {
  try {
    await dbtx.run(lockRecordCQN)
  } catch (e) {
    const drafts = await dbtx.run(draftExistsCQN)
    if (drafts.length) req.reject(409, 'DRAFT_ALREADY_EXISTS')
    req.reject(409, 'ENTITY_LOCKED')
  }
  const promisesResults = await Promise.allSettled([dbtx.run(draftExistsCQN), ...selectCQNs.map(cqn => dbtx.run(cqn))])
  const firstRejected = promisesResults.find(r => r.status === 'rejected')
  if (firstRejected) req.reject(firstRejected.reason)
  return promisesResults.map(r => r.value)
}

/**
 * Generic event handler for draft edit requests.
 *
 * @param req
 */
const fioriGenericEdit = async function (req) {
  if (!isActiveEntityRequested(req.query.SELECT.where || [])) {
    req.reject(400, 'Action "draftEdit" can only be called on the active entity')
  }

  if (!cds.db) req.reject('NO_DATABASE_CONNECTION')

  const { definitions } = this.model

  // TODO replace with generic where filter
  const keys = filterKeys(req.target.keys)
  const data = getKeyData(keys, req.query.SELECT.from.ref[0].where)
  const rootWhere = keys.reduce((res, key) => {
    res[key] = data[key]
    return res
  }, {})

  // cds.db and not "this" as we want to resolve as db here
  const transition = getTransition(req.target, cds.db)
  const lockWhere = _getLockWhere(rootWhere, transition.mapping)

  // gets the underlying target entity, as record locking can't be
  // applied to localized views
  const lockTargetEntity = transition.target

  // Lock the root record of the active entity to prevent simultaneous access to it,
  // thus preventing duplicate draft entities from being created or overwritten.
  // Only allows one active entity to be processed at a time, locking out other
  // users who need to edit the same record simultaneously.
  // .forUpdate(): lock the record, a wait of 0 is equivalent to no wait
  const lockRecordCQN = SELECT.from(lockTargetEntity, [1]).where(lockWhere).forUpdate({ wait: 0 })

  const columnNames = getColumns(req.target, { onlyNames: true, filterVirtual: true })
  const rootCQN = SELECT.from(req.target, columnNames).where(rootWhere)
  const subCQNs = getSubCQNs({
    definitions,
    rootCQN,
    compositionTree: getCompositionTree({ definitions, rootEntityName: ensureNoDraftsSuffix(req.target.name) })
  })
  const rootDraftName = ensureDraftsSuffix(req.target.name)
  const draftExistsCQN = SELECT.from(rootDraftName, ['DraftAdministrativeData_DraftUUID as DraftUUID']).where(rootWhere)
  const selectCQNs = [rootCQN, ...subCQNs.map(obj => obj.cqn)]

  // fetch unlocalized data if not a texts entity
  for (const q of selectCQNs) {
    const entity = definitions[q.SELECT.from.ref[0]]
    if (entity && !entity.name.match(/\.texts$/)) {
      Object.defineProperty(q, '_suppressLocalization', { value: true })
    }
  }

  const dbtx = cds.tx(req)
  // REVISIT: Use service.read with expand **
  const [draftExists, ...results] = await _select(lockRecordCQN, draftExistsCQN, [...selectCQNs], req, dbtx)

  if (!results[0].length) {
    req.reject(404)
  }

  if (draftExists.length) {
    const adminData = await dbtx.run(
      SELECT.one('DRAFT.DraftAdministrativeData', ['InProcessByUser', 'LastChangeDateTime']).where(draftExists[0])
    )

    // temp check if draft admin data in not maintained - raise 500 error
    if (!adminData) req.reject(500, 'Draft administrative data is not maintained')

    // draft is locked (default cancellation timeout timer has not expired) OR
    // draft is not locked but must be rejected for popup
    if (draftIsLocked(adminData.LastChangeDateTime) || req.data.PreserveChanges) {
      req.reject(409, 'DRAFT_ALREADY_EXISTS')
    }

    await Promise.all([
      dbtx.run(DELETE.from('DRAFT.DraftAdministrativeData').where(draftExists[0])),
      dbtx.run(DELETE.from(rootDraftName).where(rootWhere))
    ])
  }

  const draftUUID = cds.utils.uuid()
  const insertCQNs = [_getInsertAdminDataCQN(req, draftUUID, req.timestamp)]

  for (const resultIndex in results) {
    if (results[resultIndex].length === 0) continue
    const draftEntity = ensureDraftsSuffix(selectCQNs[resultIndex].SELECT.from.ref[0])
    const entries = results[resultIndex].map(entityResult =>
      Object.assign({}, entityResult, _getDraftColumns(draftUUID))
    )

    insertCQNs.push(INSERT.into(draftEntity).entries(entries))
  }

  await Promise.all(insertCQNs.map(CQN => dbtx.run(CQN)))

  // REVISIT: we need to use okra API here because it must be set in the batched request
  // status code must be set in handler to allow overriding for FE V2
  req?._?.odataRes?.setStatusCode(201)

  return results[0][0]
}

module.exports = cds.service.impl(function (srv, entity) {
  srv.on('EDIT', entity, fioriGenericEdit)
})
