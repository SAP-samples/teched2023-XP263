const cds = require('../../cds')
const { SELECT } = cds.ql

const { cqn2cqn4sql, convertWhereExists } = require('../../common/utils/cqn2cqn4sql')
const { getElementDeep } = require('../../common/utils/csn')
const { DRAFT_COLUMNS_MAP, SCENARIO } = require('../../common/constants/draft')
const { filterNonDraftColumns } = require('../../common/utils/draft')
const {
  addColumnAlias,
  draftIsLocked,
  ensureDraftsSuffix,
  ensureNoDraftsSuffix,
  ensureUnlocalized,
  getEnrichedCQN,
  removeDraftUUIDIfNecessary,
  replaceRefWithDraft,
  filterKeys
} = require('../utils/handler')
const { deleteCondition, readAndDeleteKeywords, removeIsActiveEntityRecursively } = require('../utils/where')
const { adaptStreamCQN } = require('../../cds-services/adapter/odata-v4/utils/stream')
const getError = require('../../common/error')

const _findSubselect = where => {
  return where.find((e, i) => {
    if (e.xpr) return _findSubselect(e.xpr)
    return e.SELECT && where[i - 1] === 'exists'
  })
}

const _findRootSubSelectFor = query => {
  if (query.SELECT.where) {
    const subSelect = _findSubselect(query.SELECT.where)
    return subSelect ? _findRootSubSelectFor(subSelect) : query
  }

  return query
}

// append where with clauses from @restrict
const _getWhereWithAppendedDraftRestrictions = (where = [], req) => {
  const restrictions = []
  if (req.query._draftRestrictions) {
    for (const each of req.query._draftRestrictions) {
      const xpr = each._xpr
      if (each.target.name === ensureUnlocalized(req.target.name)) {
        // restriction might contain or clause -> use xpr for grouping
        if (restrictions.length) restrictions.push('or')
        xpr.includes('or') ? restrictions.push({ xpr }) : restrictions.push(...xpr)
      } else {
        // restriction inherited from parent via autoexposure
        // find inner most sub select if available and append restriction to where clause
        const rootSubSelect = _findRootSubSelectFor({ SELECT: { where } })
        if (rootSubSelect && rootSubSelect.SELECT.from) {
          if (rootSubSelect.SELECT.where && rootSubSelect.SELECT.where.length) rootSubSelect.SELECT.where.push('and')
          const tableAlias = rootSubSelect.SELECT.from.as
          rootSubSelect.SELECT.where.push(
            ...xpr.map(e => {
              if (e.ref) return tableAlias ? { ref: [tableAlias, ...e.ref] } : { ref: [...e.ref] }
              return e
            })
          )
        }
      }
    }
  }

  if (restrictions.length) {
    if (where.length) where.push('and', { xpr: restrictions })
    else where.push(...restrictions)
  }
  return where
}

const _isTrue = val => val === true || val === 'true'
const _isFalse = val => val === false || val === 'false'
const _inProcessByUserWhere = userId => [{ ref: ['filterAdmin', 'InProcessByUser'] }, '=', { val: userId }]

const _getTableName = (
  {
    target: { name },
    query: {
      SELECT: { from }
    }
  },
  isDraft = false
) => {
  const table = isDraft ? ensureDraftsSuffix(name) : ensureNoDraftsSuffix(name)
  const as = from.args ? from.args[0].as : from.as
  if (as) {
    return {
      table: {
        ref: [table],
        as: as
      },
      name: as
    }
  }

  return {
    table: {
      ref: [table]
    },
    name: table
  }
}

const _getTargetKeys = ({ target }) => {
  return filterKeys(target.keys)
}

const DRAFT_COLUMNS_CASTED = [
  {
    ref: ['IsActiveEntity'],
    cast: { type: 'cds.Boolean' }
  },
  {
    ref: ['HasActiveEntity'],
    cast: { type: 'cds.Boolean' }
  },
  {
    ref: ['HasDraftEntity'],
    cast: { type: 'cds.Boolean' }
  }
]

const DRAFT_COLUMNS_CASTED_WITH_DRAFTADMIN_UUID = [
  ...DRAFT_COLUMNS_CASTED,
  { ref: ['DraftAdministrativeData_DraftUUID'] }
]

// default draft values for active entities
const _getDefaultDraftProperties = ({ hasDraft, isActive = true, withDraftUUID = true }) => {
  const columns = [
    { val: isActive, as: 'IsActiveEntity', cast: { type: 'cds.Boolean' } },
    { val: false, as: 'HasActiveEntity', cast: { type: 'cds.Boolean' } }
  ]

  if (hasDraft !== null) {
    columns.push({
      val: Boolean(hasDraft),
      as: 'HasDraftEntity',
      cast: { type: 'cds.Boolean' }
    })
  }

  if (withDraftUUID) {
    columns.push(
      isActive
        ? { val: null, as: 'DraftAdministrativeData_DraftUUID' }
        : { ref: ['DraftAdministrativeData_DraftUUID'], as: 'DraftAdministrativeData_DraftUUID' }
    )
  }

  return columns
}

// draft values for active entities with calculated hasDraft property
const _getDraftPropertiesDetermineDraft = (req, where, tableName, calcDraftUUID = false) => {
  const { table } = _getTableName(req, true)
  tableName = tableName || table

  const hasDraftQuery = SELECT.from(tableName, [{ val: 1 }])
  if (where && where.length > 0) {
    // clone where to protect from later modification
    hasDraftQuery.where([...where])
  }

  let draftUUIDColumn
  if (calcDraftUUID) {
    draftUUIDColumn = SELECT.from(tableName, ['DraftAdministrativeData_DraftUUID'])
    if (where && where.length > 0) {
      draftUUIDColumn.where(where)
    }
  } else {
    draftUUIDColumn = { val: null, as: 'DraftAdministrativeData_DraftUUID' }
  }

  const xpr = {
    xpr: ['case', 'when', hasDraftQuery, 'IS NOT NULL', 'then', 'true', 'else', 'false', 'end'],
    as: 'HasDraftEntity',
    cast: { type: 'cds.Boolean' }
  }

  hasDraftQuery.as = 'HasDraftEntity'
  hasDraftQuery.cast = { type: 'cds.Boolean' }

  return [
    { val: true, as: 'IsActiveEntity', cast: { type: 'cds.Boolean' } },
    { val: false, as: 'HasActiveEntity', cast: { type: 'cds.Boolean' } },
    xpr,
    draftUUIDColumn
  ]
}

function _copyCQNPartial(partial) {
  if (partial.SELECT) {
    const newPartial = Object.assign({}, partial)
    const newSELECT = Object.assign({}, partial.SELECT)
    newSELECT.from = _copyCQNPartial(partial.SELECT.from)
    newPartial.SELECT = newSELECT
    if (partial.SELECT._4odata) newSELECT._4odata = true
    if (partial.SELECT.columns) newPartial.SELECT.columns = _copyArray(partial.SELECT.columns)
    if (partial.SELECT.where) newPartial.SELECT.where = _copyArray(partial.SELECT.where)
    return newPartial
  }

  if (partial.id) {
    const res = Object.assign({}, partial)
    if (res.where) res.where = _copyArray(res.where)
    return res
  }

  if (partial.ref) {
    return Object.assign({}, partial, { ref: _copyArray(partial.ref) })
  }

  return Object.assign({}, partial)
}

function _copyArray(array) {
  return array.map(entry => (typeof entry === 'object' && !(entry instanceof String) ? _copyCQNPartial(entry) : entry))
}

const _isValidDraftOfWhichIAmOwner = isActiveEntity => isActiveEntity.op === '=' && _isFalse(isActiveEntity.value.val)

const _isValidActiveWithoutDraft = (isActiveEntity, hasDraftEntity) => {
  return (
    isActiveEntity.op === '=' &&
    _isTrue(isActiveEntity.value.val) &&
    hasDraftEntity.op === '=' &&
    _isFalse(hasDraftEntity.value.val)
  )
}

const _isValidWithDraftLocked = (isActiveEntity, siblingIsActive, draftInProcessByUser) => {
  return (
    isActiveEntity.op === '=' &&
    _isTrue(isActiveEntity.value.val) &&
    siblingIsActive.op === '=' &&
    siblingIsActive.value.val === null &&
    draftInProcessByUser.op === '!=' &&
    draftInProcessByUser.value.val === ''
  )
}

const _isValidWithDraftTimeout = (isActiveEntity, siblingIsActive, draftInProcessByUser) => {
  return (
    isActiveEntity.op === '=' &&
    _isTrue(isActiveEntity.value.val) &&
    siblingIsActive.op === '=' &&
    siblingIsActive.value.val === null &&
    draftInProcessByUser.op === '=' &&
    draftInProcessByUser.value.val === ''
  )
}

const _isValidExcludeActiveDraftExists = (isActiveEntity, siblingIsActive) => {
  return (
    isActiveEntity.op === '=' &&
    _isFalse(isActiveEntity.value.val) &&
    siblingIsActive.op === '=' &&
    siblingIsActive.value.val === null
  )
}

const _filterDraftColumnsBySelected = (draftColumns, columns) => {
  const _findByAlias = (draftColumn, alias) => alias && draftColumn.as && alias === draftColumn.as
  const _findByRef = (draftColumn, ref) => ref && draftColumn.ref && ref === draftColumn.ref[draftColumn.ref.length - 1]
  // include draft-specific columns only if there is no SELECT.columns or if they are selected explicitly
  return (
    (!columns && draftColumns) ||
    draftColumns.filter(
      draftColumn =>
        (!draftColumn.ref && !draftColumn.as) ||
        columns.find(col => {
          const ref = col.ref && col.ref[col.ref.length - 1]
          return _findByRef(draftColumn, ref) || _findByAlias(draftColumn, ref) || _findByAlias(draftColumn, col.as)
        })
    )
  )
}

const _isOnlyCount = columns => columns.length === 1 && (columns[0].as === '_counted_' || columns[0].as === '$count')

const _getOuterMostColumns = (columnsFromRequest, additionalDraftColumns) => {
  if (_isOnlyCount(columnsFromRequest)) return columnsFromRequest

  // remove draft columns from columnsFromRequest (if present) to avoid duplicates
  const columns = [...columnsFromRequest.filter(ele => !ele.as || !DRAFT_COLUMNS_MAP[ele.as])]
  columns.push(...additionalDraftColumns)
  return columns
}

// adds base columns 'InProcessByUser' and 'CreatedByUser' to columns param if needed
// those are required for calculating 'DraftIsProcessedByMe' and 'DraftIsCreatedByMe'
const _ensureDraftAdminColumnsForCalculation = columns => {
  columns.forEach(c => {
    if (c.ref && c.ref[0] === 'DraftIsCreatedByMe' && !columns.find(e => e.ref && e.ref[0] === 'CreatedByUser')) {
      columns.push({ ref: ['CreatedByUser'] })
    } else if (
      c.ref &&
      c.ref[0] === 'DraftIsProcessedByMe' &&
      !columns.find(e => e.ref && e.ref[0] === 'InProcessByUser')
    ) {
      columns.push({ ref: ['InProcessByUser'] })
    }
  })
}

const _draftAdminTable = req => {
  const { table } = _getTableName(req)

  let cqn = SELECT.from(table)
  if (req.query.SELECT.columns) {
    cqn = cqn.columns(...req.query.SELECT.columns)
    _ensureDraftAdminColumnsForCalculation(cqn.SELECT.columns)
  }

  return {
    cqn: getEnrichedCQN(cqn, req.query.SELECT, req.query.SELECT.where),
    scenario: SCENARIO.DRAFT_ADMIN
  }
}

const _allInactive = (req, columns) => {
  const table = {
    ref: [ensureDraftsSuffix(req.query.SELECT.from.ref[0])],
    as: req.query.SELECT.from.as || 'drafts'
  }

  const outerMostColumns = _getOuterMostColumns(
    addColumnAlias(columns, table.as),
    _getDefaultDraftProperties({ hasDraft: false, isActive: false, withDraftUUID: false })
  )

  const isCount = columns.some(element => element.func === 'count')

  // ensure only own drafts are read
  const cqn = SELECT.from(table)
    .join('DRAFT.DraftAdministrativeData', 'filterAdmin')
    .on([{ ref: [table.as, 'DraftAdministrativeData_DraftUUID'] }, '=', { ref: ['filterAdmin', 'DraftUUID'] }])
    .where(_inProcessByUserWhere(req.user.id))

  if (isCount) {
    cqn.columns(...outerMostColumns)
  } else {
    cqn.columns(...outerMostColumns.filter(o => o.as !== 'HasActiveEntity'), { ref: ['HasActiveEntity'] })
  }

  cqn.where(req.query.SELECT.where)
  return { cqn: getEnrichedCQN(cqn, req.query.SELECT, []), scenario: SCENARIO.ALL_INACTIVE }
}

const _setRefAlias = (ref, as) => {
  if (ref && ref[0] !== as) {
    ref.unshift(as)
  }
}

const _buildWhere = (where, table) => {
  for (const entry of where) {
    if (entry.ref) {
      _setRefAlias(entry.ref, table.as)
    } else if (entry.func && entry.args) {
      _buildWhere(entry.args, table)
    } else if (entry.list) {
      _buildWhere(entry.list, table)
    } else if (entry.xpr) {
      _buildWhere(entry.xpr, table)
    }
  }
}

const _allActive = (req, columns) => {
  const { table } = _getTableName(req)
  if (!table.as) {
    table.as = 'active'
  }

  const outerMostColumns = _getOuterMostColumns(
    addColumnAlias(columns, table.as),
    _getDefaultDraftProperties({ hasDraft: null })
  )

  const ids = filterKeys(req.target.keys)
  const isCount = columns.some(element => element.func === 'count')
  const xpr = {
    xpr: [
      'case',
      'when',
      'drafts.DraftAdministrativeData_DraftUUID',
      'IS NOT NULL',
      'then',
      'true',
      'else',
      'false',
      'end'
    ],
    as: 'HasDraftEntity',
    cast: { type: 'cds.Boolean' }
  }

  const cqn = SELECT.from(table)

  if (isCount) {
    cqn.columns(..._filterDraftColumnsBySelected(outerMostColumns, req.query.SELECT.columns))
  } else {
    cqn.columns(..._filterDraftColumnsBySelected([...outerMostColumns, xpr], req.query.SELECT.columns))
    cqn.leftJoin(ensureDraftsSuffix(table.ref[0]) + ' as drafts').on(`${table.as}.${ids[0]} = drafts.${ids[0]}`)

    for (let i = 1; i < ids.length; i++) {
      // this 'and' belongs to the join condition and is not a where and
      cqn.and({ ref: [table.as, ids[i]] }, '=', { ref: ['drafts', ids[i]] })
    }
  }

  const scenarioAlias = 'active'
  req.query.SELECT.where = _getWhereWithAppendedDraftRestrictions(req.query.SELECT.where, req)

  if (req.query.SELECT.where) {
    _buildWhere(req.query.SELECT.where, table)
  }

  return {
    cqn: getEnrichedCQN(cqn, req.query.SELECT, req.query.SELECT.where, scenarioAlias),
    scenario: SCENARIO.ALL_ACTIVE
  }
}

const _activeWithoutDraft = (req, draftWhere, columns) => {
  const { table } = _getTableName(req, true)
  const draftName = table.ref[0]
  const active = _getTableName(req)
  const keys = _getTargetKeys(req)

  let subSelect = SELECT.from(draftName).columns(...keys)
  subSelect = keys.reduce(
    (select, key) =>
      subSelect.where([
        { ref: [active.name, key] },
        '=',
        {
          ref: [draftName, key]
        }
      ]),
    subSelect
  )

  const outerMostColumns = _getOuterMostColumns(columns, _getDefaultDraftProperties({ hasDraft: false }))
  const cqn = SELECT.from(active.table)
    .columns(...outerMostColumns)
    .where(['not exists', subSelect])

  draftWhere = _getWhereWithAppendedDraftRestrictions(draftWhere, req)
  return { cqn: getEnrichedCQN(cqn, req.query.SELECT, draftWhere), scenario: SCENARIO.ACTIVE_WITHOUT_DRAFT }
}

const _draftOfWhichIAmOwner = (req, draftWhere, columns) => {
  const { table, name } = _getTableName(req, true)
  const outerMostColumns = _getOuterMostColumns(
    addColumnAlias(columns, name),
    DRAFT_COLUMNS_CASTED_WITH_DRAFTADMIN_UUID
  )

  const cqn = SELECT.from(table)
    .columns(...outerMostColumns)
    .join('DRAFT.DraftAdministrativeData', 'filterAdmin')
    .on([{ ref: [name, 'DraftAdministrativeData_DraftUUID'] }, '=', { ref: ['filterAdmin', 'DraftUUID'] }])
    .where(_inProcessByUserWhere(req.user.id))

  return { cqn: getEnrichedCQN(cqn, req.query.SELECT, draftWhere), scenario: SCENARIO.DRAFT_WHICH_OWNER }
}

const _activeWithDraftInProcess = (req, draftWhere, columns, isLocked) => {
  const draft = _getTableName(req, true)
  const draftName = draft.table.ref[0]
  const active = _getTableName(req)
  const keys = _getTargetKeys(req)
  const draftColumns = _getDefaultDraftProperties({ hasDraft: true })

  let subSelect = SELECT.from(draftName)
    .columns(...keys)
    .join('DRAFT.DraftAdministrativeData', 'filterAdmin')
    .on([{ ref: [draftName, 'DraftAdministrativeData_DraftUUID'] }, '=', { ref: ['filterAdmin', 'DraftUUID'] }])

  const DRAFT_CANCEL_TIMEOUT_IN_SEC = ((cds.env.drafts && cds.env.drafts.cancellationTimeout) || 15) * 60

  subSelect = subSelect.where([
    { ref: ['filterAdmin', 'InProcessByUser'] },
    '!=',
    { val: req.user.id },
    'and',
    { ref: ['filterAdmin', 'InProcessByUser'] },
    'is not null',
    'and',
    { func: 'seconds_between', args: [{ ref: ['filterAdmin', 'LastChangeDateTime'] }, 'CURRENT_TIMESTAMP'] },
    isLocked ? '<' : '>',
    { val: DRAFT_CANCEL_TIMEOUT_IN_SEC }
  ])

  subSelect = keys.reduce(
    (_select, key) => subSelect.where([{ ref: [active.name, key] }, '=', { ref: [draftName, key] }]),
    subSelect
  )

  const outerMostColumns = _getOuterMostColumns(columns, draftColumns)
  const cqn = SELECT.from(active.table).columns(outerMostColumns)
  cqn.where(_getWhereWithAppendedDraftRestrictions([], req))
  cqn.where(['exists', subSelect])
  return { cqn: getEnrichedCQN(cqn, req.query.SELECT, draftWhere), scenario: SCENARIO.DRAFT_IN_PROCESS }
}

const _alignAliasForUnion = (table, as, select) => {
  if (!as || !select.SELECT.where) {
    return select
  }

  for (const entry of select.SELECT.where) {
    if (entry.ref && entry.ref[0] === table) {
      entry.ref[0] = as
    }
  }

  return select
}

const isTargetRef = (el, targetAlias) => targetAlias && el.ref && el.ref.length > 1 && el.ref[0] === targetAlias

const _joinFromWhere = (where, parentAlias, targetAlias) => {
  return where.reduce((links, el, idx, where) => {
    if (el.xpr) {
      const result = _joinFromWhere(el.xpr, parentAlias, targetAlias)

      if (result.length) {
        if (links.length) links.push('and')
        links.push(...result)
      }

      return links
    }

    if (el.ref && el.ref[0] === parentAlias && el.ref[el.ref.length - 1] !== 'IsActiveEntity') {
      if (where[idx - 1] && where[idx - 1] === '=' && isTargetRef(where[idx - 2], targetAlias)) {
        if (links.length) links.push('and')
        links.push(el, '=', where[idx - 2])
      }

      if (where[idx + 1] && where[idx + 1] === '=' && isTargetRef(where[idx + 2], targetAlias)) {
        if (links.length) links.push('and')
        links.push(el, '=', where[idx + 2])
      }
    }

    return links
  }, [])
}

const _findJoinInQuery = (query, parentAlias) => {
  const targetAlias = query.SELECT.from.as
  if (query.SELECT && query.SELECT.where) return _joinFromWhere(query.SELECT.where, parentAlias, targetAlias)
  return []
}

const _isDraftField = element => element.ref && element.ref.length > 1 && element.ref[0] === 'DraftAdministrativeData'

const _functionContainsDraftField = obj =>
  typeof obj === 'object' &&
  obj.func &&
  obj.args.some(arg => {
    return _isDraftField(arg) || _functionContainsDraftField(arg)
  })

const _isLogicalFunction = (where, index) => {
  // REVISIT
  const borders = ['(', ')', 'and', 'or', undefined]

  return borders.includes(where[index - 1]) && borders.includes(where[index + 1])
}

const _getWhereForActive = where => {
  const activeWhere = []
  for (let i = 0; i < where.length; i++) {
    if (where[i].xpr) {
      activeWhere.push({ xpr: _getWhereForActive(where[i].xpr) })
      continue
    }

    if (_isDraftField(where[i])) {
      activeWhere.push({ val: null })
    } else if (_functionContainsDraftField(where[i])) {
      if (_isLogicalFunction(where, i)) {
        activeWhere.push({ val: 1 }, '=', { val: 2 })
      } else {
        activeWhere.push({ val: null })
      }
    } else {
      activeWhere.push(where[i])
    }
  }

  for (let i = 0; i < activeWhere.length; i++) {
    if (
      activeWhere[i].val === null &&
      activeWhere[i + 1] === '=' &&
      activeWhere[i + 2] &&
      activeWhere[i + 2].val === null
    ) {
      activeWhere[i] = { val: 1 }
      activeWhere[i + 2] = { val: 1 }
    }
  }

  return activeWhere
}

const _siblingEntity = (
  { query, target, nav, params },
  columns,
  model,
  draftAdminAlias,
  parentQuery,
  siblingIndex,
  req
) => {
  const parentLinks = parentQuery ? _findJoinInQuery(query, parentQuery.SELECT.from.as) : []
  const keys = (nav[siblingIndex + 1].where && (params[siblingIndex] || params[0])) || {}
  const siblingQuery = query.SELECT.where[query.SELECT.where.indexOf('exists') + 1]
  const onCond = _findJoinInQuery(siblingQuery, target.as)
  const siblingAlias = siblingQuery.SELECT.from.as
  const subScenario = _siblingSubScenario(nav, siblingIndex, siblingQuery, target, params, model, onCond, req)
  const isSiblingDraft = subScenario
    ? subScenario.isSiblingActive || subScenario.scenario === 'ACTIVE' || subScenario.scenario === 'ALL_ACTIVE'
    : keys.IsActiveEntity && keys.IsActiveEntity !== false
  const { table } = _getTableName({ query, target }, isSiblingDraft)
  const cqn = SELECT.from(table)

  if (siblingIndex === 0) {
    const columnCqnPartial = columns.map(col => {
      if (col.val) {
        return Object.assign({}, col)
      }
      const colName = col.ref ? col.ref[col.ref.length - 1] : col
      const ref = col.ref ? [table.as, ...col.ref] : [table.as, colName]
      return Object.assign({}, col, { ref })
    })
    columnCqnPartial.push({ ref: ['draftAdmin', 'InProcessByUser'], as: 'draftAdmin_inProcessByUser' })
    cqn.columns(...columnCqnPartial)
  } else {
    cqn.columns([{ val: 1 }])
  }

  if (isSiblingDraft) {
    cqn
      .join(ensureNoDraftsSuffix(target.name), siblingAlias)
      .on(onCond)
      .join('DRAFT.DraftAdministrativeData', 'draftAdmin')
      .on(`${table.as}.DraftAdministrativeData_DraftUUID = draftAdmin.DraftUUID`)
  } else {
    cqn
      .join(ensureDraftsSuffix(target.name), siblingAlias)
      .on(onCond)
      .join('DRAFT.DraftAdministrativeData', 'draftAdmin')
      .on(`${siblingAlias}.DraftAdministrativeData_DraftUUID = draftAdmin.DraftUUID`)
  }

  for (const key in keys) {
    if (key !== 'IsActiveEntity') cqn.where([{ ref: [table.as, key] }, '=', { val: keys[key] }])
  }

  if (subScenario) {
    cqn.where(['exists', subScenario.cqn])
  }

  // in DraftAdminData scenario parent is linked via join
  if (draftAdminAlias) {
    cqn.where([{ ref: [draftAdminAlias, 'DraftUUID'] }, '=', { ref: ['draftAdmin', 'DraftUUID'] }])
  } else if (parentLinks.length) {
    cqn.where({ xpr: [...parentLinks] })
  }

  return { cqn, scenario: SCENARIO.SIBLING_ENTITY, isSiblingActive: !isSiblingDraft }
}

function _siblingSubScenario(nav, siblingIndex, siblingQuery, target, params, model, onCond, req) {
  if (nav[siblingIndex + 1].where) return
  let subScenario
  const subNav = nav.slice(siblingIndex + 1)
  const subSiblingIndex = subNav.indexOf('SiblingEntity')
  const subReq = {
    query: siblingQuery,
    target: model.definitions[target.name],
    params: [...params].reverse(),
    user: req.user
  }

  if (subSiblingIndex > -1) {
    subScenario = _getSiblingScenario(subReq, [{ val: 1 }], model, subSiblingIndex, subNav, params)
    if (subSiblingIndex > 0) {
      const subQuery = SELECT.from(siblingQuery.SELECT.from).columns([{ val: 1 }])
      _mergeSiblingIntoCQN(subQuery, subScenario, subSiblingIndex - 1)
      subQuery.where(onCond)
      subScenario.cqn = subQuery
    }
  } else {
    subReq.query = SELECT.from(siblingQuery.SELECT.from).columns([{ val: 1 }])

    const existsIdx = siblingQuery.SELECT.where.indexOf('exists')
    if (existsIdx > -1) subReq.query.where(siblingQuery.SELECT.where.slice(existsIdx, existsIdx + 2))
    const subOrigFrom = { ref: [...subNav].reverse() }
    subScenario = _generateCQN(subReq, [{ val: 1 }], subOrigFrom, model)
    subScenario.cqn.where(onCond)
  }

  return subScenario
}

const _getSiblingScenario = (req, columns, model, siblingIndex, nav) => {
  const draftAdminAlias = _isDraftAdminScenario(req) && req.query.SELECT.from.as
  const params = [...req.params].reverse()
  const _getSiblingQueryFromWhere = (query, queryIndex, parentQuery) => {
    if (query.SELECT && query.SELECT.where && queryIndex > 0) {
      for (let i = 0; i < query.SELECT.where.length; i++) {
        if (query.SELECT.where[i] === 'exists' && queryIndex > 0) {
          return _getSiblingQueryFromWhere(query.SELECT.where[i + 1], queryIndex - 1, query)
        }
      }
    }

    const target = { name: query.SELECT.from.ref[0].id || query.SELECT.from.ref[0], as: query.SELECT.from.as }
    return _siblingEntity(
      { query, target, params, nav },
      columns,
      model,
      draftAdminAlias,
      parentQuery,
      siblingIndex,
      req
    )
  }

  return _getSiblingQueryFromWhere(req.query, siblingIndex)
}

const _replaceWhereExists = (query, _siblingIndex, siblingCQN) => {
  if (query.SELECT && query.SELECT.where) {
    for (let i = 0; i < query.SELECT.where.length; i++) {
      const whereElement = query.SELECT.where[i]
      if (whereElement.xpr) {
        const res = _replaceWhereExists({ SELECT: { where: whereElement.xpr } }, _siblingIndex, siblingCQN)
        if (res) return res
        continue
      }

      const indexExists = query.SELECT.where.indexOf('exists')
      if (indexExists > -1) {
        query.SELECT.where.splice(indexExists + 1, 1, siblingCQN)
      }
    }
  }
}

const _mergeSiblingIntoCQN = (cqn, { cqn: siblingCQN }, siblingIndex) =>
  _replaceWhereExists(cqn, siblingIndex, siblingCQN)

const _getDraftDoc = (req, draftName, draftWhere) => {
  const refDraft = req.query.SELECT.from.as ? { ref: [draftName], as: req.query.SELECT.from.as } : draftName

  const draftDocs = getEnrichedCQN(
    SELECT.from(refDraft)
      .join('DRAFT.DraftAdministrativeData', 'filterAdmin')
      .on([
        { ref: [req.query.SELECT.from.as || draftName, 'DraftAdministrativeData_DraftUUID'] },
        '=',
        { ref: ['filterAdmin', 'DraftUUID'] }
      ])
      .where(_inProcessByUserWhere(req.user.id)),
    req.query.SELECT,
    draftWhere,
    undefined,
    false
  )

  return draftDocs
}

const _getOrderByEnrichedColumns = (orderBy, columns, entity) => {
  const enrichedCol = []

  if (orderBy && orderBy.length > 1) {
    const colNames = columns.filter(el => el.ref).map(el => el.ref[el.ref.length - 1])

    // REVISIT: GET Books?$select=title&$expand=NotBooks($select=pages)&$orderby=NotBooks/title - what's then?
    for (const el of orderBy) {
      // For associations we need to 'materialise' the resulting field, otherwise we cannot access it in an outer SELECT.
      if (entity && entity.elements[el.ref[0]] && entity.elements[el.ref[0]].isAssociation) {
        enrichedCol.push({ ref: [...el.ref], as: _poorMansAlias4(el) })
      } else if (!(el.ref[el.ref.length - 1] in DRAFT_COLUMNS_MAP) && !colNames.includes(el.ref[el.ref.length - 1])) {
        enrichedCol.push({ ref: [...el.ref] })
      }
    }
  }

  return enrichedCol
}

const _replaceDraftAlias = where => {
  where.forEach(element => {
    if (element.xpr) {
      _replaceDraftAlias(element.xpr)
      return
    }

    if (_isDraftField(element)) {
      element.ref[0] = 'filterAdmin'
    }

    if (typeof element === 'object' && element.func) {
      _replaceDraftAlias(element.args)
    }
  })
}

const _poorMansAlias4 = xpr => '_' + xpr.ref.join('_') + '_'

const _getUnionCQN = (req, draftName, columns, subSelect, draftWhere, model, entity) => {
  const draftActiveWhere = _getWhereForActive(draftWhere)
  const activeDocs = getEnrichedCQN(SELECT.from(req.target), req.query.SELECT, draftActiveWhere, undefined, false)
  activeDocs.where(_getWhereWithAppendedDraftRestrictions([], req))
  convertWhereExists(activeDocs.SELECT, model, {})

  // @restrict.where not applicable for drafts (I can ALWAYS read mine)
  _replaceDraftAlias(draftWhere)
  const draftDocs = _getDraftDoc(req, draftName, draftWhere)

  const union = SELECT.from({ SET: { op: 'union', all: true, args: [draftDocs, activeDocs] } })
  if (req.query.SELECT.count) union.SELECT.count = true
  if (req.query.SELECT.__countAggregated) union.SELECT.__countAggregated = true

  if (req.query.SELECT.from.as) {
    draftDocs.SELECT.from.as = req.query.SELECT.from.as
    activeDocs.SELECT.from.as = req.query.SELECT.from.as
  }

  if (_isOnlyCount(columns)) {
    draftDocs.columns(...columns)
    activeDocs
      .columns(...columns)
      .where([
        'not exists',
        _alignAliasForUnion(ensureNoDraftsSuffix(req.target.name), req.query.SELECT.from.as, subSelect)
      ])

    return union.columns({ func: 'sum', args: [{ ref: ['$count'] }], as: '$count' })
  }

  const enrichedColumns = _getOrderByEnrichedColumns(req.query.SELECT.orderBy, columns, entity)

  for (const col of enrichedColumns) {
    // if we have columns for outer order by that may also be needed for joins, we need to duplicate them
    const element = getElementDeep(req.target, col.ref)
    if (element && element._foreignKey4) {
      columns.push({ ref: [...col.ref] })
    }

    col.as = _poorMansAlias4(col)
    // add alias to outer order by
    const ob = req.query.SELECT.orderBy.find(ele => _poorMansAlias4(ele) === col.as)
    ob.ref = [col.as]
  }

  const draftColumns = [
    ...addColumnAlias([...columns, ...enrichedColumns], req.query.SELECT.from.as || draftName),
    ..._filterDraftColumnsBySelected(DRAFT_COLUMNS_CASTED, req.query.SELECT.columns),
    'DraftAdministrativeData_DraftUUID'
  ]
  draftDocs.columns(draftColumns)

  const activeName = activeDocs.SELECT.from.as || (activeDocs.SELECT.from.ref && activeDocs.SELECT.from.ref[0])
  const hasDraftWhere = []
  const targetKeys = _getTargetKeys(req)
  for (const key of targetKeys) {
    // add 'and' token if not the first iteration
    if (hasDraftWhere.length) hasDraftWhere.push('and')
    hasDraftWhere.push({ ref: [activeName, key] }, '=', { ref: [draftName, key] })
  }

  const draftColumnsBySelected = _filterDraftColumnsBySelected(
    _getDraftPropertiesDetermineDraft(req, hasDraftWhere, ensureDraftsSuffix(req.target.name), true),
    req.query.SELECT.columns
  )

  const activeColumns = [...columns, ...enrichedColumns, ...draftColumnsBySelected]
  activeDocs.columns(activeColumns)

  const aliasForUnion = _alignAliasForUnion(ensureNoDraftsSuffix(req.target.name), req.query.SELECT.from.as, subSelect)
  activeDocs.where(['not exists', aliasForUnion])

  // groupBy, orderBy and limit do not support partial CQNs
  if (req.query.SELECT.groupBy) {
    union.SELECT.groupBy = req.query.SELECT.groupBy
  }

  if (req.query.SELECT.orderBy) {
    union.SELECT.orderBy = req.query.SELECT.orderBy
  }

  if (req.query.SELECT.limit) {
    union.SELECT.limit = req.query.SELECT.limit
  }

  return union
    .columns(...columns.map(ref => (ref.as ? { ref: [ref.as], as: ref.as } : ref))) // needed for aliased stream property ref@odata.mediaContentType
    .columns(..._filterDraftColumnsBySelected(DRAFT_COLUMNS_CASTED, req.query.SELECT.columns))
}

const _excludeActiveDraftExists = (req, columns, draftWhere, model) => {
  const { table, name } = _getTableName(req, true)
  const draftName = table.ref[0]

  const subSelect = SELECT.from(draftName, [1])
    .join('DRAFT.DraftAdministrativeData', 'filterAdmin')
    .on([{ ref: [draftName, 'DraftAdministrativeData_DraftUUID'] }, '=', { ref: ['filterAdmin', 'DraftUUID'] }])
    .where(_inProcessByUserWhere(req.user.id))

  const targetName = ensureNoDraftsSuffix(req.target.name)
  const targetKeys = _getTargetKeys(req)
  for (const key of targetKeys) {
    subSelect.where([{ ref: [targetName, key] }, '=', { ref: [draftName, key] }])
  }

  const entity = model.definitions[targetName]
  draftWhere = removeIsActiveEntityRecursively(draftWhere)
  const cqn = _getUnionCQN(req, draftName, columns, subSelect, draftWhere, model, entity)
  cqn.SELECT.from.as = name

  if (cqn.SELECT.orderBy) {
    for (const entry of cqn.SELECT.orderBy || []) {
      if (entry.ref.length > 1 && entry.ref[0] !== name) {
        entry.ref[0] = name
      }
    }
  }

  return { cqn: cqn, scenario: SCENARIO.UNION }
}

const _readDraftParameters = where => {
  const obj = {
    isActiveEntity: readAndDeleteKeywords(['IsActiveEntity'], where),
    hasDraftEntity: readAndDeleteKeywords(['HasDraftEntity'], where),
    siblingIsActive: readAndDeleteKeywords(['SiblingEntity', 'IsActiveEntity'], where),
    draftInProcessByUser: readAndDeleteKeywords(['DraftAdministrativeData', 'InProcessByUser'], where)
  }

  // remove "DraftAdministrativeData/InProcessByUser ne null" from request if necessary
  readAndDeleteKeywords(['DraftAdministrativeData', 'InProcessByUser'], where)

  return obj
}

const _validatedActiveWithoutDraft = (req, draftWhere, draftParameters, columns) =>
  _isValidActiveWithoutDraft(draftParameters.isActiveEntity, draftParameters.hasDraftEntity) &&
  _activeWithoutDraft(req, draftWhere, columns)

const _validatedWithSiblingInProcess = (req, draftWhere, draftParameters, columns, model) => {
  const { isActiveEntity, siblingIsActive, draftInProcessByUser } = draftParameters
  if (
    !draftInProcessByUser &&
    _isValidExcludeActiveDraftExists(draftParameters.isActiveEntity, draftParameters.siblingIsActive)
  ) {
    return _excludeActiveDraftExists(req, columns, draftWhere, model)
  }

  if (
    draftInProcessByUser &&
    draftInProcessByUser.op === '!=' &&
    _isValidWithDraftLocked(isActiveEntity, siblingIsActive, draftInProcessByUser)
  ) {
    return _activeWithDraftInProcess(req, draftWhere, columns, req.user.id)
  }

  if (draftInProcessByUser && _isValidWithDraftTimeout(isActiveEntity, siblingIsActive, draftInProcessByUser)) {
    return _activeWithDraftInProcess(req, draftWhere, columns, null)
  }
}

const _validatedDraftOfWhichIAmOwner = (req, draftWhere, draftParameters, columns) =>
  _isValidDraftOfWhichIAmOwner(draftParameters.isActiveEntity) && _draftOfWhichIAmOwner(req, draftWhere, columns)

const _draftInSubSelect = (where, req) => {
  return where.some(({ SELECT, xpr }) => {
    if (xpr) {
      return _draftInSubSelect(xpr, req)
    }

    if (SELECT && SELECT.where) {
      const isActiveEntity = readAndDeleteKeywords(['IsActiveEntity'], SELECT.where, false)
      if (isActiveEntity) {
        return _isFalse(isActiveEntity.value.val)
      }

      return _draftInSubSelect(SELECT.where, req)
    }

    return false
  })
}

const _isDraftAdminScenario = req =>
  req.target.query && req.target.query._target && req.target.query._target.name === 'DRAFT.DraftAdministrativeData'

const _generateCQN = (req, columns, from, model) => {
  const nav = [...from.ref].reverse() || []
  let siblingIndex = nav.indexOf('SiblingEntity')

  // it can also be a property access (new parser), then we must shift it
  if (siblingIndex > 0 && req.target.elements[nav[0]] && !req.target.elements[nav[0]].isAssociation) {
    nav.shift()
    siblingIndex = siblingIndex - 1
  }

  let siblingScenario
  if (siblingIndex > -1) {
    siblingScenario = _getSiblingScenario(req, columns, model, siblingIndex, nav)
    if (siblingIndex === 0) return siblingScenario
    _mergeSiblingIntoCQN(req.query, siblingScenario, siblingIndex - 1)
  }

  if (_isDraftAdminScenario(req)) return _draftAdminTable(req)
  if (!req.query.SELECT.where) return _allActive(req, columns)

  // REVISIT this function does not only read, but modifies where!
  const draftParameters = _readDraftParameters(req.query.SELECT.where)

  if (
    draftParameters.isActiveEntity &&
    _isTrue(draftParameters.isActiveEntity.value.val) &&
    !(draftParameters.siblingIsActive && draftParameters.siblingIsActive.value.val === null) &&
    !draftParameters.hasDraftEntity
  ) {
    return _allActive(req, columns)
  }

  if (!draftParameters.isActiveEntity) {
    if (_draftInSubSelect(req.query.SELECT.where, req) || (siblingScenario && !siblingScenario.isSiblingActive)) {
      // this is only the case when navigating into tree
      return _allInactive(req, columns)
    }

    return _allActive(req, columns)
  }

  if (draftParameters.hasDraftEntity) {
    return _validatedActiveWithoutDraft(req, req.query.SELECT.where, draftParameters, columns)
  }

  if (draftParameters.siblingIsActive) {
    return _validatedWithSiblingInProcess(req, req.query.SELECT.where, draftParameters, columns, model)
  }

  return _validatedDraftOfWhichIAmOwner(req, req.query.SELECT.where, draftParameters, columns)
}

const _isIsActiveEntity = element => element.ref && element.ref[element.ref.length - 1] === 'IsActiveEntity'

const _adaptSubSelects = ({ SELECT: { from, where } }, scenario) => {
  if (!where) return

  if (scenario === 'ALL_INACTIVE') {
    replaceRefWithDraft(from.ref)
  }

  for (let i = 0; i < where.length; i++) {
    const element = where[i]

    if (_isIsActiveEntity(element) && where.length > i + 2) {
      if (
        (scenario !== 'ALL_INACTIVE' && _isFalse(where[i + 2].val)) ||
        (scenario === SCENARIO.DRAFT_ADMIN && !_isFalse(where[i + 2].val))
      ) {
        replaceRefWithDraft(from.ref)
      }

      if (!_isIsActiveEntity(where[i + 2])) {
        i = deleteCondition(i, where) - 1
      } else {
        i = i + 3 < where.length ? i + 2 : i + 3
      }
    } else if (element.SELECT) {
      _adaptSubSelects(element, scenario)
    } else if (element.xpr) {
      for (const ele of element.xpr.filter(e => e.SELECT)) {
        _adaptSubSelects(ele, scenario)
      }
    }
  }
}

const _calculateDraftAdminColumns = (result, user, deleteLastChangeDateTime) => {
  if (!result) return
  if ('InProcessByUser' in result && !draftIsLocked(result.LastChangeDateTime)) result.InProcessByUser = ''
  if (deleteLastChangeDateTime) delete result.LastChangeDateTime
  if ('DraftIsCreatedByMe' in result && 'CreatedByUser' in result)
    result.DraftIsCreatedByMe = result.CreatedByUser === user
  if ('DraftIsProcessedByMe' in result && 'InProcessByUser' in result)
    result.DraftIsProcessedByMe = result.InProcessByUser === user
}

const _adaptDraftColumnsForSiblingEntity = (result, isSiblingActive) => {
  result.IsActiveEntity = isSiblingActive
  result.HasDraftEntity = isSiblingActive
  result.HasActiveEntity = !isSiblingActive
}

const _collectAliases = (from, aliases) => {
  if (!from) return
  if (from.ref && from.as) {
    // Actually table names in where annotations should be provided with '.' separator.
    // Normalization to '_' is done for the exceptional case if '_' is still used (based on db table names).
    aliases.set(from.ref[0].replace(/\./g, '_'), from.as)
  } else if (from.args) {
    from.args.forEach(arg => {
      _collectAliases(arg, aliases)
    })
  } else if (from.SET && from.SET.args) {
    from.SET.args.forEach(arg => {
      _collectAliases(arg, aliases)
    })
  }
}

const _adaptAnnotationAliases = cqn => {
  const aliases = new Map()
  _collectAliases(cqn.SELECT.from, aliases)
}

const enhanceQueryForTimeoutIfNeeded = (scenario, columns = []) => {
  if (scenario !== SCENARIO.DRAFT_ADMIN) {
    const draftAdmin = columns.find(col => col.ref && col.ref[col.ref.length - 1] === 'DraftAdministrativeData')
    columns = (draftAdmin && draftAdmin.expand) || []
  }
  const inProcessByUser = columns.find(col => col.ref && col.ref[col.ref.length - 1] === 'InProcessByUser')
  const lastChangeDateTime = columns.find(col => col.ref && col.ref[col.ref.length - 1] === 'LastChangeDateTime')
  if (inProcessByUser && !lastChangeDateTime) {
    columns.push({ ref: [...inProcessByUser.ref.slice(0, inProcessByUser.ref.length - 1), 'LastChangeDateTime'] })
    return true
  }
}

// REVISIT: HACK for sqlite support, union not yet properly supported in before handler on db
// remove once union is removed, should be part of before handler
const _getLocalizedEntity = (model, target, user) => {
  const prefix = 'localized'
  let localizedEntity
  /*
   * REVISIT: in case of not sqlite, model.definitions[`${prefix}.${user.locale}.${target.name}`] is undefined
   * and the fallback lookup model.definitions[`${prefix}.${target.name}`] gets the entity -> bad coding
   */
  if (cds.env.i18n.for_sqlite.includes(user.locale)) {
    localizedEntity = model.definitions[`${prefix}.${user.locale}.${target.name}`]
  }

  return localizedEntity || model.definitions[`${prefix}.${target.name}`]
}

const _getLastSubQuery = query => (query.SELECT.from.SELECT ? _getLastSubQuery(query.SELECT.from) : query)
const _setLastSubQuery = (query, last, prev = query) => {
  if (query.SELECT.from.SELECT) return _setLastSubQuery(query.SELECT.from, last, query)
  else prev.SELECT.from = _copyCQNPartial(last)
  return prev
}

const _adaptDraftAdminExpand = cqn => {
  const draftAdminExpand =
    cqn.SELECT.columns && cqn.SELECT.columns.find(c => c.expand && c.ref[0] === 'DraftAdministrativeData')

  if (draftAdminExpand) {
    _ensureDraftAdminColumnsForCalculation(draftAdminExpand.expand)
  }
}

const _getOriginalColumns = req => {
  const originalColumns = {}
  // expanded columns are handled generically in db
  for (const c of req.query.SELECT.columns) {
    originalColumns[c.as || (c.ref && c.ref[c.ref.length - 1]) || c] = true
  }

  return originalColumns
}

const _handlerStreaming = (req, query) => {
  adaptStreamCQN(query)
  query._streaming = true
  return cds.tx(req).run(query)
}

const _postProcess = (result, req, cqnScenario, deleteLastChangeDateTime) => {
  const resultAsArray = Array.isArray(result) ? result : result ? [result] : []
  if (!result || !resultAsArray.length) return result

  if (cqnScenario.scenario === SCENARIO.SIBLING_ENTITY) {
    if (resultAsArray[0].draftAdmin_inProcessByUser !== req.user.id) return []
    delete resultAsArray[0].draftAdmin_inProcessByUser
    _adaptDraftColumnsForSiblingEntity(resultAsArray[0], cqnScenario.isSiblingActive)
  }

  const removeDraftUUIDIfNecessaryFn = removeDraftUUIDIfNecessary(req)
  let notRequestedColumns
  if (!req.query.SELECT._4odata) {
    const originalColumns = _getOriginalColumns(req)
    notRequestedColumns = originalColumns && Object.keys(resultAsArray[0]).filter(key => !originalColumns[key])
  }

  if (cqnScenario.scenario === SCENARIO.DRAFT_ADMIN) {
    _calculateDraftAdminColumns(resultAsArray[0], req.user.id, deleteLastChangeDateTime)
    if (notRequestedColumns) {
      for (const key of notRequestedColumns) delete resultAsArray[0][key]
    }
  } else {
    for (const row of resultAsArray) {
      removeDraftUUIDIfNecessaryFn(row)
      _calculateDraftAdminColumns(row.DraftAdministrativeData, req.user.id, deleteLastChangeDateTime)
      if (notRequestedColumns) {
        for (const key of notRequestedColumns) delete row[key]
      }
    }
  }

  if (result.HasActiveEntity === null) result.HasActiveEntity = false
  if (result.HasDraftEntity === null) result.HasDraftEntity = false
  if (result.IsActiveEntity === null) result.IsActiveEntity = false
  return result
}

const _fnCompare = elName => c => (c.as && c.as === elName) || (c.ref && c.ref[c.ref.length - 1] === elName)
const _adaptColumns4readAfterWrite = (req, cqnScenario, query4sql) => {
  if (
    !(req.context.event === 'EDIT' && cqnScenario.scenario === SCENARIO.DRAFT_WHICH_OWNER) &&
    !(req.context.event === 'draftActivate' && cqnScenario.scenario === SCENARIO.ALL_ACTIVE)
  )
    return

  // cleanup columns if not requested with $select or $expand
  cqnScenario.cqn.SELECT.columns = cqnScenario.cqn.SELECT.columns.reduce((columns, column) => {
    const elName = column.as || (column.ref && column.ref[column.ref.length - 1])
    if (query4sql.SELECT.columns.find(_fnCompare(elName)) || elName in req.target.keys) columns.push(column)
    return columns
  }, [])

  // add missing keys
  const isActive = req.context.event === 'draftActivate'
  // aliasing is fixed by scenarios
  const alias = isActive ? 'active' : req.target.drafts.name
  for (const key in req.target.keys) {
    if (req.target.keys[key].isAssociation) continue
    if (!cqnScenario.cqn.SELECT.columns.find(_fnCompare(key))) {
      const column =
        key === 'IsActiveEntity'
          ? { val: isActive, as: 'IsActiveEntity', cast: { type: 'cds.Boolean' } }
          : { ref: [alias, key] }
      cqnScenario.cqn.SELECT.columns.push(column)
    }
  }
}

/**
 * Generic Handler for READ requests in the context of draft.
 *
 * @param req
 */
const fioriGenericRead = async function (req) {
  if (!cds.db) req.reject('NO_DATABASE_CONNECTION')

  const query = req.query
  const originalFrom = _copyCQNPartial(query.SELECT.from)

  // handle localized here as it was previously handled for req.target
  req.target = _getLocalizedEntity(this.model, req.target, req.user) || req.target

  // REVISIT DRAFT HANDLING: cqn2cqn4sql must not be called here
  const query4sql = cqn2cqn4sql(_copyCQNPartial(req.query), this.model, { _4fiori: true })

  // Clone the request. Do not clone with Object.assign as that would skip all non-enumerable properties.
  // REVISIT: query4sql.clone() doesn't really clone the original query, hence _generateCQN will heavily modify
  // it, e.g. IsActiveEntity is stripped. This is a problem for subsequent handlers which rely on this information.
  const reqClone = { __proto__: req, query: query4sql }
  // Clone draft restrictions to the cloned query.
  reqClone.query._draftRestrictions = query._draftRestrictions

  if (query._streaming) return _handlerStreaming(req, reqClone.query)

  let cqnScenario

  // to replace scenario CQNs for queries with $apply SELECT chain (new odata2cqn parser)
  // just to make existing tests working with new parser. not really tested, not needed to be supported
  if (reqClone.query.SELECT.from.SELECT) {
    const subQueryReq = { __proto__: req, query: _copyCQNPartial(_getLastSubQuery(reqClone.query)) }
    const nonDraftColumns = filterNonDraftColumns(subQueryReq.query.SELECT.columns)
    cqnScenario = _generateCQN(subQueryReq, nonDraftColumns, originalFrom.SELECT.from, this.model)
    cqnScenario.cqn = _setLastSubQuery(reqClone.query, cqnScenario.cqn)
  } else {
    const nonDraftColumns = filterNonDraftColumns(reqClone.query.SELECT.columns)
    cqnScenario = _generateCQN(reqClone, nonDraftColumns, originalFrom, this.model)
  }

  if (!cqnScenario) throw getError(501)

  // ensure base columns for calculation are selected in draft admin expand
  _adaptDraftAdminExpand(cqnScenario.cqn)

  if (cqnScenario.scenario === SCENARIO.ALL_ACTIVE && cqnScenario.cqn.SELECT.where) {
    cqnScenario.cqn.SELECT.where = removeIsActiveEntityRecursively(cqnScenario.cqn.SELECT.where)
  }

  const enhancedWithLastChangeDateTime = enhanceQueryForTimeoutIfNeeded(
    cqnScenario.scenario,
    cqnScenario.cqn.SELECT.columns
  )

  _adaptSubSelects(cqnScenario.cqn, cqnScenario.scenario)
  _adaptAnnotationAliases(cqnScenario.cqn)

  // unlocalize for db and after handlers as it was before
  req.target = this.model.definitions[ensureUnlocalized(req.target.name)]

  _adaptColumns4readAfterWrite(req, cqnScenario, query4sql)

  const result = await cds.tx(req).send({ query: cqnScenario.cqn, target: req.target })
  return _postProcess(result, reqClone, cqnScenario, enhancedWithLastChangeDateTime)
}

module.exports = cds.service.impl(function (srv, entity) {
  srv.on('READ', entity, fioriGenericRead)
})
