const cds = require('../cds'),
  { Object_keys } = cds.utils
const LOG = cds.log('fiori|drafts')
const original = Symbol('original')

const DRAFT_ELEMENTS = new Set([
  'IsActiveEntity',
  'HasDraftEntity',
  'HasActiveEntity',
  'DraftAdministrativeData',
  'DraftAdministrativeData_DraftUUID',
  'SiblingEntity'
])

const REDUCED_DRAFT_ELEMENTS = new Set(['IsActiveEntity', 'HasDraftEntity', 'SiblingEntity'])

const DRAFT_ADMIN_ELEMENTS = [
  'DraftUUID',
  'LastChangedByUser',
  'LastChangeDateTime',
  'CreatedByUser',
  'CreationDateTime',
  'InProcessByUser',
  'DraftIsCreatedByMe',
  'DraftIsProcessedByMe'
]

const _fillIsActiveEntity = (row, IsActiveEntity, target) => {
  if (target.drafts) row.IsActiveEntity = IsActiveEntity
  for (const key in target.associations) {
    const prop = row[key]
    if (!prop) continue
    const el = target.elements[key]
    const childIsActiveEntity = el._target.isDraft ? IsActiveEntity : true
    if (Array.isArray(prop)) prop.map(r => _fillIsActiveEntity(r, childIsActiveEntity, el._target))
    else if (typeof prop === 'object') _fillIsActiveEntity(prop, childIsActiveEntity, el._target)
  }
}

// REVISIT: should not be necessary
const _runWithContext = (srv, req, obj) => {
  const r = new cds.Request(obj)
  r.event // invoke getter
  r._ = Object.assign(r._, req._)
  if (req.getUriInfo) r.getUriInfo = () => req.getUriInfo()
  if (req.getUrlObject) r.getUrlObject = () => req.getUrlObject()
  r._.params = req.params
  r._.query = req.query
  return srv.dispatch(r)
}

/// It's important to wait for the completion of all promises, otherwise a rollback might happen too soon
const _promiseAll = async array => {
  const results = await Promise.allSettled(array)
  const e = results.find(r => r.status === 'rejected')
  if (e) throw e.reason
  return results.map(r => r.value)
}

const _isCount = query => query.SELECT.columns?.length === 1 && query.SELECT.columns[0].func === 'count'

const _inProcessByUserXpr = lockShiftedNow => ({
  xpr: [
    'case',
    'when',
    { ref: ['LastChangeDateTime'] },
    '<',
    { val: lockShiftedNow },
    'then',
    { val: '' },
    'else',
    { ref: ['InProcessByUser'] },
    'end'
  ],
  as: 'InProcessByUser',
  cast: { type: 'cds.String' }
})

const _lock = {
  get shiftedNow() {
    return new Date(Math.max(0, Date.now() - DRAFT_CANCEL_TIMEOUT_IN_MIN() * 60 * 1000)).toISOString()
  }
}

const DRAFT_CANCEL_TIMEOUT_IN_MIN = () =>
  (cds.env.drafts?.cancellationTimeout && Number(cds.env.drafts?.cancellationTimeout)) || 15

const _redirectRefToDrafts = (ref, model) => {
  const [root, ...tail] = ref
  const draft = model.definitions[root.id || root].drafts
  return [root.id ? { ...root, id: draft.name } : draft.name, ...tail]
}

const _redirectRefToActives = (ref, model) => {
  const [root, ...tail] = ref
  const active = model.definitions[root.id || root].actives
  return [root.id ? { ...root, id: active.name } : active.name, ...tail]
}

const h = cds.ApplicationService.prototype.handle
/* eslint-disable complexity */
cds.ApplicationService.prototype.handle = async function (req) {
  const handle = h.bind(this)

  if (
    !req.query ||
    req.query.UPSERT || // skip UPSERTs (might have an additional INSERT)
    (!req.query.SELECT && !req.query.INSERT && !req.query.UPDATE && !req.query.DELETE) ||
    req.query._draftParams
  )
    return handle(req)
  const query = _cleansed(req.query, this.model)
  _cleanseParams(req.params, req.target)
  if (req.data) _cleanseParams(req.data, req.target)
  const draftParams = query._draftParams

  const _newReq = (req, query, draftParams, event) => {
    // REVISIT: This is a bit hacky -> better way?
    query._target = undefined
    query._draftParams = draftParams
    cds.infer(query, this.model.definitions)

    // REVISIT: This is extremely bad. We should be able to just create a copy without such hacks.
    const _req = cds.Request.for(req._) // REVISIT: this causes req._.data of WRITE reqs copied to READ reqs
    // If we create a `READ` event based on a modifying request, we delete data
    if (event === 'READ' && req.event !== 'READ') delete _req.data // which we fix here -> but this is an ugly workaround
    _req.query = query
    _req.event =
      event ||
      (query.SELECT && 'READ') ||
      (query.INSERT && 'CREATE') ||
      (query.UPDATE && 'UPDATE') ||
      (query.DELETE && 'DELETE') ||
      req.event
    _req.target = query._target
    _req.params = req.params
    _req._ = Object.assign({}, req._ || {})
    _req._.params = req.params
    _req._.query = query
    const props = ['_isRest', '_isOData', 'isConcurrentResource', 'isConditional', 'validateEtag']
    props.forEach(p => {
      if (req[p]) _req.p = req[p]
    })
    _req._ = req._
    const cqnData = _req.query.UPDATE?.data || _req.query.INSERT?.entries?.[0]
    if (cqnData) _req.data = cqnData // must point to the same object
    Object.defineProperty(_req, '_messages', {
      get: function () {
        return req._messages
      }
    })
    if (req.tx) _req.tx = req.tx
    return _req
  }

  const run = async query => {
    const _req = _newReq(req, query, draftParams)
    return handle(_req)
  }

  if (req.event === 'NEW' || req.event === 'CANCEL' || req.event === 'draftPrepare') {
    if (draftParams.IsActiveEntity) req.reject(501)
    req.target = req.target.drafts

    if (query.INSERT?.into) {
      if (typeof query.INSERT.into === 'string') query.INSERT.into = req.target.name
      else if (query.INSERT.into.ref) query.INSERT.into.ref = _redirectRefToDrafts(query.INSERT.into.ref, this.model)
    } else if (query.DELETE?.from?.ref) query.DELETE.from.ref = _redirectRefToDrafts(query.DELETE.from.ref, this.model)
    else if (query.SELECT?.from?.ref) query.SELECT.from.ref = _redirectRefToDrafts(query.SELECT.from.ref, this.model)
    const _req = _newReq(req, query, draftParams, req.event)
    const result = await handle(_req)
    return result
  }

  if (req.event === 'DELETE' && draftParams.IsActiveEntity) {
    const draftsRef = _redirectRefToDrafts(query.DELETE.from.ref, this.model)
    // NOTE: Check if draft is locked!
    const draft = await run(
      SELECT.one.from({ ref: draftsRef }).columns([
        { ref: ['DraftAdministrativeData_DraftUUID'] },
        {
          ref: ['DraftAdministrativeData'],
          expand: [_inProcessByUserXpr(_lock.shiftedNow)]
        }
      ])
    )
    const inProcessByUser = draft?.DraftAdministrativeData?.InProcessByUser
    if (inProcessByUser && inProcessByUser !== cds.context.user.id)
      req.reject(403, 'DRAFT_LOCKED_BY_ANOTHER_USER', [inProcessByUser])
    const deletes = [run(DELETE.from({ ref: query.DELETE.from.ref }))]
    if (draft)
      deletes.push(
        run(
          DELETE.from(req.target.drafts).where({
            DraftAdministrativeData_DraftUUID: draft.DraftAdministrativeData_DraftUUID
          })
        )
      )
    if (draft && req.target['@Common.DraftRoot.ActivationAction'])
      deletes.push(
        DELETE.from('DRAFT.DraftAdministrativeData').where({ DraftUUID: draft.DraftAdministrativeData_DraftUUID })
      )
    await _promiseAll(deletes)
    return req.data
  }

  if (req.event === 'draftActivate') {
    LOG.debug('activate draft')
    // It would be great if we'd have a SELECT ** to deeply expand the entity (along compositions), that should
    // be implemented in expand implementation.
    if (req.query.SELECT.from.ref.length > 1 || draftParams.IsActiveEntity !== false) {
      req.reject(400, 'Action "draftActivate" can only be called on the root draft entity')
    }
    const targetDraft = req.target.drafts
    const targetWhere = query.SELECT.from.ref[0].where
    const cols = expandStarStar(targetDraft)
    const res = await run(
      SELECT.one
        .from(targetDraft)
        .columns(cols)
        .columns([
          'HasActiveEntity',
          'DraftAdministrativeData_DraftUUID',
          { ref: ['DraftAdministrativeData'], expand: [{ ref: ['InProcessByUser'] }] }
        ])
        .where(targetWhere)
    )
    if (!res) req.reject(404)
    if (res.DraftAdministrativeData?.InProcessByUser !== cds.context.user.id)
      req.reject(403, 'DRAFT_LOCKED_BY_ANOTHER_USER', [res.DraftAdministrativeData?.InProcessByUser])
    const DraftAdministrativeData_DraftUUID = res.DraftAdministrativeData_DraftUUID
    delete res.DraftAdministrativeData_DraftUUID
    delete res.DraftAdministrativeData
    const HasActiveEntity = res.HasActiveEntity
    delete res.HasActiveEntity
    delete res.IsActiveEntity
    // First run the handlers as they might need access to DraftAdministrativeData or the draft entities
    const result = await run(
      HasActiveEntity ? UPDATE(req.target).data(res).where(targetWhere) : INSERT.into(req.target).entries(res)
    )
    await _promiseAll([
      run(DELETE.from(targetDraft).where(targetWhere)),
      DELETE.from('DRAFT.DraftAdministrativeData').where({ DraftUUID: DraftAdministrativeData_DraftUUID })
    ])

    req?._?.odataRes?.setStatusCode(201)

    return Object.assign(result, { IsActiveEntity: true })

    // REVISIT: we need to use okra API here because it must be set in the batched request
    // status code must be set in handler to allow overriding for FE V2
  }

  if (req.target.actions?.[req.event] && draftParams.IsActiveEntity === false) {
    if (query.SELECT?.from?.ref) query.SELECT.from.ref = _redirectRefToDrafts(query.SELECT.from.ref, this.model)
    const rootQuery = query.clone()
    rootQuery.SELECT.columns = [{ ref: ['DraftAdministrativeData'], expand: [{ ref: ['InProcessByUser'] }] }]
    rootQuery.SELECT.one = true
    const root = await run(rootQuery)
    if (!root) req.reject(404)
    if (root.DraftAdministrativeData?.InProcessByUser !== cds.context.user.id) req.reject(403)
    const _req = _newReq(req, query, draftParams, req.event)
    const result = await handle(_req)
    return result
  }

  if (req.event === 'PATCH') {
    if (draftParams.IsActiveEntity) req.reject(501)
    if (!('IsActiveEntity' in draftParams)) {
      const res = await run(
        SELECT.one.from({ ref: req.UPDATE.entity.ref }).columns('DraftAdministrativeData_DraftUUID')
      )
      if (res) req.reject(403, 'DRAFT_ALREADY_EXISTS')
      const _req = _newReq(req, query, draftParams, 'UPDATE')
      const result = await handle(_req)
      return result
    }
    if (draftParams.IsActiveEntity === false) {
      LOG.debug('patch draft')
      if (req.target?.name.endsWith('DraftAdministrativeData')) req.reject(405)
      const draftsRef = _redirectRefToDrafts(query.UPDATE.entity.ref, this.model)
      const res = await run(
        SELECT.one.from({ ref: draftsRef }).columns('DraftAdministrativeData_DraftUUID', {
          ref: ['DraftAdministrativeData'],
          expand: [{ ref: ['InProcessByUser'] }]
        })
      )
      if (!res) req.reject(404)
      if (res.DraftAdministrativeData?.InProcessByUser !== cds.context.user.id)
        req.reject(403, 'DRAFT_LOCKED_BY_ANOTHER_USER', [res.DraftAdministrativeData?.InProcessByUser])
      await UPDATE('DRAFT.DraftAdministrativeData')
        .data({
          InProcessByUser: req.user.id,
          LastChangedByUser: req.user.id,
          LastChangeDateTime: new Date()
        })
        .where({ DraftUUID: res.DraftAdministrativeData_DraftUUID })

      const updateData = { ...req.data }
      delete updateData.IsActiveEntity
      await run(UPDATE({ ref: draftsRef }).data(updateData))
      req.data.IsActiveEntity = false
      return req.data
    }
  }

  if (req.event === 'READ') {
    if (
      !Object.keys(draftParams).length &&
      !req.query._target.name?.endsWith('DraftAdministrativeData') &&
      !req.query._target.drafts
    ) {
      req.query = query
      return handle(req)
    }
    const read = req.query._target.name.endsWith('.drafts')
      ? Read.ownDrafts
      : draftParams.IsActiveEntity === false && draftParams.SiblingEntity_IsActiveEntity === null
      ? Read.all
      : draftParams.IsActiveEntity === true &&
        draftParams.SiblingEntity_IsActiveEntity === null &&
        (draftParams.DraftAdministrativeData_InProcessByUser === 'not null' ||
          draftParams.DraftAdministrativeData_InProcessByUser === 'not ')
      ? Read.lockedByAnotherUser
      : draftParams.IsActiveEntity === true &&
        draftParams.SiblingEntity_IsActiveEntity === null &&
        draftParams.DraftAdministrativeData_InProcessByUser === ''
      ? Read.unsavedChangesByAnotherUser
      : draftParams.IsActiveEntity === true && draftParams.HasDraftEntity === false
      ? Read.unchanged
      : draftParams.IsActiveEntity === true
      ? Read.onlyActives
      : draftParams.IsActiveEntity === false
      ? Read.ownDrafts
      : Read.onlyActives
    const result = await read(run, query)
    return result
  }

  req.query = query
  const result = await handle(req)
  return result
}

// REVISIT: It's not optimal to first calculate the whole result array and only later
//          delete unrequested properties. However, as a first step, we do it that way,
//          especially since the current db driver always adds those fields.
//          Once we switch to the new driver, we'll adapt it.
const _requested = (result, query) => {
  const originalQuery = query[original]
  if (!result || !originalQuery) return result
  const all = ['HasActiveEntity', 'HasDraftEntity']

  const ignoredCols = new Set(all.concat('DraftAdministrativeData'))
  const _isODataV2 = cds.context?.http?.req?.headers?.['x-cds-odata-version'] === 'v2'
  if (!_isODataV2) ignoredCols.add('DraftAdministrativeData_DraftUUID')
  for (const col of originalQuery.SELECT.columns || ['*']) {
    const name = col.as || col.ref?.[0] || col
    if (all.includes(name) || name === 'DraftAdministrativeData' || name === 'DraftAdministrativeData_DraftUUID')
      ignoredCols.delete(name)
    if (name === '*') all.forEach(c => ignoredCols.delete(c))
  }
  if (!ignoredCols.size) return result
  const resArray = Array.isArray(result) ? result : [result]
  for (const row of resArray) {
    for (const ignoredCol of ignoredCols) delete row[ignoredCol]
  }
  return result
}

const Read = {
  onlyActives: async function (run, query, { ignoreDrafts } = {}) {
    LOG.debug('List Editing Status: Only Active')
    // DraftAdministrativeData is only accessible via drafts
    if (_isCount(query)) return run(query)
    if (query._target.name.endsWith('.DraftAdministrativeData')) return run(query._drafts)
    if (!query._target._isDraftEnabled) return run(query)
    if (!query.SELECT.groupBy && query.SELECT.columns && !query.SELECT.columns.some(c => c === '*')) {
      const keys = Object_keys(query._target.keys).filter(k => k !== 'IsActiveEntity')
      for (const key of keys) {
        if (!query.SELECT.columns.some(c => c.ref?.[0] === key)) query.SELECT.columns.push({ ref: [key] })
      }
    }
    const actives = await run(query)
    if (!actives || (Array.isArray(actives) && !actives.length) || !query._target.drafts) return actives
    let drafts
    if (ignoreDrafts) drafts = []
    else {
      try {
        drafts = await Read.complementaryDrafts(run, query, actives)
      } catch (e) {
        drafts = []
      }
    }
    Read.merge(query._target, actives, drafts, (row, other) => {
      if (other) Object.assign(row, other, { HasActiveEntity: false, HasDraftEntity: true })
      else
        Object.assign(row, {
          HasActiveEntity: false,
          HasDraftEntity: false,
          DraftAdministrativeData: null,
          DraftAdministrativeData_DraftUUID: null
        })
      _fillIsActiveEntity(row, true, query._target)
    })
    return _requested(actives, query)
  },
  unchanged: async function (run, query) {
    LOG.debug('List Editing Status: Unchanged')
    const draftsQuery = query._drafts
    const keys = Object_keys(query._target.keys).filter(k => k !== 'IsActiveEntity')
    draftsQuery.SELECT.count = undefined
    draftsQuery.SELECT.limit = undefined
    draftsQuery.SELECT.orderBy = undefined
    draftsQuery.SELECT.columns = keys.map(k => ({ ref: [k] }))

    const drafts = await run(draftsQuery)
    const res = await Read.onlyActives(run, query.where(Read.whereNotIn(query._target, drafts)), {
      ignoreDrafts: true
    })
    return _requested(res, query)
  },
  ownDrafts: async function (run, query) {
    LOG.debug('List Editing Status: Own Draft')

    // read active from draft
    if (!query._drafts._target?.name.endsWith('.drafts')) {
      const result = await run(query._drafts)

      // active entity is draft enabled, draft columns have to be removed
      if (query._drafts._target?.drafts) {
        Read.merge(query._drafts._target, result, [], row => {
          delete row.IsActiveEntity
          delete row.HasDraftEntity
          delete row.HasActiveEntity
          delete row.DraftAdministrativeData_DraftUUID
        })
      }
      return result
    }
    const draftsQuery = query._drafts.where(
      { ref: ['DraftAdministrativeData', 'InProcessByUser'] },
      '=',
      cds.context.user.id
    )
    const drafts = await run(draftsQuery)
    Read.merge(query._target, drafts, [], row => {
      Object.assign(row, {
        HasDraftEntity: false
      })
      _fillIsActiveEntity(row, false, query._drafts._target)
    })
    return _requested(drafts, query)
  },
  all: async function (run, query) {
    LOG.debug('List Editing Status: All')
    query._drafts.SELECT.count = false
    query._drafts.SELECT.limit = undefined // We need all entries for the keys to properly select actives (count)
    const isCount = _isCount(query._drafts)
    if (isCount) {
      const keys = Object_keys(query._target.keys).filter(k => k !== 'IsActiveEntity')
      query._drafts.SELECT.columns = keys.map(k => ({ ref: [k] }))
    }
    if (!query._drafts.SELECT.columns) query._drafts.SELECT.columns = ['*']
    if (!query._drafts.SELECT.columns.some(c => c.ref?.[0] === 'HasActiveEntity'))
      query._drafts.SELECT.columns.push({ ref: ['HasActiveEntity'] })

    const isFirstPage = !query.SELECT.limit?.offset?.val

    const [ownDrafts, actives] = await Promise.all([
      isFirstPage
        ? run(query._drafts.where({ ref: ['DraftAdministrativeData', 'InProcessByUser'] }, '=', cds.context.user.id))
        : [], // we only show drafts on the first page
      run(query)
    ])

    const ownNewDrafts = []
    const ownEditDrafts = []
    for (const draft of ownDrafts) {
      if (draft.HasActiveEntity) ownEditDrafts.push(draft)
      else ownNewDrafts.push(draft)
    }

    // We can't properly calculate `count`:
    //   - Not all actives are retrieved (e.g. top = 0), hence there could be more deletes if more actives are requested,
    //     hence we cannot count deletions based on data.
    //   - We can't rely on the fact that `HasActiveEntity` always has an active counterpart because the filter
    //     is applied on draft and active data respectively (you could fetch a draft but not an active instance).
    //     However, there's not much we can do, so we use use this as a best guess.

    const count = isFirstPage ? ownNewDrafts.length + (isCount ? actives[0]?.$count : actives.$count) : actives.$count
    if (isCount) return { $count: count }

    Read.merge(query._target, ownDrafts, [], row => {
      Object.assign(row, {
        HasDraftEntity: false
      })
      _fillIsActiveEntity(row, false, query._drafts._target)
    })
    Read.delete(query._target, actives, ownEditDrafts)
    const otherEditDrafts = await Read.complementaryDrafts(run, query, actives)
    Read.merge(query._target, actives, otherEditDrafts, (row, other) => {
      if (other) {
        Object.assign(row, {
          HasDraftEntity: true,
          HasActiveEntity: false,
          DraftAdministrativeData_DraftUUID: other.DraftAdministrativeData_DraftUUID,
          DraftAdministrativeData: other.DraftAdministrativeData
        })
      } else {
        Object.assign(row, {
          HasDraftEntity: false,
          HasActiveEntity: false,
          DraftAdministrativeData_DraftUUID: null,
          DraftAdministrativeData: null
        })
      }
      _fillIsActiveEntity(row, true, query._target)
    })
    const res = isFirstPage ? [...ownNewDrafts, ...ownEditDrafts, ...actives] : actives
    if (query.SELECT.count) res.$count = count
    return _requested(res, query)
  },
  activesFromDrafts: async function (run, query, { isLocked = true }) {
    const draftsQuery = query._drafts
    const keys = Object_keys(query._target.keys).filter(k => k !== 'IsActiveEntity')
    const additionalCols = draftsQuery.SELECT.columns
      ? draftsQuery.SELECT.columns.filter(
          c => c.ref && ['DraftAdministrativeData', 'DraftAdministrativeData_DraftUUID'].includes(c.ref[0])
        )
      : [{ ref: ['DraftAdministrativeData_DraftUUID'] }]
    draftsQuery.SELECT.columns = keys.map(k => ({ ref: [k] })).concat(additionalCols)
    draftsQuery.where({
      HasActiveEntity: true,
      'DraftAdministrativeData.InProcessByUser': { '!=': cds.context.user.id },
      'DraftAdministrativeData.LastChangeDateTime': {
        [isLocked ? '>' : '<']: _lock.shiftedNow
      }
    })
    const drafts = await run(draftsQuery)
    const actives = drafts.length
      ? await run(query.where(Read.whereIn(query._target, drafts)))
      : Object.assign([], { $count: 0 })
    Read.merge(query._target, actives, drafts, (row, other) => {
      if (other) Object.assign(row, other, { HasDraftEntity: true, HasActiveEntity: false })
      else Object.assign({ HasDraftEntity: false, HasActiveEntity: false })
      _fillIsActiveEntity(row, true, query._target)
    })
    return _requested(actives, query)
  },
  unsavedChangesByAnotherUser: async function (run, query) {
    LOG.debug('List Editing Status: Unsaved Changes by Another User')
    return Read.activesFromDrafts(run, query, { isLocked: false })
  },
  lockedByAnotherUser: async function (run, query) {
    LOG.debug('List Editing Status: Locked by Another User')
    return Read.activesFromDrafts(run, query, { isLocked: true })
  },
  whereNotIn: (target, data) => Read.whereIn(target, data, true),
  whereIn: (target, data, not = false) => {
    const keys = Object_keys(target.keys).filter(k => k !== 'IsActiveEntity')
    const dataArray = data ? (Array.isArray(data) ? data : [data]) : []
    if (not && !dataArray.length) return []
    return [
      { list: keys.map(k => ({ ref: [k] })) },
      not ? 'not in' : 'in',
      { list: dataArray.map(r => ({ list: keys.map(k => ({ val: r[k] })) })) }
    ]
  },
  complementaryDrafts: (run, query, _actives) => {
    const actives = Array.isArray(_actives) ? _actives : [_actives]
    if (!actives.length) return []
    const drafts = cds.ql.clone(query._drafts)
    drafts.SELECT.where = Read.whereIn(query._target, actives)
    if (drafts.SELECT.columns?.some(c => c === '*')) {
      drafts.SELECT.columns = drafts.SELECT.columns.filter(c => c !== '*')
      if (!drafts.SELECT.columns.some(c => c.ref?.[0] === 'DraftAdministrativeData_DraftUUID')) {
        drafts.SELECT.columns.push({ ref: ['DraftAdministrativeData_DraftUUID'] })
      }
    }
    const relevantColumns = ['DraftAdministrativeData', 'DraftAdministrativeData_DraftUUID']
    drafts.SELECT.columns = (
      drafts.SELECT.columns?.filter(c => c.ref && relevantColumns.includes(c.ref[0])) ||
      relevantColumns.map(k => ({ ref: [k] }))
    ).concat(
      Object_keys(query._target.keys)
        .filter(k => k !== 'IsActiveEntity')
        .map(k => ({ ref: [k] }))
    )
    drafts.SELECT.count = undefined
    drafts.SELECT.search = undefined
    drafts.SELECT.one = undefined
    return run(drafts)
  },
  _makeArray: data => (Array.isArray(data) ? data : data ? [data] : []),
  _index: (target, data) => {
    // Indexes the data for fast key access
    const dataArray = Read._makeArray(data)
    if (!dataArray.length) return
    const _keys = Object_keys(target.keys).filter(k => k !== 'IsActiveEntity')
    const hash = row => _keys.map(k => row[k]).reduce((res, curr) => res + '|$|' + curr, '')
    const hashMap = new Map()
    for (const row of dataArray) hashMap.set(hash(row), row)
    return { hashMap, hash }
  },
  // Calls `cb` for each entry of data with a potential counterpart in otherData
  merge: (target, data, otherData, cb) => {
    const dataArray = Read._makeArray(data)
    if (!dataArray.length) return

    const index = Read._index(target, otherData)
    for (const row of dataArray) {
      const other = index?.hashMap.get(index.hash(row))
      cb(row, other)
    }
  },
  // Deletes entries of data with a counterpart in otherData
  delete: (target, data, otherData) => {
    if (!Array.isArray(data) || !data.length) return

    const index = Read._index(target, otherData)
    let i = data.length
    while (i--) {
      if (index?.hashMap.get(index.hash(data[i]))) data.splice(i, 1)
    }
  }
}

function _cleanseParams(params, target) {
  if (!target?.drafts) return
  if (Array.isArray(params)) {
    for (const param of params) _cleanseParams(param, target)
    return
  }
  if (typeof params === 'object') {
    for (const key in params) {
      if (key === 'IsActiveEntity') {
        const value = params[key]
        delete params[key]
        if (cds.env.fiori?.draft_compat) Object.defineProperty(params, key, { value, enumerable: false })
      }
    }
  }
}

function _cleanseCols(columns, elements, target) {
  // TODO: sometimes target is undefined
  if (!target || typeof columns?.filter !== 'function') return columns
  const filtered = target?.drafts ? columns.filter(c => !elements.has(c.ref?.[0])) : columns
  return filtered.map(c => {
    if (c.expand && c.ref) {
      return { ...c, expand: _cleanseCols(c.expand, elements, target.elements[c.ref[0]]?._target) }
    }
    return c
  })
}

/**
 * Creates a clone of the query, cleanses and collects all draft parameters into ._draftParams.
 */
function _cleansed(query, model) {
  const draftParams = {} //> used to collect draft filter criteria
  const q = _cleanseQuery(query, draftParams, model)
  if (query.SELECT) {
    const getDrafts = () => {
      const draftsQuery = _cleanseQuery(query, {}, model) // could just clone `q` but the latter is ruined by database layer
      draftsQuery._target = undefined
      const [root, ...tail] = draftsQuery.SELECT.from.ref
      const draft = model.definitions[root.id || root].drafts
      draftsQuery.SELECT.from = {
        ref: [root.id ? { ...root, id: draft.name } : draft.name, ...tail]
      }
      cds.infer(draftsQuery, model.definitions)
      // draftsQuery._target = draftsQuery._target?.drafts || draftsQuery._target
      if (query.SELECT.columns && query._target.drafts)
        draftsQuery.SELECT.columns = _cleanseCols(query.SELECT.columns, REDUCED_DRAFT_ELEMENTS, draft)

      if (draftsQuery._target.name.endsWith('.DraftAdministrativeData')) {
        draftsQuery.SELECT.columns = _tweakAdminCols(draftsQuery.SELECT.columns)
      } else if (draftsQuery._target?.name.endsWith('.drafts')) {
        draftsQuery.SELECT.columns = _tweakAdminExpand(draftsQuery.SELECT.columns)
      }
      Object.defineProperty(draftsQuery, '_draftParams', { value: draftParams, enumerable: false })
      Object.defineProperty(q, '_drafts', { value: draftsQuery })
      return draftsQuery
    }
    Object.defineProperty(q, '_drafts', {
      configurable: true,
      get() {
        return getDrafts()
      }
    })
  }

  Object.defineProperty(q, '_draftParams', { value: draftParams, enumerable: false })
  q[original] = query
  return q

  function _cleanseQuery(query, draftParams, model) {
    const target = query._target
    const q = cds.ql.clone(query)

    const ref = q.SELECT?.from.ref || q.UPDATE?.entity.ref || q.INSERT?.into.ref || q.DELETE?.from.ref
    const cqn = q.SELECT || q.UPDATE || q.INSERT || q.DELETE

    if (ref) {
      let entity
      const cleansedRef = ref.map(r => {
        entity = (entity && entity.elements[r.id || r]._target) || model.definitions[r.id || r]
        if (!entity?.drafts) return r
        return r.where ? { ...r, where: _cleanseWhere(r.where, draftParams) } : r
      })
      if (q.SELECT) q.SELECT.from = { ...q.SELECT.from, ref: cleansedRef }
      else if (q.DELETE) q.DELETE.from = { ...q.DELETE.from, ref: cleansedRef }
      else if (q.UPDATE) q.UPDATE.entity = { ...q.UPDATE.entity, ref: cleansedRef }
      else if (q.INSERT) q.INSERT.into = { ...q.INSERT.into, ref: cleansedRef }

      // This only works for simple cases of `SiblingEntity`, e.g. `root(ID=1,IsActiveEntity=false)/SiblingEntity`
      // , check if there are more complicated use cases
      const siblingIdx = cleansedRef.findIndex(r => r === 'SiblingEntity')
      if (siblingIdx !== -1) {
        cleansedRef.splice(siblingIdx, 1)
        draftParams.IsActiveEntity = !draftParams.IsActiveEntity
      }
    }

    if (target.drafts && cqn.where) cqn.where = _cleanseWhere(cqn.where, draftParams)
    if (target.drafts && cqn.orderBy) cqn.orderBy = _cleanseWhere(cqn.orderBy, {})
    if (cqn.columns) cqn.columns = _cleanseCols(cqn.columns, DRAFT_ELEMENTS, target)
    return q
  }

  function _tweakAdminExpand(columns) {
    if (!columns) return columns
    return columns.map(col => {
      if (col.ref?.[0] === 'DraftAdministrativeData') {
        return { ...col, expand: _tweakAdminCols(col.expand) }
      }
      return col
    })
  }

  function _tweakAdminCols(columns) {
    if (!columns || columns.some(c => c === '*')) columns = DRAFT_ADMIN_ELEMENTS.map(k => ({ ref: [k] }))
    return columns.map(col => {
      const name = col.ref?.[0]
      if (!name) return col
      switch (name) {
        case 'DraftAdministrativeData':
          return { ...col, expand: _tweakAdminCols(col.expand) }
        case 'DraftIsCreatedByMe':
          return {
            xpr: [
              'case',
              'when',
              { ref: ['CreatedByUser'] },
              '=',
              { val: cds.context.user.id },
              'then',
              'true',
              'else',
              'false',
              'end'
            ],
            as: 'DraftIsCreatedByMe',
            cast: { type: 'cds.Boolean' }
          }
        case 'InProcessByUser':
          return _inProcessByUserXpr(_lock.shiftedNow)
        case 'DraftIsProcessedByMe':
          return {
            xpr: [
              'case',
              'when',
              { ref: ['InProcessByUser'] },
              '=',
              { val: cds.context.user.id },
              'and',
              { ref: ['LastChangeDateTime'] },
              '>',
              { val: _lock.shiftedNow },
              'then',
              'true',
              'else',
              'false',
              'end'
            ],
            as: 'DraftIsProcessedByMe',
            cast: { type: 'cds.Boolean' }
          }
        default:
          return col
      }
    })
  }

  function _cleanseWhere(xpr, draftParams) {
    const cleansed = []
    for (let i = 0; i < xpr.length; ++i) {
      let x = xpr[i],
        e = x.ref?.[0]
      if (DRAFT_ELEMENTS.has(e) && !xpr[i + 2]) {
        continue
      }
      if (DRAFT_ELEMENTS.has(e) && xpr[i + 2]) {
        let { val } = xpr[i + 2]
        draftParams[x.ref.join('_')] = xpr[i + 1] === '!=' ? (typeof val === 'boolean' ? !val : 'not ' + val) : val
        i += 3
        continue
      }
      if (x.xpr) {
        x = { xpr: _cleanseWhere(x.xpr, draftParams) }
        if (!x.xpr) {
          i += 1
          continue
        }
      }
      cleansed.push(x)
    }
    const last = cleansed[cleansed.length - 1]
    if (last === 'and' || last === 'or') cleansed.pop()
    if (cleansed.length) return cleansed
  }
}

// This function is better defined on DB layer
function expandStarStar(target, recursion = new Map()) {
  const MAX_RECURSION_DEPTH = (cds.env.features.recursion_depth && Number(cds.env.features.recursion_depth)) || 4
  const columns = []
  for (const el in target.elements) {
    const element = target.elements[el]
    if (!element.isAssociation && !DRAFT_ELEMENTS.has(el)) columns.push({ ref: [el] })
    if (!element.isComposition || element._target['@odata.draft.enabled'] === false) continue // happens for texts if not @fiori.draft.enabled
    const _key = target.name + ':' + el
    let cache = recursion.get(_key)
    if (!cache) {
      cache = 1
      recursion.set(_key, cache)
    } else {
      cache++
      recursion.set(_key, cache)
    }
    if (cache >= MAX_RECURSION_DEPTH) return
    const expand = expandStarStar(element._target, recursion)
    if (expand) columns.push({ ref: [el], expand })
  }
  return columns
}

async function onNew(req) {
  LOG.debug('new draft')
  const isRoot = typeof req.query.INSERT.into === 'string' || req.query.INSERT.into.ref?.length === 1
  // Only allowed for pseudo draft roots (entities with this action)
  if (isRoot && !req.target.actives['@Common.DraftRoot.ActivationAction'])
    req.reject(403, 'DRAFT_MODIFICATION_ONLY_VIA_ROOT')
  let DraftUUID
  if (isRoot) DraftUUID = cds.utils.uuid()
  else {
    const rootData = await _runWithContext(this, req, {
      query: SELECT.one(req.query.INSERT.into.ref[0].id)
        .columns([
          { ref: ['DraftAdministrativeData_DraftUUID'] },
          { ref: ['DraftAdministrativeData'], expand: [{ ref: ['InProcessByUser'] }] }
        ])
        .where(req.query.INSERT.into.ref[0].where)
    })
    if (!rootData) req.reject(404)
    if (rootData.DraftAdministrativeData?.InProcessByUser !== req.user.id)
      req.reject(403, 'DRAFT_LOCKED_BY_ANOTHER_USER', [rootData.DraftAdministrativeData.InProcessByUser])
    DraftUUID = rootData.DraftAdministrativeData_DraftUUID
  }
  const timestamp = cds.context.timestamp.toISOString() // REVISIT: toISOString should be done on db layer
  const adminDataCQN = isRoot
    ? INSERT.into('DRAFT.DraftAdministrativeData').entries({
        DraftUUID,
        CreationDateTime: timestamp,
        CreatedByUser: req.user.id,
        LastChangeDateTime: timestamp,
        LastChangedByUser: req.user.id,
        DraftIsCreatedByMe: true, // Dummy values
        DraftIsProcessedByMe: true, // Dummy values
        InProcessByUser: req.user.id
      })
    : UPDATE('DRAFT.DraftAdministrativeData')
        .data({
          InProcessByUser: req.user.id,
          LastChangedByUser: req.user.id,
          LastChangeDateTime: timestamp
        })
        .where({ DraftUUID })

  const _assignDraftData = (obj, target) => {
    const newObj = Object.assign({}, obj, { DraftAdministrativeData_DraftUUID: DraftUUID, HasActiveEntity: false })
    if (!target) return newObj

    // Also support deep insertions
    for (const key in newObj) {
      if (!target.elements[key]?.isComposition) continue
      if (Array.isArray(newObj[key]))
        newObj[key] = newObj[key].map(v => _assignDraftData(v, target.elements[key]._target))
      else if (typeof newObj[key] === 'object') {
        newObj[key] = _assignDraftData(newObj[key], target.elements[key]._target)
      }
    }

    return newObj
  }

  const draftData = _assignDraftData(req.query.INSERT.entries[0], req.target)

  delete draftData.IsActiveEntity
  const draftCQN = INSERT.into(req.target).entries(draftData)

  await _promiseAll([cds.run(adminDataCQN), _runWithContext(this, req, { query: draftCQN })])
  req._.readAfterWrite = true
  return { ...draftData, IsActiveEntity: false }
}

async function onEdit(req) {
  LOG.debug('edit active')
  const draftParams = req.query._draftParams
  if (req.query.SELECT.from.ref.length > 1 || draftParams.IsActiveEntity !== true) {
    req.reject(400, 'Action "draftEdit" can only be called on the root active entity')
  }
  const targetWhere = req.query.SELECT.from.ref[0].where

  if (draftParams.IsActiveEntity !== true) req.reject(400)

  const DraftUUID = cds.utils.uuid()

  const cols = expandStarStar(req.target)
  const _addDraftColumns = (target, columns) => {
    if (target.drafts) {
      columns.push({ val: true, as: 'HasActiveEntity' })
      columns.push({ val: DraftUUID, as: 'DraftAdministrativeData_DraftUUID' })
    }
    for (const col of columns) {
      if (col.expand) {
        const el = target.elements[col.ref[0]]
        _addDraftColumns(el._target, col.expand)
      }
    }
  }
  _addDraftColumns(req.target, cols)

  const existingDraft = SELECT.one(req.target.drafts)
    .columns({ ref: ['DraftAdministrativeData'], expand: [_inProcessByUserXpr(_lock.shiftedNow)] })
    .where(targetWhere)
  // prevent service to check for own user
  Object.defineProperty(existingDraft, '_draftParams', { value: draftParams, enumerable: false })

  const activeCQN = SELECT.one.from(req.target).columns(cols).where(targetWhere)
  activeCQN._suppressLocalization = true // in the future we should be able to just set activeCQN.SELECT.localized = false

  const activeCheck = SELECT.one(req.target).columns([1]).where(targetWhere).forUpdate()
  Object.defineProperty(activeCheck, '_draftParams', { value: draftParams, enumerable: false })
  // It's not possible to use `FOR UPDATE` in HANA if the view contains joins/unions. Unfortunately, we can't resolve the table entity
  // because we must trigger the app-service request on the target entity (which could be delegated to a remote service).
  // The best we can do is to catch a potential error
  await _runWithContext(this, req, { query: activeCheck }).catch(_ => {})

  const [res, draft] = await _promiseAll([
    _runWithContext(this, req, { query: activeCQN }),
    // no user check must be done here...
    _runWithContext(this, req, { query: existingDraft })
  ])

  if (!res) req.reject(404)
  const preserveChanges = req.context?.data?.PreserveChanges
  const inProcessByUser = draft?.DraftAdministrativeData?.InProcessByUser
  if (draft) {
    if (inProcessByUser || preserveChanges) req.reject(409, 'DRAFT_ALREADY_EXISTS')
    const keys = {}
    for (const key in req.target.drafts.keys) keys[key] = res[key]
    await _promiseAll([
      DELETE.from('DRAFT.DraftAdministrativeData').where({ DraftUUID }),
      _runWithContext(this, req, { query: DELETE.from(req.target.drafts).where(keys) })
    ])
  }

  const timestamp = cds.context.timestamp.toISOString() // REVISIT: toISOString should be done on db layer
  await INSERT.into('DRAFT.DraftAdministrativeData').entries({
    DraftUUID,
    CreationDateTime: timestamp,
    CreatedByUser: req.user.id,
    LastChangeDateTime: timestamp,
    LastChangedByUser: req.user.id,
    DraftIsCreatedByMe: true, // Dummy values
    DraftIsProcessedByMe: true, // Dummy values
    InProcessByUser: req.user.id
  })

  const targetDraft = req.target.drafts
  // is set to `null` on srv layer
  res.DraftAdministrativeData_DraftUUID = DraftUUID
  res.HasActiveEntity = true
  delete res.DraftAdministrativeData
  await _runWithContext(this, req, { query: INSERT.into(targetDraft).entries(res) })

  // REVISIT: we need to use okra API here because it must be set in the batched request
  // status code must be set in handler to allow overriding for FE V2
  req?._?.odataRes?.setStatusCode(201)

  return { ...res, IsActiveEntity: false } // REVISIT: Flatten?
}

async function onCancel(req) {
  LOG.debug('delete draft')
  const activeRef = _redirectRefToActives(req.query.DELETE.from.ref, this.model)
  const draftParams = req.query._draftParams

  const draftDelete = SELECT.one
    .from({ ref: req.query.DELETE.from.ref })
    .columns([
      'DraftAdministrativeData_DraftUUID',
      { ref: ['DraftAdministrativeData'], expand: [{ ref: ['InProcessByUser'] }] }
    ])
  // do not add InProcessByUser restriction
  Object.defineProperty(draftDelete, '_draftParams', { value: draftParams, enumerable: false })
  const draft = await _runWithContext(this, req, { query: draftDelete })
  if (draftParams.IsActiveEntity === false && !draft) req.reject(404)
  if (draft && draft.DraftAdministrativeData?.InProcessByUser !== cds.context.user.id)
    req.reject(403, 'DRAFT_LOCKED_BY_ANOTHER_USER', [draft.DraftAdministrativeData?.InProcessByUser])
  const queries = !draft ? [] : [_runWithContext(this, req, { query: DELETE.from({ ref: req.query.DELETE.from.ref }) })]
  if (draft && req.target['@Common.DraftRoot.ActivationAction'])
    // only for draft root
    queries.push(
      DELETE.from('DRAFT.DraftAdministrativeData').where({ DraftUUID: draft.DraftAdministrativeData_DraftUUID })
    )
  else
    queries.push(
      UPDATE('Draft.DraftAdministrativeData')
        .data({
          InProcessByUser: cds.context.user.id,
          LastChangedByUser: cds.context.user.id,
          LastChangeDateTime: cds.context.timestamp.toISOString()
        })
        .where({ DraftUUID: draft.DraftAdministrativeData_DraftUUID })
    )
  if (draftParams.IsActiveEntity) queries.push(_runWithContext(this, req, { query: DELETE.from({ ref: activeRef }) }))
  await _promiseAll(queries)
  return req.data
}

async function onPrepare(req) {
  LOG.debug('prepare draft')
  const draftParams = req.query._draftParams
  if (req.query.SELECT.from.ref.length > 1 || draftParams.IsActiveEntity !== false) {
    req.reject(400, 'Action "draftPrepare" can only be called on the root draft entity')
  }
  const where = req.query.SELECT.from.ref[0].where

  const keys = Object_keys(req.target.keys).filter(k => k !== 'IsActiveEntity')
  const draftQuery = SELECT.one
    .from(req.target, d => {
      d.DraftAdministrativeData(a => a.InProcessByUser)
    })
    .columns(keys)
    .where(where)
  Object.defineProperty(draftQuery, '_draftParams', { value: draftParams, enumerable: false })
  const data = await _runWithContext(this, req, { query: draftQuery })
  if (!data) req.reject(404)
  if (data.DraftAdministrativeData?.InProcessByUser !== req.user.id)
    req.reject(403, 'DRAFT_LOCKED_BY_ANOTHER_USER', [data.DraftAdministrativeData?.InProcessByUser])
  delete data.DraftAdministrativeData
  return { ...data, IsActiveEntity: false }
}

module.exports = { onNew, onEdit, onCancel, onPrepare }
