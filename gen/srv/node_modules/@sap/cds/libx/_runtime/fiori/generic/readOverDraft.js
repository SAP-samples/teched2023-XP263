const cds = require('../../cds')
const { SELECT } = cds.ql
const { getEnrichedCQN, hasDraft, ensureDraftsSuffix } = require('../utils/handler')
const { readAndDeleteKeywords } = require('../utils/where')
const { cqn2cqn4sql } = require('../../common/utils/cqn2cqn4sql')
const { isActiveEntityRequested } = require('../../../_runtime/fiori/utils/where')

const _modifyWhere = (where, context) => {
  for (let i = 0; i < where.length; i++) {
    const element = where[i]

    if (element.xpr) {
      _modifyWhere(element.xpr, context)
      continue
    }

    if (element.SELECT) {
      const subCqnDraft = SELECT.from(
        {
          ref: [...element.SELECT.from.ref],
          as: element.SELECT.from.as
        },
        [1]
      )

      where[i] = subCqnDraft
      _modifyCQN(subCqnDraft, element.SELECT.where, context)
    }
  }
}

const _modifyCQN = (cqnDraft, where, context) => {
  const whereDraft = [...where]
  const result = readAndDeleteKeywords(['IsActiveEntity'], whereDraft)
  cqnDraft.where(whereDraft)

  if (result && result.value.val === false) {
    const fromRef = cqnDraft.SELECT.from.ref
    cqnDraft.SELECT.from.ref[fromRef.length - 1] = ensureDraftsSuffix(fromRef[fromRef.length - 1])
  }
  if (cqnDraft.SELECT.columns) {
    cqnDraft.SELECT.columns = cqnDraft.SELECT.columns.map(e =>
      e.ref && e.ref.includes('IsActiveEntity') ? { val: true, as: 'IsActiveEntity', cast: { type: 'cds.Boolean' } } : e
    )
  }

  _modifyWhere(cqnDraft.SELECT.where, context)
}

const _hasNavToNonDraftEnclosedAssoc = (pathSegments, definitions, excludeAssoc) => {
  if (pathSegments.length < 2) return false
  const entity = definitions[pathSegments[0]]
  const nav = entity.elements[pathSegments[1]]

  if (nav._isAssociationStrict) {
    if (nav['@odata.draft.enclosed']) return false
    if (excludeAssoc == null) return true
    if (!excludeAssoc(nav)) return true
  }

  // At this point we know that nav is a composition, so we have to recursively
  // follow the navigation until we reach the end or find an association.
  pathSegments.shift()
  pathSegments[0] = nav.target
  return _hasNavToNonDraftEnclosedAssoc(pathSegments, definitions, excludeAssoc)
}

const _shouldReadOverDraft = (req, definitions) => {
  const SELECT = req.query.SELECT
  const fromRef = SELECT.from.ref

  if (!fromRef) return false

  // for $expand requests, read over the draft if the navigation target is non-draft-enabled
  // REVISIT: this is an interim workaround to be removed
  if (!req.target._isDraftEnabled && SELECT.columns && SELECT.columns.some(column => column.expand)) return true

  // read over the draft only for navigation scenarios
  if (fromRef.length === 1) return false

  const firstFromRef = fromRef[0]
  const rootEntityName = typeof firstFromRef === 'string' ? firstFromRef : firstFromRef.id
  const rootEntity = definitions[rootEntityName]

  // read over the draft only if the root entity is draft-enabled
  if (!rootEntity._isDraftEnabled) return false

  // read over the draft only if the navigation starts from a draft entity, e.g.,
  // /Books(ID=1, IsActiveEntity=false)
  if (isActiveEntityRequested(firstFromRef.where)) return false

  const pathSegments = fromRef.map(path => (typeof path === 'string' ? path : path.id))
  const excludeAssoc = assoc => {
    if (assoc.name === 'DraftAdministrativeData' || assoc.name === 'SiblingEntity') return true
    return false
  }

  // Read over the draft only if:
  // - the navigation target is an association and
  // - isn't annotated with the @odata.draft.enclosed annotation
  return _hasNavToNonDraftEnclosedAssoc(pathSegments, definitions, excludeAssoc)
}

/**
 * Generic Handler for READ requests.
 *
 * @param {import('../../cds-services/adapter/odata-v4/ODataRequest')} req
 * @param next
 * @returns {Promise<Array>}
 */
const _readOverDraftHandler = async function (req, next) {
  if (!cds.db) req.reject('NO_DATABASE_CONNECTION')

  const definitions = this.model.definitions

  // determine whether the request is handled here (read over draft handler),
  // or whether it is passed to the next registered handler/route
  if (!_shouldReadOverDraft(req, definitions)) return next()

  const rows = req.query.SELECT.limit && req.query.SELECT.limit.rows
  if (rows && rows.val === 0) return Promise.resolve([])

  // REVISIT DRAFT HANDLING: cqn2cqn4sql must not be called here
  const sqlQuery = cqn2cqn4sql(req.query, this.model, { _4db: req.target._isDraftEnabled, _4fiori: true })

  if (req.query._streaming) {
    sqlQuery._streaming = true
  }

  const hasDraftEntity = hasDraft(definitions, sqlQuery)

  if (hasDraftEntity && sqlQuery.SELECT.where && sqlQuery.SELECT.where.length) {
    let cqnDraft = SELECT.from({
      ref: [...sqlQuery.SELECT.from.ref],
      as: sqlQuery.SELECT.from.as
    })

    cqnDraft.SELECT.columns = sqlQuery.SELECT.columns
    _modifyCQN(cqnDraft, sqlQuery.SELECT.where, req)
    cqnDraft = getEnrichedCQN(cqnDraft, sqlQuery.SELECT, [])
    return cds.tx(req).run(cqnDraft)
  }

  return cds.tx(req).run(sqlQuery)
}

module.exports = cds.service.impl(function readOverDraft(srv) {
  srv.on('READ', '*', _readOverDraftHandler)
})
