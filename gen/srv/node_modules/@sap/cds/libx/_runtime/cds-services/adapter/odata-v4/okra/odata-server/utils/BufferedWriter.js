'use strict'

const { AsyncResource } = require('async_hooks')
const Transform = require('stream').Transform

/**
 * The BufferedWriter is a transform stream that buffers the incoming data and
 * emits the concatenated result as an event.
 *
 * After finished the stream processing this stream emits
 *
 * @extends Transform
 */
class BufferedWriter extends Transform {
  /**
   * Creates an instance of BufferedWriter.
   */
  constructor () {
    super({
      transform (data, encoding, callback) {
        const existingBufferList = this.getBufferList()
        existingBufferList.push(data)
        callback()
      }
    })

    // REVISIT: AsyncResource.bind()
    // We AsyncResource.bind() here (also for non middleware case!) to ensure subsequent handlers have access to cds.context -> this test would break if not, and there's an async handler before ours in the route: cds/tests/_runtime/odata/__tests__/integration/crud-with-mtx.test.js
    // Yet, if we do so this test breaks because the implementation of srv.on('error') is pretty screwed: cds/tests/runtime/req.test.js
    this.on('finish', AsyncResource.bind(() => {
      /**
       * Result event to emit the result data.
       * @event BufferedWriter#result
       * @type {Buffer}
       */
      this.emit('result', this.createResultBuffer())
    }))

    this._internalBufferList = []
  }

  /**
   * Returns the internal buffer list
   *
   * @returns {Array} The internal buffer list
   */
  getBufferList () {
    return this._internalBufferList
  }

  /**
   * Creates a single buffer from the internal buffer list.
   *
   * @returns {Buffer} The concatenated internal buffer
   */
  createResultBuffer () {
    return Buffer.concat(this.getBufferList())
  }
}

module.exports = BufferedWriter
