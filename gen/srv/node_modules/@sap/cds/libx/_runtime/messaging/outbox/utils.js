const cds = require('../../cds')
const waitingTime = require('../common-utils/waitingTime')
const OutboxRunner = require('./OutboxRunner')
const { isStandardError } = require('../../common/error/standardError')
const LOG = cds.log('persistent-outbox')
const util = require('util')
const _safeJSONParse = string => {
  try {
    return string && JSON.parse(string)
  } catch (_e) {
    // Don't throw
  }
}
const outboxRunner = new OutboxRunner()
const cdsUser = 'cds.internal.user'
const messageProcessorRegistered = Symbol('message processor registered')

const _get100NanosecondTimestampISOString = () => {
  const [now, nanoseconds] = [new Date(), process.hrtime()[1]]
  return now.toISOString().replace('Z', `${nanoseconds}`.padStart(9, '0').substring(3, 7) + 'Z')
}

const _getMessagesEntity = () => {
  const messagesDbName = 'cds.outbox.Messages'
  const messagesEntity = cds.model.definitions[messagesDbName]
  if (!messagesEntity)
    throw new Error(`The entity '${messagesDbName}' is missing but needed for the persistent outbox.`)
  return messagesEntity
}

// REVISIT: Is this always a reliable way to identify the provider tenant?
//          Are there scenarios where the credentials have a different format?
const _isProviderTenant = tenant =>
  cds.requires.auth && cds.requires.auth.credentials && cds.requires.auth.credentials.identityzoneid === tenant

const hasPersistentOutbox = (srv, tenant) => {
  if (!cds.requires.outbox || cds.requires.outbox.kind !== 'persistent-outbox') return false
  if (srv.options && srv.options.outbox && srv.options.outbox.kind && srv.options.outbox.kind !== 'persistent-outbox')
    return false
  if ((cds.mtx || cds.requires.multitenancy) && tenant && _isProviderTenant(tenant)) return false // no persistence for provider account
  return true
}

const isUnrecoverable = (service, error) => {
  let unrecoverable = service.isUnrecoverableError && service.isUnrecoverableError(error)
  if (unrecoverable === undefined) unrecoverable = error.unrecoverable
  return unrecoverable || isStandardError(error)
}

const processDefault = async (messages, { toBeDeleted, toBeUpdated, options, service }) => {
  /** throws if an emit failed due to a programming error
   * returns false if an emit failed due to temporary issues **/
  const run = async ({ ID, process }) => {
    try {
      await process()
      toBeDeleted.push(ID)
    } catch (e) {
      if (isStandardError(e)) {
        LOG.error(`${service.name}: Programming error detected:`, e)
        toBeDeleted.push(ID)
        throw new Error(`${service.name}: Programming error detected.`)
      }
      if (e.unrecoverable) {
        LOG.error(`${service.name}: Unrecoverable error:`, e)
        if (options.maxAttempts) {
          const _msg = { ID, attempts: options.maxAttempts }
          if (options.storeLastError !== false) _msg.lastError = e
          toBeUpdated.push(_msg)
        } else toBeDeleted.push(ID)
      } else {
        LOG.error(`${service.name}: Emit failed:`, e)
        const _msg = { ID }
        if (options.storeLastError !== false) _msg.lastError = e
        toBeUpdated.push(_msg)
        return false
      }
    }
  }
  if (options.parallel) {
    const first = messages.next()?.value // First try to see if message can be emitted
    if (first && (await run(first)) === false) return // No need to process the rest if the emit failed
    const res = await Promise.allSettled([...messages].map(run))
    const errors = res.filter(r => r.status === 'rejected').map(r => r.reason)
    if (errors.length) {
      throw new Error(`${service.name}: Programming errors detected.`)
    }
  } else {
    for (const msg of messages) {
      if ((await run(msg)) === false) break
    }
  }
}

// Note: This function can also run for each tenant on startup
const processMessages = async (service, tenant, _opts = {}) => {
  const opts = Object.assign({ attempt: 0 }, _opts)
  const name = service.name
  const messagesEntity = _getMessagesEntity()

  outboxRunner.run({ name, tenant }, () => {
    let letAppCrash = false
    const config = tenant ? { tenant, user: new cds.User.Privileged() } : { user: new cds.User.Privileged() }
    const spawn = cds.spawn(async () => {
      let messages
      try {
        const messagesQuery = SELECT.from(messagesEntity)
          .where({ target: name })
          .orderBy('timestamp')
          .limit(opts.chunkSize)
          .forUpdate()
        if (opts.maxAttempts) messagesQuery.where({ attempts: { '<': opts.maxAttempts } })
        messages = await messagesQuery
      } catch (e) {
        // could potentially be a timeout
        const _waitingTime = waitingTime(opts.attempt)
        LOG.error(`${name}: Message retrieval failed`, e, `Retrying in ${Math.round(_waitingTime / 1000)} s`)
        outboxRunner.schedule(
          {
            name,
            tenant,
            waitingTime: _waitingTime
          },
          () => processMessages(service, tenant, { ...opts, attempt: opts.attempt + 1 })
        )
        return
      }
      let currMaxAttempts = 0
      const messagesGen = function* () {
        for (const _message of messages) {
          const msg = _safeJSONParse(_message.msg)
          const userId = msg[cdsUser]
          delete msg[cdsUser]
          currMaxAttempts = Math.max(_message.attempts || 0, currMaxAttempts)
          const user = new cds.User.Privileged(userId)
          if (!msg) continue
          const res = {
            process: () =>
              Promise.resolve().then(async () => {
                if (userId) cds.context = { user }
                try {
                  return service._emitImmediate && (await service._emitImmediate(msg))
                } catch (e) {
                  if (isUnrecoverable(service, e)) e.unrecoverable = true
                  throw e
                }
              }),
            ID: _message.ID,
            msg,
            user,
            opts
          }
          yield res
        }
      }

      const process = service.outbox?.process || this.process || processDefault
      const toBeDeleted = []
      const toBeUpdated = []
      try {
        await process(messagesGen(), {
          toBeDeleted,
          toBeUpdated,
          service,
          emit: service._emitImmediate.bind(service),
          options: opts
        })
      } catch (e) {
        if (opts.crashOnError !== false) letAppCrash = true
      }

      const queries = []
      const _waitingTime = waitingTime(currMaxAttempts)
      if (toBeDeleted.length) queries.push(DELETE.from(messagesEntity).where('ID in', toBeDeleted))
      if (toBeUpdated.length) {
        for (const toBeUpdatedMsg of toBeUpdated) {
          if (toBeDeleted.includes(toBeUpdatedMsg.ID)) continue
          const data = {
            attempts: { '+=': 1 }
          }
          Object.assign(data, toBeUpdatedMsg)
          if (data.lastError && typeof data.lastError !== 'string') data.lastError = util.inspect(data.lastError)
          queries.push(UPDATE(messagesEntity).where({ ID: toBeUpdatedMsg.ID }).set(data))
        }
      }

      await Promise.all(queries)

      if (letAppCrash) return

      if (toBeUpdated.length) {
        LOG.error(`${name}: Some messages could not be emitted, retrying in ${Math.round(_waitingTime / 1000)} s`)
        return outboxRunner.schedule(
          {
            name,
            tenant,
            waitingTime: _waitingTime
          },
          () => processMessages(service, tenant, opts)
        )
      }
      outboxRunner.success({ name, tenant })
      if (toBeDeleted.length === opts.chunkSize) {
        processMessages(service, tenant, opts) // We only processed max. opts.chunkSize, so there might be more
      } else {
        LOG._trace && LOG.trace(`${name}: All messages processed`)
      }
    }, config)
    spawn.on('done', () => {
      if (letAppCrash) cds.exit(1)
      outboxRunner.end({ name, tenant }, () => processMessages(service, tenant, opts))
    })
  })
}

const registerMessageProcessor = (name, context) => {
  const registry = context[messageProcessorRegistered] || (context[messageProcessorRegistered] = new Set())
  if (!registry.has(name)) {
    registry.add(name)
    return true
  }
  return false
}

const _createMessage = (name, msg, context) => {
  const _msg = { ...msg, [cdsUser]: context.user.id }
  const outboxMsg = {
    ID: cds.utils.uuid(),
    target: name,
    timestamp: _get100NanosecondTimestampISOString(), // needs to be different for each emit
    msg: JSON.stringify(_msg)
  }
  return outboxMsg
}

const writeInOutbox = async (name, msg, context) => {
  const outboxMsg = _createMessage(name, msg, context)
  const messagesEntity = _getMessagesEntity()
  return cds.tx(context).run(INSERT.into(messagesEntity).entries(outboxMsg))
}

module.exports = { processMessages, registerMessageProcessor, writeInOutbox, hasPersistentOutbox, isUnrecoverable }
