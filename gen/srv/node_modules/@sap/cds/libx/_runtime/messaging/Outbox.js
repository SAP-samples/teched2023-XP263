const cds = require('../cds')

const {
  processMessages,
  registerMessageProcessor,
  writeInOutbox,
  hasPersistentOutbox,
  isUnrecoverable
} = require('./outbox/utils')

class OutboxService extends cds.Service {
  // eslint-disable-next-line require-await
  async init() {
    // REVISIT: add 'outbox' to list of module names?
    const LOG = cds.log(this.name)

    // REVISIT: Also allow to overwrite this.send
    this._emitImmediate = this.emit
    this.emit = async function (...args) {
      const msg = typeof args[0] === 'object' ? args[0] : { event: args[0], data: args[1], headers: args[2] }
      const context = this.context || cds.context
      if (this.options.outbox && context) {
        const outboxOpts = Object.assign(
          {},
          (typeof cds.requires.outbox === 'object' && cds.requires.outbox) || {},
          (this.options && typeof this.options.outbox === 'object' && this.options.outbox) || {}
        )
        if (hasPersistentOutbox(this, context.tenant)) {
          // returns true if not yet registered
          if (registerMessageProcessor(this.name, context)) {
            context.on('succeeded', () => processMessages(this, context.tenant, outboxOpts))
          }
          await writeInOutbox(this.name, msg, context)
          return
        }
        // Revisit: Also allow maxAttempts?
        context.on('succeeded', async () => {
          try {
            await this._emitImmediate(msg)
          } catch (e) {
            LOG.error('Emit failed', { event: msg.event, cause: e })
            // opts.crashOnError is not official!!!
            if (isUnrecoverable(this, e) && outboxOpts.crashOnError !== false) cds.exit(1)
          }
        })
        return
      }
      return this._emitImmediate(msg)
    }
  }
}

module.exports = OutboxService
