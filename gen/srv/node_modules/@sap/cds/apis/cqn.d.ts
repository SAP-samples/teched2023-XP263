import { entity } from "./csn"

export type Query = SELECT | INSERT | UPDATE | DELETE | CREATE | DROP | UPSERT
export type ParsedExpr = expr & { _:string }

export type SELECT = {SELECT:{
	distinct?: true
	one? : boolean
	from : source
	mixin?: {[key:string]: expr}
	columns? : column_expr[]
	excluding? : string[]
	where? : predicate
	having? : predicate
	groupBy? : expr[]
	orderBy? : ordering_term[]
	limit?: { rows:val, offset:val }
	forUpdate?: { wait: number }
	forShareLock?: { wait: number }
	search?: _xpr
	count?: boolean
}}

export type INSERT = {INSERT:{
	into : name | ref
	entries : any[]
	columns : string[]
	values : any[]
	rows : any[]
	as : SELECT
}}

export type UPSERT = {UPSERT:{
	into : name | ref
	entries : any[]
	columns : string[]
	values : any[]
	rows : any[]
}}

export type UPDATE = {UPDATE:{
	entity : name
	data : { [key:string] : expr }
	where? : predicate
}}

export type DELETE = {DELETE:{
	from : name
	where? : predicate
}}

export type CREATE = {CREATE:{
	entity : entity | name
	as: SELECT
}}

export type DROP = {DROP:{
	entity : name
	table: ref
	view: ref
}}

type name = string
type source = ( ref | SELECT ) & { as?: name, join?:name, on?:xpr }
export type column_expr = expr & { as?: name, cast?:any, expand?: column_expr[], inline?: column_expr[] }
export type predicate = _xpr
type ordering_term = expr & { sort?: "asc"|"desc", nulls?: "first"|"last" }

export type expr = ref | val | xpr | function_call | SELECT
type ref = {ref:( name & { id?:string, where?:expr, args?:expr[] } )[]}
type val = {val:any}
type xpr = {xpr:_xpr}
type _xpr = ( expr | operator ) []
type operator = string
type function_call = {func: string, args: {[key: string]: unknown}[]}

export type enum_literal = {"#": string}
export type expr_literal = {"=": string}
