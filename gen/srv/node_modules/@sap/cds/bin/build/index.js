const path = require('path')
const fs = require('fs')
const BuildTaskEngine = require('./buildTaskEngine')
const BuildTaskFactory = require('./buildTaskFactory')
const BuildTaskHandler = require('./buildTaskHandler')
const { LOG_MODULE_NAMES } = require('./constants')
const { BuildError } = require('./util')

module.exports = Object.assign(build,
    { build, BuildTaskFactory, BuildTaskEngine, BuildTaskHandler, BuildError }
)

/**
 * New modular build.
 *
 * @param {object} options - command options as defined by build command.
 */
async function build(options = {}) {
    const projectPath = path.resolve(options.project || '.')
    if (!fs.lstatSync(projectPath).isDirectory()) {
        return Promise.reject(`Project [${projectPath}] does not exist`)
    }

    const cds = require('./cds')
    const cdsEnv = cds.env, cdsRoot = cds.root
    if (projectPath !== process.cwd()) {
        const env = cds.env.for('cds', projectPath);
        cds.env = env // REVISIT: not good / fragile
        cds.root = projectPath // REVISIT: not good / fragile
    }
    const logger = options.logger || cds.log(LOG_MODULE_NAMES)
    const buildOptions = _mergeCliOptions({ root: cds.root }, options)
    const buildTaskFactory = new BuildTaskFactory(logger)
    const buildTaskEngine = new BuildTaskEngine(logger)
    let buildResult

    try {
        const tasks = await buildTaskFactory.getTasks(buildOptions)
        buildResult = await buildTaskEngine.processTasks(tasks, buildOptions)
    } catch (e) {
        // cds CLI layer logs if invoked from CLI
        if (!buildOptions.cli) {
            buildTaskEngine._logMessages(buildOptions, [e])
        }
        throw e
    } finally {
        cds.root = cdsRoot
        cds.env = cdsEnv
    }
    return buildResult
}

function _mergeCliOptions(buildOptions, options) {
    buildOptions["log-level"] = options["log-level"]
    buildOptions.cli = options.cli
    buildOptions.cmdOptions = options
    return buildOptions
}
