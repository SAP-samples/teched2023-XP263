const path = require('path')
const fs = require('fs')
const cds = require('../../cds')

const BuildTaskHandlerInternal = require('../buildTaskHandlerInternal')
const { FOLDER_GEN, EXTENSION_POINT_VALIDATION } = require('../../constants')
const ResourcesTarBuilder = require('../mtx/resourcesTarBuilder')
const { BuildError, BuildMessage } = require('../../util')

class MtxExtensionModuleBuilder extends BuildTaskHandlerInternal {
    init() {
        super.init()
        if (this.buildOptions.root === this.buildOptions.target) {
            this.task.dest = path.join(this.task.dest, FOLDER_GEN)
        }
    }

    async build() {
        const { src, dest } = this.task
        const destExt = path.join(dest, 'ext')
        // check existence of appPackage folder only
        // REVISIT: cds.resolve will fail as no index.csn file exists in this folder for the extension migration use case
        // a compilation error is thrown anyhow if any base model refs cannot be resolved
        const appPackageFolder = this._getAppPackageFolder()
        if (!fs.existsSync(path.join(src, appPackageFolder))) {
            throw new BuildError(`The SaaS application base model '${appPackageFolder}' is missing. Have you run the 'cds pull' command?`)
        }

        // full compile of the extension using base model - ensuring consistency
        const model = await this.model()

        if (model) {
            // extension CSN using parsed format
            const options = { ...this.options(), flavor: 'parsed' }
            const extModel = await cds.load(this._resolveExtensionFiles(model), options)
            if (extModel.requires) {
                extModel.requires.length = 0
            }

            if (!this.hasBuildOption(EXTENSION_POINT_VALIDATION, false)) {
                this._lintExtModel(extModel, model) // throws error in case of linting errors
            }

            await this.compileToJson(extModel, path.join(destExt, 'extension.csn'))

            await this.collectLanguageBundles(extModel, path.join(destExt, 'i18n'))

            const files = Object.keys(await cds.deploy.resources(model))
            if (files.length > 0) {
                const dataDest = path.join(destExt, 'data')
                await Promise.all(
                    files
                        .filter(file => /\.csv$/.test(file))
                        .map(csv => {
                            return this.copy(csv).to(path.join(dataDest, path.basename(csv)))
                        })
                )
            }
        }

        const packageJson = path.join(src, 'package.json')
        if (!fs.existsSync(packageJson)) {
            throw new BuildError(`package.json file not found in ${src}`)
        }
        await this.copy(packageJson).to(path.join(destExt, 'package.json'))

        // copy handlers
        const folders = [path.join(src, cds.env.folders.srv, 'handlers')]
        await this.copyNativeContent(src, destExt, res => {
            if (fs.statSync(res).isDirectory()) {
                return folders.some(folder => folder.startsWith(res))
            }
            if (folders.includes(path.dirname(res)) && /\.js$/.test(res)) {
                return true
            }
        })

        // add all resources contained in 'gen/ext' folder
        await new ResourcesTarBuilder(this).writeTarFile(path.join(this.task.dest, 'extension.tgz'), destExt)
    }

    _resolveExtensionFiles(model) {
        const node_modules = path.join(this.task.src, 'node_modules')
        const paths = model['$sources'].reduce((acc, file) => {
            if (file.startsWith(this.task.src) && !file.startsWith(node_modules)) {
                acc.push(file)
            }
            return acc
        }, [])

        return paths
    }

    _lintExtModel(extModel, model) {
        const linter = this._linter()
        if (!linter) {
            return
        }
        const env = cds.env.for('cds', path.join(this.task.src, this._getAppPackageFolder()))
        this.logger._debug && this.logger.debug(`Saas extension point restrictions:\n${env.requires?.['cds.xt.ExtensibilityService']}`)

        const messages = linter.lint(extModel, model, env)
        if (messages.length) {
            // REVISIT: lint messages can be passed as is with cds-mtxs version >= 1.7
            throw new BuildError('SaaS extension point restrictions violated. Check the concrete restrictions defined by the SaaS app provider.',
                messages.map(f => new BuildMessage(f.message, f.severity, f.location || f.element?.$location)))
        }
    }

    _linter() {
        let linter
        try {
            // Make sure cds-mtxs APIs are loaded
            linter = require('@sap/cds-mtxs').xt?.linter // eslint-disable-line cds/no-missing-dependencies
            if (!linter) {
                this.pushMessage('MTXS linter cannot be loaded. Update of @sap/cds-dk and @sap/cds-mtxs modules required? Skipping extension model lint step.')
                return null // too old mtxs
            }
        } catch (e) {
            if (e.code !== 'MODULE_NOT_FOUND') throw e
            this.pushMessage('MTXS linter cannot be loaded, @sap/cds-mtxs not installed. Skipping extension model lint step.')
        }
        return linter
    }

    _getAppPackageFolder() {
        return path.join('node_modules', cds.env.extends || '_base');
    }
}

module.exports = MtxExtensionModuleBuilder
