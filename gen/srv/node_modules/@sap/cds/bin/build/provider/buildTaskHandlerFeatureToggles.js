const fs = require('fs')
const path = require('path')
const cds = require('../cds')
const { DEFAULT_CSN_FILE_NAME } = require('../constants')
const BuildTaskHandlerInternal = require('./buildTaskHandlerInternal')

class FeatureToggleBuilder extends BuildTaskHandlerInternal {
    init() {
        this._result = {
            dest: this.task.dest,
            csn: {},
            edmx: new Map(),
            languages: new Set(),
            services: new Set(),
            languageBundles: {}
        }
    }

    get ftsName() {
        return path.dirname(cds.env.features.folders || 'fts/*')
    }

    async compileAll(csn, destBase, destFts) {
        const sources = await this._resolveSourcePaths(csn)
        const dictionary = { base: null, features: null }

        if (sources.features) {
            // create base model as the given CSN is containing all features
            dictionary.base = await cds.load(sources.base, this.options())
        } else {
            // CSN already represents the base model as no features exist
            dictionary.base = csn
        }
        // preserve @location as @source properties
        const csnStr = await this.compileToJson(dictionary.base, path.join(destBase, DEFAULT_CSN_FILE_NAME))
        const csnModel = JSON.parse(csnStr)
        csnModel.meta = csn.meta
        this._result.csn = csnModel

        if (sources.features) {
            dictionary.features = await this._compileFeatures(sources.features, destBase, destFts)
        }
        return { dictionary, sources }
    }

    async collectAllLanguageBundles(dictionary, paths, destBase, destFts) {
        const i18nFolder = cds.env.i18n.folders?.[0] || 'i18n'
        // create language bundle for base model
        const i18n = await this.collectLanguageBundles(dictionary.base, path.join(destBase, i18nFolder))
        if (i18n) {
            this._result.languageBundles = i18n.bundles
        }

        if (dictionary.features) {
            // create language bundles for all features
            for (const ftName in dictionary.features) {
                // attach the sources information for i18n location reference
                dictionary.features[ftName]['$sources'] = paths.features[ftName]
                await this.collectLanguageBundles(dictionary.features[ftName], path.join(destFts, this.ftsName, ftName, i18nFolder))
            }
        }
    }

    async _resolveSourcePaths(csn) {
        const regex = new RegExp(path.resolve(this.buildOptions.root, this.ftsName).replace(/\\/g, '\\\\') + '[/|\\\\](?<ftName>[^/|\\\\]*)')
        let paths = { base: [] }

        // add ROOT source file paths for the base model
        paths.base = this._resolveModel().reduce((acc, file) => {
            const match = file.match(regex)
            if (!match) {
                acc.push(file)
            }
            return acc
        }, [])

        // keep existing behavior and return paths returned by cds.resolve if features are not supported by this project
        if (!fs.existsSync(path.join(this.buildOptions.root, this.ftsName))) {
            return paths
        }

        // add source file paths for the features
        paths.features = csn['$sources'].reduce((acc, file) => {
            const match = file.match(regex)
            if (match) {
                const { ftName } = match.groups
                //feature
                if (!acc[ftName]) {
                    acc[ftName] = []
                }
                acc[ftName].push(file)
            }
            return acc
        }, {})

        return paths
    }

    async _compileFeatures(ftsPaths, destBase, destFts) {
        if (!ftsPaths) {
            return
        }
        const features = {}
        const options = { ...this.options(), flavor: 'parsed' }

        // create feature models
        for (const ftName in ftsPaths) {
            const ftCsn = await cds.load(ftsPaths[ftName], options)
            const ftPath = path.join(destFts, this.ftsName, ftName)

            // replace require paths by base model path to ensure precedence of feature annotations
            // see https://pages.github.tools.sap/cap/docs/cds/compiler-messages#anno-duplicate-unrelated-layer
            ftCsn.requires = [path.join(path.relative(ftPath, destBase), DEFAULT_CSN_FILE_NAME).replace(/\\/g, '/')]

            await this.compileToJson(ftCsn, path.join(ftPath, DEFAULT_CSN_FILE_NAME))
            await this._validateFeature(ftPath)
            features[ftName] = ftCsn
        }
        return features
    }

    async _validateFeature(ftPath) {
        // features must not have other than base model dependencies, cross feature dependencies are not supported
        // do not pass options.messages in order to avoid duplicate compiler messages
        return cds.load([ftPath])
        // version 2.13.9 of compileSources does not read the requires definition of parsed CSNs
        // require('@sap/cds-compiler').compileSources({ '../..csn.json': baseCsn, 'feature.csn': ftCsn }, this.options())
    }
}

module.exports = FeatureToggleBuilder