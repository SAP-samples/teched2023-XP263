const fs = require('fs')
const path = require('path')
const cds = require('../../cds')
const BuildTaskHandlerEdmx = require('../buildTaskHandlerEdmx')
const { BuildError } = require('../../util')
const { BUILD_OPTION_OUTPUT_MODE, OUTPUT_MODE_RESULT_ONLY, ODATA_VERSION_V2, FOLDER_GEN, BUILD_NODEJS_EDMX_GENERATION, EDMX_GENERATION,
    SKIP_PACKAGE_JSON_GENERATION, CONTENT_EDMX, CONTENT_PACKAGE_JSON, CONTENT_PACKAGELOCK_JSON, CONTENT_NPMRC, CONTENT_CDSRC_JSON,
    CONTENT_ENV, CONTENT_DEFAULT_ENV_JSON } = require('../../constants')
const { WARNING } = BuildTaskHandlerEdmx

class NodejsModuleBuilder extends BuildTaskHandlerEdmx {
    init() {
        super.init()
        // set unified option values in order to ease access later on
        // default value true
        this.task.options[CONTENT_PACKAGE_JSON] = !this.hasBuildOption(CONTENT_PACKAGE_JSON, false) && !this.hasBuildOption(SKIP_PACKAGE_JSON_GENERATION, true) ? true : false
        this.task.options[CONTENT_PACKAGELOCK_JSON] = !this.hasBuildOption(CONTENT_PACKAGELOCK_JSON, false) ? true : false
        this.task.options[CONTENT_NPMRC] = !this.hasBuildOption(CONTENT_NPMRC, false) ? true : false
        this.task.options[CONTENT_CDSRC_JSON] = !this.hasBuildOption(CONTENT_CDSRC_JSON, false) ? true : false

        // default value false
        this.task.options[CONTENT_EDMX] = this.hasBuildOption(CONTENT_EDMX, true) || this.hasCdsEnvOption(BUILD_NODEJS_EDMX_GENERATION, true) || this.hasBuildOption(EDMX_GENERATION, true) ? true : false
        this.task.options[CONTENT_ENV] = this.hasBuildOption(CONTENT_ENV, true) ? true : false
        this.task.options[CONTENT_DEFAULT_ENV_JSON] = this.hasBuildOption(CONTENT_DEFAULT_ENV_JSON, true) ? true : false

        if (this.task.options.compileDest) {
            throw new BuildError("Option not supported - compileDest")
        }
        // fallback if src has been defined as '.'
        this.destSrv = this.isStagingBuild() ? path.resolve(this.task.dest, cds.env.folders.srv) : path.join(this.task.dest, FOLDER_GEN)
    }

    options() {
        const options = super.options()
        if (cds.env.requires.extensibility || cds.env.requires.toggles) {
            options.flavor = 'xtended'
        }
        return options
    }

    async build() {
        const destSrv = this.isStagingBuild() ? this.destSrv : path.resolve(this.destSrv, cds.env.folders.srv)
        const destRoot = this.isStagingBuild() ? this.task.dest : this.destSrv

        if (cds.env.odata?.version === ODATA_VERSION_V2) {
            // log warning as nodejs is only supporting odata version V4
            this.pushMessage("OData v2 is not supported by node runtime. Make sure to define OData v2 in cds configuration.", WARNING)
        }
        // by default model contains all features
        const model = await this.model()
        if (!model) {
            return this._result
        }

        const { dictionary, sources } = await this.compileAll(model, destSrv, destRoot)

        // collect and write language bundles into single i18n.json file
        await this.collectAllLanguageBundles(dictionary, sources, destSrv, destRoot)

        if (this.hasBuildOption(CONTENT_EDMX, true)) {
            const m = await cds.load(sources.base, super.options()) // REVISIT: Quick hack to get inferred model as expected by cds.compile.to.edmx()
            await this.compileToEdmx(m, this.destSrv)
        }

        if (this.isStagingBuild() && !this.hasBuildOption(BUILD_OPTION_OUTPUT_MODE, OUTPUT_MODE_RESULT_ONLY)) {
            const srcSrv = this.task.src === this.buildOptions.root ? path.resolve(this.task.src, cds.env.folders.srv) : this.task.src
            await this._copyNativeContent(this.buildOptions.root, srcSrv, destRoot, destSrv)
            await this._fixCapireSamplesDeps(destRoot)
        }
        return this._result
    }

    // REVISIT: fix for capire samples - needs to be reworked
    // Instead of adding relative paths we may better delete the entire entry as relative paths
    // cannot be resolved in cloud deployments anyway.
    // Support for HANA native artifacts defined in sub-modules required
    async _fixCapireSamplesDeps(dest) {
        const packageJson = path.join(dest, 'package.json')
        try {
            const content = require(packageJson)
            const { dependencies } = content
            let changed
            for (let dependency in dependencies) {
                if (dependency.startsWith('@capire/')) {
                    dependencies[dependency] = path.relative(dest, path.dirname(require.resolve(dependency + '/package.json')))
                    changed = true
                }
            }
            if (changed) {
                return this.write(JSON.stringify(content, null, '  ')).to(packageJson)
            }
        } catch (e) {/*ignore*/ }
    }

    async clean() {
        // staging build content is deleted by BuildTaskEngine
        if (this.buildOptions.target === this.buildOptions.root) {
            // delete the entire 'task.dest' folder otherwise, for details see #constructor
            // - the value of the folder 'src' has been appended to the origin 'task.dest' dir
            this.logger._debug && this.logger.debug(`Deleting build target folder ${this.destSrv}`)
            await fs.promises.rm(this.isStagingBuild() ? this.task.dest : this.destSrv, { force: true, recursive: true })
        }
    }

    async _copyNativeContent(srcRoot, srcSrv, destRoot, destSrv) {
        // project/srv/** -> 'gen/srv/srv/**'
        const filesFilter = await this._copySrvContent(srcSrv, destRoot, destSrv)

        // project/* -> 'gen/srv/*'
        await this.copyProjectRootContent(srcRoot, destRoot, (entry) => !filesFilter.includes(path.basename(entry)))
    }

    /**
     * Copy files for nodejs staging builds from the given <em>src</em>' folder (e.g. 'project/srv') to either <em>destRoot</em> (e.g. 'project/gen/srv')
     * or <em>destSrv</em> (e.g. 'project/gen/srv/srv') folders according to the file semantics.
     * Files with project semantics like 'package.json' or '.npmrc' file are copied to <em>destRoot</em> while others like '.js' service handlers
     * are copied to <em>destSrv</em>.
     * @param {*} src
     * @param {*} destRoot - folder name representing the app root folder (e.g. gen/srv)
     * @param {*} destSrv - folder name representing the app sub-folder (e.g. gen/srv/srv)
     * @returns the list of files that have been copied
     */
    async _copySrvContent(src, destRoot, destSrv) {
        const srvRootBlockList = RegExp('package\\.json$|package-lock\\.json$|\\.npmrc$|\\.cdsrc\\.json$')
        const srvBlockList = RegExp('\\.cds$|csn\\.json$|\\.csn$|manifest\\.y.?ml$|\\.env($|\\..*$)|default-env\\.json$')
        const srvRootFileNames = []

        // 1. copy all files to 'destSrv' except those contained in the blocklist (including node_modules)
        // project/srv -> 'gen/srv/srv'
        await super.copyNativeContent(src, destSrv, (entry) => {
            if (fs.statSync(entry).isDirectory()) {
                // TODO shall not copy language bundles - return !/(\/|\\)(node_modules|_i18n)(\/|\\)?$/.test(entry)
                return !/(\/|\\)node_modules(\/|\\)?$/.test(entry)
            }
            // make sure the file exists on srv root level - see https://github.tools.sap/cap/issues/issues/12077
            if (srvRootBlockList.test(entry) && path.dirname(entry) === src) {
                srvRootFileNames.push(path.basename(entry))
                return false
            }
            return !srvBlockList.test(entry)
        })

        // 2. copy dedicated files like package.json, .npmrc to 'destRoot'
        // project/srv -> 'gen/srv'
        let srvAllowList = "package\\.json$" // always copy package.json, modify only if CONTENT_PACKAGE_JSON is true
        srvAllowList += this.hasBuildOption(CONTENT_PACKAGELOCK_JSON, true) ? "|package-lock\\.json$" : ""
        srvAllowList += this.hasBuildOption(CONTENT_NPMRC, true) ? "|\\.npmrc$" : ""
        srvAllowList += this.hasBuildOption(CONTENT_CDSRC_JSON, true) ? "|\\.cdsrc\\.json$" : ""
        srvAllowList += this.hasBuildOption(CONTENT_ENV, true) ? "|\\.env($|\\..*$)" : ""
        srvAllowList += this.hasBuildOption(CONTENT_DEFAULT_ENV_JSON, true) ? "|default-env\\.json$" : ""
        srvAllowList = new RegExp(srvAllowList)
        await Promise.all(srvRootFileNames.map(fileName => {
            if (srvAllowList.test(fileName)) {
                return this.copy(path.join(src, fileName)).to(path.join(destRoot, fileName))
            }
        }))

        return srvRootFileNames
    }

    /**
     * Copy dedicated files (files with project semantics like package.json, .npmrc, .cdsrc, etc.)
     * from the given <em>src</em> folder (e.g. 'project') into the given <em>dest</em> folder (e.g. 'project/gen/srv')
     * @param {*} src
     * @param {*} dest
     * @param {*} filter - copy file if filter function returns true
     */
    async copyProjectRootContent(src, dest, filter) {
        let { folders = ['i18n'] } = cds.env.i18n
        folders.push('handlers')
        folders = folders.map(folder => path.join(src, folder))
        let srvAllowList = "package\\.json$" // always copy package.json, modify only if CONTENT_PACKAGE_JSON is true
        srvAllowList += this.hasBuildOption(CONTENT_PACKAGELOCK_JSON, true) ? "|package-lock\\.json$" : ""
        srvAllowList += this.hasBuildOption(CONTENT_NPMRC, true) ? "|\\.npmrc$" : ""
        srvAllowList += this.hasBuildOption(CONTENT_CDSRC_JSON, true) ? "|\\.cdsrc\\.json$" : ""
        srvAllowList += this.hasBuildOption(CONTENT_ENV, true) ? "|\\.env($|\\..*$)" : ""
        srvAllowList += this.hasBuildOption(CONTENT_DEFAULT_ENV_JSON, true) ? "|default-env\\.json$" : ""
        srvAllowList = new RegExp(srvAllowList)

        await super.copyNativeContent(src, dest, (entry) => {
            if (fs.statSync(entry).isDirectory()) {
                return folders.some(folder => entry.startsWith(folder))
            }
            if (/\.js$|\.properties$/.test(entry)) {
                return true
            }
            return srvAllowList.test(entry) && (!filter || filter.call(this, entry))
        })
    }
}

module.exports = NodejsModuleBuilder
