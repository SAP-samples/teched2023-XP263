const path = require('path')
const cds = require('../../cds')
const fs = require('fs')
const { FOLDER_GEN, DEFAULT_CSN_FILE_NAME } = require('../../constants')
const NodeCfModuleBuilder = require('../nodejs')
const ResourcesTarProvider = require('../mtx/resourcesTarBuilder')
const { INFO, ERROR } = NodeCfModuleBuilder
const { relativePaths, BuildError, resolveRequiredSapModels } = require('../../util')

const DEFAULT_MAIN_FOLDER = "_main"

class MtxSidecarModuleBuilder extends NodeCfModuleBuilder {
    get priority() {
        // should be scheduled after 'hana' build tasks are finished
        return NodeCfModuleBuilder.PRIORITY_MIN_VALUE
    }
    init() {
        super.init()
        if (this.buildOptions.root === this.buildOptions.target) {
            this.task.dest = path.join(this.task.dest, FOLDER_GEN)
        }
    }

    /**
     * Builds the mtx sidecar app consisting of:
     * - nodejs app model defined by the required sidecar services
     * - main app model defined by the build task's model options including feature models and resources TAR
     *
     * build.target=".": 'dest' -> 'model-provider/gen'
     * build.target="gen": 'dest' -> 'gen/model-provider'
     */
    async build() {
        // nodejs app parts have to be built using sidecar env
        const sidecarEnv = cds.env.for("cds", this.task.src)
        // build main application
        await this._buildMainApp(sidecarEnv)
        // build node application
        await this._buildNodeApp(sidecarEnv)
    }

    /**
     * Builds the mtx sidecar nodejs app parts.
     * @param {object} sidecarEnv cds env based on the sidecar dir
     */
    async _buildNodeApp(sidecarEnv) {
        const destSidecar = this.task.dest
        const destSidecarSrc = path.join(destSidecar, cds.env.folders.srv)
        const i18nFolder = cds.env.i18n.folders?.[0] || 'i18n'
        const model = this._compileSidecarSync(sidecarEnv)
        await this.compileToJson(model, path.join(destSidecarSrc, DEFAULT_CSN_FILE_NAME))

        await this.collectLanguageBundles(model, path.join(destSidecarSrc, i18nFolder))
        await this.copyProjectRootContent(this.task.src, destSidecar)
    }

    /**
     * Builds the main app parts containing base model CSN with feature CSNs and resources TAR.
     * @param {object} sidecarEnv cds env based on the sidecar dir
     */
    async _buildMainApp(sidecarEnv) {
        let main = sidecarEnv.requires['cds.xt.ModelProviderService']?.root
        if (!main) {
            throw new BuildError(`Invalid MTX sidecar configuration. Make sure that the profile 'mtx-sidecar' is configured and an up-to-date version of @sap/cds-mtxs is installed.`)
        }
        const profiles = cds.env.profiles || []

        if (!profiles.includes("production") && !profiles.includes("prod")) {
            main = DEFAULT_MAIN_FOLDER
            // root should represent the production use case and not development
            this.pushMessage(`MTX sidecar build results are created in folder '${main}'. Enable 'production' or 'prod' profile if the folder is configured differently.`, INFO)
        }
        const destRoot = this.task.dest
        const destMain = path.join(destRoot, main)
        const destMainSrv = path.join(destMain, cds.env.folders.srv)
        const csn = await this.model()
        if (!csn) {
            return
        }
        const { dictionary, sources } = await this.compileAll(csn, destMainSrv, destMain)
        await this.collectAllLanguageBundles(dictionary, sources, destMainSrv, destMain)

        // create resources TAR
        // resources are determined based on available database build task, SQLite as fallback
        await new ResourcesTarProvider(this).createTar(destMain, csn)

        // copy package.json and .cdsrc.json from project root
        await this._copyMainConfigFiles(cds.root, destMain)
    }

    /**
     * Synchronous compilation using the sidecar context.
     * @param {object} sidecarEnv cds env based on the sidecar dir
     * @returns the compiled mtx sidecar CSN
     */
    _compileSidecarSync(sidecarEnv) {
        const env = cds.env
        try {
            cds.root = this.task.src
            cds.env = sidecarEnv
            const modelPaths = cds.resolve('*', false)
            const modelFilePaths = cds.resolve(modelPaths)

            if (!modelFilePaths || modelFilePaths.length === 0) {
                throw new BuildError("No CDS models found in MTX sidecar. Make sure up-to-date versions of the required npm modules are installed.")
            }
            this._logger._debug && this._logger.debug(`sidecar model: ${relativePaths(this.buildOptions.root, modelFilePaths).join(", ")}`)

            // check whether all models belonging to the @sap namespace can be resolved
            const unresolved = resolveRequiredSapModels(modelPaths)
            if (unresolved.length > 0) {
                // log error, but don't fail
                throw new BuildError(`CDS models [${unresolved.join(', ')}] required by MTX sidecar cannot be resolved. Make sure up-to-date versions of the corresponding npm modules are installed.`, ERROR)
            }

            // synchronous compilation
            return cds.load(modelFilePaths, { sync: true, ...this.options() })
        } finally {
            // restore project scope
            cds.root = this.buildOptions.root
            cds.env = env
        }
    }

    async _copyMainConfigFiles(src, dest) {
        const packageJson = path.join(src, 'package.json')
        const cdsrcJson = path.join(src, '.cdsrc.json')
        const promises = []
        if (fs.existsSync(packageJson)) {
            promises.push(this.copy(packageJson).to(path.join(dest, 'package.json')))
        }
        if (fs.existsSync(cdsrcJson)) {
            promises.push(this.copy(cdsrcJson).to(path.join(dest, '.cdsrc.json')))
        }
        return promises
    }
}
module.exports = MtxSidecarModuleBuilder
