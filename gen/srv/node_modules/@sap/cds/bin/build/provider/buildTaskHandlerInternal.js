const fs = require('fs')
const path = require('path')
const cds = require('../cds')
const BuildTaskHandler = require('../buildTaskHandler')
const { hasOptionValue } = require('../util')
const { FOLDER_GEN, BUILD_OPTION_OUTPUT_MODE, OUTPUT_MODE_RESULT_ONLY } = require('../constants')

class BuildTaskHandlerInternal extends BuildTaskHandler {
    /**
     * Returns the logger that has been passed the build task engine.
     * @returns {object}
     */
    get logger() {
        //injected by framework
        return this._logger;
    }
    /**
     * Returns the build options used for this CDS build execution
     * @returns {object}
     */
    get buildOptions() {
        return this._buildOptions
    }
    /**
     * Custom build handlers are executed before internal handlers in order
     * ensure and content cannot be overwritten by mistake.
     */
    get priority() {
        return BuildTaskHandlerInternal.PRIORITY_MAX_VALUE
    }

    async clean() {
        // the build results have already been deleted by the BuildTaskEngine if the build.target !== '.'
        // make sure that src is not a subfolder of dest
        if (this._buildOptions.root === this._buildOptions.target && this.task.src !== this.task.dest && !this._isSubDirectory(this.task.dest, this.task.src)) {
            await fs.promises.rm(this.task.dest, { force: true, recursive: true })
        }
    }

    /**
     * Used by the framework to initialize the logger implementation.
     * @param {object} logger
     */
    set logger(logger) {
        super.logger = logger;
    }
    /**
     * Sets the build options used for this CDS build execution
     * @param {object} options
     */
    set buildOptions(options) {
        super.buildOptions = options
    }
    /**
     * Maximum allowed priority for internal build tasks.
     */
    static get PRIORITY_MAX_VALUE() {
        return 0;
    }
    /**
     * Minimum allowed priority for custom build tasks.
     */
    static get PRIORITY_MIN_VALUE() {
        return Number.MIN_SAFE_INTEGER;
    }

    /**
     * Called by the framework after {@link #init()}. Handlers may want to perform more elaborate preparation.
     * E.g. caching some pre-calculated data that can be used across multiple build tasks. This kind of data
     * has to be stored in the handler type specific buildOptions section.
     * @returns {Promise<boolean>} A value 'false' indicates that {@link #prepare()} will not be called for other instances
     * of this handler type.
     * True indicates that {@link #prepare()} will be called for other instances of this of this handler type.
     * @deprecated
     */
    async prepare() {
        // cancel subsequent prepare calls for other handlers of the same type by default
        return false
    }

    /**
     * Returns whether cds env has a property with the specified value.
     * If the value is omitted the existence of the given property name is checked.
     * @param {string} qualifiedName
     * @param {any=} value
     */
    hasCdsEnvOption(qualifiedName, value) {
        return hasOptionValue(cds.env.get(qualifiedName), value)
    }

    /**
     * Determines whether the given build option value has been set for this build task.
     * If the value is omitted, the existence of the given property name is checked.
     * @param {string} qualifiedName
     * @param {any=} value
     */
    hasBuildOption(qualifiedName, value) {
        return hasOptionValue(this._getBuildOption(qualifiedName), value)
    }

    /**
     * Returns the value of the given build option defined for this build task.
     * @param {string} qualifiedName
     */
    getBuildOption(qualifiedName) {
        return super._getBuildOption(qualifiedName)
    }

    /**
    * Returns a list of CDS model files defining the transitive closure of the CDS model based on the model options
    * defined for this build task.
    */
    resolveModel() {
        return this._resolveModel()
    }

    /**
     * Returns whether the build results of this build plugin are created inplace
     * or in a separate staging folder which is not part of the build tasks src folder.
     */
    isStagingBuild() {
        return !this.task.src.startsWith(this.task.dest)
    }

    async copyNativeContent(srcDir, destDir, customFilter) {
        const files = BuildTaskHandlerInternal._find(srcDir, (src) => {
            // do not copy files that:
            // - are contained in the 'buildOptions.target' folder
            // - are contained in this modules 'dest' folder
            // - are contained in some generation folder
            // - do NOT fulfill additional specific filter criteria
            return this._commonStagingBuildFilter(src, destDir) && (!customFilter || customFilter.call(this, src))
        })
        return Promise.all(
            files.map((srcFile) => {
                let relFile = path.relative(srcDir, srcFile)
                let destFile = path.join(destDir, relFile)
                return this.copy(srcFile).to(destFile)
            })
        )
    }

    async compileToJson(model, csnFile) {
        // This will als add a @source prop containing the relative path to the origin .cds source file
        // and a parsed _where clause for @restrict.{grant,where} annotations.
        // The @source annotation is required for correct custom handler resolution if no @impl annotation has been defined as
        // custom service handler implementations are relative to the origin .cds source files.
        // For staging builds (task.src !== task.dest) the csn.json file that is served at runtime is copied into a corresponding srv subfolder.
        // As a consequence the src folder name has to be included in the @source file name while for inplace builds (task.src === task.dest) this is not the case.
        // This ensures that the paths are relative to the cwd when executing cds run.
        const jsonOptions = {
            cwd: this.buildOptions.root,
            src: this.task.src === this.task.dest ? this.task.src : this.buildOptions.root
        }
        const csnStr = cds.compile.to.json(model, jsonOptions)
        if (!this.hasBuildOption(BUILD_OPTION_OUTPUT_MODE, OUTPUT_MODE_RESULT_ONLY)) {
            await this.write(csnStr).to(csnFile)
        }
        return csnStr
    }

    /**
     * Collect and write language bundles into a single i18n.json file.
     * @param {Object} model
     * @param {string} bundleDest
     */
    async collectLanguageBundles(model, bundleDest) {
        // collect effective i18n properties...
        let bundles = {}
        const bundleGenerator = cds.localize.bundles4(model)
        if (bundleGenerator && bundleGenerator[Symbol.iterator]) {
            for (let [locale, bundle] of bundleGenerator) {
                // fallback bundle has the name ""
                if (typeof locale === 'string') {
                    bundles[locale] = bundle
                }
            }
        }

        // omit bundles in case the fallback bundle is the only existing entry
        const keys = Object.keys(bundles)
        if (keys.length === 1 && keys[0] === "" && Object.keys(bundles[keys[0]]).length === 0) {
            bundles = {}
        }
        // copied from ../compile/i18n.js
        const { file: base = 'i18n' } = cds.env.i18n
        const file = path.join(bundleDest, base + '.json')

        // bundleDest might be null
        if (bundleDest && Object.keys(bundles).length > 0) {
            if (!this.hasBuildOption(BUILD_OPTION_OUTPUT_MODE, OUTPUT_MODE_RESULT_ONLY)) {
                await this.write(bundles).to(file)
            }
            return { file, bundles }
        }
        return null
    }

    _isSubDirectory(parent, child) {
        return !path.relative(parent, child).startsWith('..')
    }

    _commonStagingBuildFilter(src, destDir) {
        if (typeof src !== "string" || typeof destDir !== "string") {
            return false
        }
        if (!fs.statSync(src).isDirectory()) {
            return true //file
        }
        if (src === destDir) {
            return false
        }
        const regex = new RegExp(FOLDER_GEN + "\\b")
        if (src === this.buildOptions.target) {
            return false
        }
        return !regex.exec(path.basename(src))
    }

    static _find(srcDir, filter) {
        const files = []
        this._traverseFileSystem(srcDir, files, filter)
        return files;
    }

    static _traverseFileSystem(srcDir, files, filter) {
        let entries = []
        try {
            entries = fs.readdirSync(srcDir)
        } catch (e) {
            // ignore if not existing
        }
        entries.map(subDirEntry => path.join(srcDir, subDirEntry)).forEach((entry) => {
            this._handleResource(entry, files, filter)
        })
    }

    static _handleResource(entry, files, filter) {
        if (!filter || filter.call(this, entry)) {
            var stats = this._getResourceStatus(entry)
            if (stats.isDirectory()) {
                this._traverseFileSystem(entry, files, filter)
            } else if (stats.isFile() || stats.isSymbolicLink()) {
                files.push(entry)
            }
        }
    }

    // for testing purposes
    static _getResourceStatus(entry) {
        return fs.lstatSync(entry)
    }
}
module.exports = BuildTaskHandlerInternal
