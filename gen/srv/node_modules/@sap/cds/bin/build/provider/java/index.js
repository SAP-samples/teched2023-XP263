const fs = require('fs')
const path = require('path')
const cds = require('../../cds')
const BuildTaskHandlerEdmx = require('../buildTaskHandlerEdmx')
const { isOldJavaStack, BuildError } = require('../../util')

const { BUILD_OPTION_OUTPUT_MODE, ODATA_VERSION_V2, OUTPUT_MODE_RESULT_ONLY, FILE_EXT_CDS, SKIP_ASSERT_COMPILER_V2, CONTENT_LANGUAGE_BUNDLES, CONTENT_DEFAULT_CSN, DEFAULT_CSN_FILE_NAME } = require('../../constants')
const { INFO } = require('../../buildTaskHandler')

const DEFAULT_COMPILE_DEST_FOLDER = path.normalize('src/main/resources/edmx')

class JavaModuleBuilder extends BuildTaskHandlerEdmx {
    init() {
        super.init()
        this.task.options.compileDest = path.resolve(this.task.dest, this.task.options.compileDest || DEFAULT_COMPILE_DEST_FOLDER)
    }

    async build() {
        const { src, dest } = this.task

        const odataOptions = {
            version: cds.env.odata?.version
        }

        if (await isOldJavaStack([src, this.buildOptions.root])) {
            if (!this._isCompilerV1() && !cds.env.build?.[SKIP_ASSERT_COMPILER_V2]) {
                throw new BuildError('CDS compiler version 2 does no longer support the classic CAP Java runtime. It is recommended to migrate to the current CAP Java runtime SDK. See https://cap.cloud.sap/docs/java/migration for more.')
            }
            // default is now v4 and not v2 anymore, so warn and overwrite with v2 if using default
            if (!cds.env.for('cds', this.buildOptions.root, false).odata?.version) {
                odataOptions.version = ODATA_VERSION_V2
                this.pushMessage('Forcing OData v2 for building though the default is v4. Make sure to define OData v2 in cds configuration.', INFO)
            }

            // 'sql_mapping' and 'cds.persistence.name' annotations are required by old java stack
            if (cds.env.sql.names !== 'plain') {
                odataOptions.sql_mapping = cds.env.sql.names
            }
        }

        const model = await this.model()
        if (!model) {
            return this._result
        }

        const odata = await this._compileForOdata(model, this.task.options.compileDest, odataOptions)
        await this.compileToEdmx(odata, this.task.options.compileDest, odataOptions)

        if (this.hasBuildOption(CONTENT_LANGUAGE_BUNDLES, true)) {
            // collect and write language bundles into single i18n.json file
            const i18nFolder = cds.env.i18n.folders?.[0] || 'i18n'
            const i18n = await this.collectLanguageBundles(model, path.join(this.task.dest, i18nFolder))
            if (i18n) {
                this._result.languageBundles = i18n.bundles
            }
        }
        if (this.isStagingBuild() && !this.hasBuildOption(BUILD_OPTION_OUTPUT_MODE, OUTPUT_MODE_RESULT_ONLY)) {
            await this._copyNativeContent(src, dest)
        }
        return this._result
    }

    async clean() {
        if (this.isStagingBuild()) {
            return super.clean()
        }
        this.logger._debug && this.logger.debug(`Deleting build target folder ${this.task.options.compileDest}`)
        await fs.promises.rm(this.task.options.compileDest, { force: true, recursive: true })
    }

    async _copyNativeContent(src, dest) {
        return super.copyNativeContent(src, dest, (entry) => {
            if (fs.statSync(entry).isDirectory()) {
                return true // using common filter for folders
            } else {
                const extname = path.extname(entry)
                return extname !== FILE_EXT_CDS
            }
        })
    }

    async _compileForOdata(model, csnDest, compileOptions) {
        // csn for service providers
        const m = cds.compile.for.java(model, {
            ...this._options4odata(),
            ...compileOptions
        })
        const csnFile = path.join(csnDest, DEFAULT_CSN_FILE_NAME)
        let csnModel
        // adding csn to build result containing @source and _where persisted properties
        if (this.hasBuildOption(CONTENT_DEFAULT_CSN, true)) { //default true or undefined
            const csnStr = await this.compileToJson(model, csnFile)
            csnModel = JSON.parse(csnStr)
            csnModel.meta = model.meta
        } else {
            const csnStr = await this.compileToJson(m, csnFile)
            csnModel = JSON.parse(csnStr)
            csnModel.meta = m.meta
        }
        this._result.csn = csnModel

        return m
    }

    _isCompilerV1() {
        const version = cds.compiler.version()
        const match = version.match(/(\d+)\.?(\d*)\.?(\d*)/)
        return match && match[1] === 1
    }
}
module.exports = JavaModuleBuilder
