/* eslint-disable no-empty */
const fs = require('fs')
const path = require('path')
const cds = require('../../cds')
const BuildTaskProviderInternal = require("../buildTaskProviderInternal")
const BuildTaskHandlerEdmx = require('../buildTaskHandlerEdmx')
const { isStreamlinedMtx, hasJavaNature } = require('../../util')
const ResourcesTarProvider = require('./resourcesTarBuilder')

const { BUILD_TASK_HANA, FOLDER_GEN } = require('../../constants')
const { WARNING, ERROR } = BuildTaskHandlerEdmx
const FOLDER_SDC = "sdc"
const FOLDER_NODE_MODULES = "node_modules"
const FOLDER_TEMPLATES = "tpl"

class MtxModuleBuilder extends BuildTaskHandlerEdmx {
    get priority() {
        // should be scheduled after 'hana' build tasks are finished
        return BuildTaskHandlerEdmx.PRIORITY_MIN_VALUE
    }
    init() {
        super.init()

        if (hasJavaNature([this.buildOptions.root, this.task.src, cds.env.folders.srv])) {
            // Java projects having this build task configured are using Classic MTX
            // Streamlined MTX based Java projects have to configure the 'mtx-sidecar' build task instead.
            this._delegate = new ClassicMtxBuilder(this)
        } else {
            // Nodejs projects
            if (isStreamlinedMtx()) {
                this._delegate = new StreamlinedMtxBuilder(this)
            } else {
                this._delegate = new ClassicMtxBuilder(this)
            }
        }
    }

    async build() {
        return this._delegate.build()
    }

    async clean() {
        return this._delegate.clean()
    }
}

class StreamlinedMtxBuilder {
    constructor(handler) {
        this._handler = handler
    }
    async build() {
        // Non-sidecar scenario: model-provider is implemented by the Nodejs app itself (default for Nodejs).
        // Only create resources TAR, compiled CSN(s) are created by the Nodejs app build task.
        const dest = cds.env.build?.target !== "." ? this._handler.task.dest : path.join(this._handler.task.dest, FOLDER_GEN)
        const model = await this._handler.model()
        if (!model) {
            return
        }
        return new ResourcesTarProvider(this._handler).createTar(dest, model)
    }
    async clean() {
        // staging build content is deleted by BuildTaskEngine
        if (this._handler.buildOptions.root === this._handler.buildOptions.target) {
            // remove 'gen' folder
            return fs.promises.rm(path.join(this._handler.task.dest, FOLDER_GEN), { force: true, recursive: true })
        }
    }
}

class ClassicMtxBuilder {
    constructor(handler) {
        this._handler = handler
    }

    async build() {
        if (cds.env.requires.toggles === true) {
            throw new Error("Feature toggles are only supported by Streamlined MTX")
        }

        const buildOptions = this._handler.buildOptions
        const destSdc = buildOptions.root === buildOptions.target ? path.join(this._handler.task.dest, FOLDER_GEN, FOLDER_SDC) : path.join(this._handler.task.dest, FOLDER_SDC)
        const model = await this._handler.model()
        if (!model) {
            return
        }

        // custom build tasks for srv and db modules might be defined
        const tenantDbPath = await this._getHanaTenantDbPath()

        // validate extension whitelists defined for this SaaS application
        this._validateExtensionAllowLists(model, tenantDbPath)

        // copy base model sources
        await Promise.all(model.$sources.map(src => {
            if (src.includes(FOLDER_NODE_MODULES)) {
                return this._handler.copy(src).to(path.join(destSdc, src.substr(src.indexOf(FOLDER_NODE_MODULES))))
            } else {
                const relSrc = path.relative(buildOptions.root, src)
                if (relSrc.startsWith("..")) {
                    this._handler.logger.warn(`model file is out of project scope, skipping file ${src}`)
                    return Promise.resolve()
                }
                return this._handler.copy(src).to(path.join(destSdc, relSrc))
            }
        }))

        // collect and write language bundles into single i18n.json file
        const i18nFolder = cds.env.i18n.folders?.[0] || 'i18n'
        const i18n = await this._handler.collectLanguageBundles(model, path.join(destSdc, i18nFolder))
        if (i18n) {
            this._handler._result.languageBundles = i18n.bundles
        }

        // copy native hana content and templates
        await this._copyNativeContent(this._handler.task.src, destSdc, tenantDbPath)
    }

    async clean() {
        // staging build content is deleted by BuildTaskEngine
        if (this._handler.buildOptions.root === this._handler.buildOptions.target) {
            // remove 'gen' folder
            return fs.promises.rm(path.join(this._handler.task.dest, FOLDER_GEN), { force: true, recursive: true })
        }
    }

    async _copyNativeContent(src, dest, tenantDbPath) {
        // copying templates
        const tplSrc = path.join(src, FOLDER_TEMPLATES)
        if (fs.existsSync(tplSrc)) {
            const tplDest = path.join(path.dirname(dest), FOLDER_TEMPLATES)
            await this._copyTemplates(tplSrc, tplDest)
        }

        if (tenantDbPath) {
            // copy native HANA artifacts, e.g. .csv files
            const dbDest = path.resolve(dest, path.relative(this._handler.buildOptions.root, tenantDbPath))
            if (!src.startsWith(dbDest)) { // ensure valid paths
                await this._copyNativeHanaContent(tenantDbPath, dbDest)
            } else {
                this.pushMessage(`Invalid mtx build task configuration detected, destination folder ${dbDest} must not be nested within 'src' folder`, ERROR)
            }
        }
    }

    async _copyNativeHanaContent(src, dest) {
        return this._handler.copyNativeContent(src, dest, (entry) => {
            if (fs.statSync(entry).isDirectory()) {
                const folderName = path.basename(entry)
                return folderName !== FOLDER_NODE_MODULES
            }
            // also add table data properties files containing translated texts
            return /\.csv$|\.hdb.*$|^\.hdi.*|\.properties$|^undeploy\.json/.test(path.basename(entry))
        })
    }

    async _copyTemplates(src, dest) {
        return this._handler.copyNativeContent(src, dest, (entry) => {
            if (fs.statSync(entry).isFile()) {
                return /\.cds$/.test(path.basename(entry))
            }
            return true
        })
    }

    /**
     * Extensions shall be restricted to relevant entities, by default all entities and services can be extended.
     * Empty whitelists indicate that all services or entities can be extended.
     * <br>
     * A warning is logged in case neither a 'entity-whitelist' nor a o service-whitelist has been defined.
     * An error is thrown in case a invalid entry is found.
     *
     * @param {Object} model - the reflected csn for this SaaS application
     */
    _validateExtensionAllowLists(model, tenantDbPath) {
        let entityWhitelist = cds.env.mtx?.["entity-whitelist"]
        let serviceWhitelist = cds.env.mtx?.["service-whitelist"]
        let extensionAllowlist = cds.env.mtx?.["extension-allowlist"]

        // for java projects mtx configuration is part of sidecar config
        if (!entityWhitelist && !serviceWhitelist && !extensionAllowlist && tenantDbPath) {
            const dbEnv = cds.env.for("cds", tenantDbPath)
            entityWhitelist = dbEnv.mtx?.["entity-whitelist"]
            serviceWhitelist = dbEnv.mtx?.["service-whitelist"]
            extensionAllowlist = dbEnv.mtx?.["extension-allowlist"]
        }

        function isValid(e, pattern, nsPattern, kind) {
            return e && e.name && (e.name === pattern || (nsPattern && e.name.startsWith(nsPattern))) && (!kind || e.kind === kind)
        }

        if (extensionAllowlist || entityWhitelist || serviceWhitelist) {
            const invalidEntries = new Set()
            const reflected = cds.reflect(model)

            if (Array.isArray(extensionAllowlist)) {
                extensionAllowlist.forEach(allowListEntry => {
                    if (Array.isArray(allowListEntry.for)) {
                        allowListEntry.for.forEach(pattern => {
                            if (pattern !== '*') {
                                if (!reflected.find(e => isValid(e, pattern, pattern + '.', allowListEntry.kind))) {
                                    invalidEntries.add(pattern)
                                }
                            }
                        })
                    }
                })
                if (invalidEntries.size > 0) {
                    this._handler.pushMessage(`Invalid entries found in 'extension-allowlist' - [${[...invalidEntries].join(', ')}]`, WARNING)
                }
            } else if (Array.isArray(entityWhitelist) || Array.isArray(serviceWhitelist)) {
                // validate whitelist entries
                if (Array.isArray(entityWhitelist)) {
                    entityWhitelist.forEach(name => {
                        if (!reflected.find(e => isValid(e, name, null, "entity"))) {
                            invalidEntries.add(name)
                        }
                    })
                }
                if (Array.isArray(serviceWhitelist)) {
                    serviceWhitelist.forEach(name => {
                        if (!reflected.find(e => isValid(e, name, null, "service"))) {
                            invalidEntries.add(name)
                        }
                    })
                }
                if (invalidEntries.size > 0) {
                    this._handler.pushMessage(`Invalid entries found in 'entity-whitelist' or 'service-whitelist' - [${[...invalidEntries].join(', ')}]`, WARNING) //NOSONAR
                }
            }
        }
    }

    /**
     * Returns the build tasks of this project - either user defined or calculated by BuildTaskFactory.
     * A build task of type 'hana' is enforced in order to copy existing native hana artifacts later on.
     *
     * @returns {string} the src folder of the tenant db module
     */
    async _getHanaTenantDbPath() {
        let tasks = this._handler.buildOptions.tasks || []
        const modelPaths = this._handler.resolveModel()

        // ensure that the hana task is contained even if this mtx task has been executed solely using "cds build --for mtx"
        if (!tasks.find(task => task.for === BUILD_TASK_HANA)) {
            //mtx task might have been executed as separate task
            tasks = cds.env.build?.tasks || []
            if (tasks.length === 0) {
                const provider = new BuildTaskProviderInternal(this._handler.logger)
                await provider.lookupTasks(tasks, this._handler.buildOptions)
            }
        }
        // the SaaS app might use a tenant aware db as well as a shared db deployed using static hdi-deployer
        // pick the hana build task referring to the tenant aware db - the src path has to be contained in this build task's model options
        const hanaDbPaths = tasks.filter(task => task.for === BUILD_TASK_HANA).map(hanaTask => path.resolve(this._handler.buildOptions.root, hanaTask.src || cds.env.folders.db))
        let tenantDbPath = hanaDbPaths.find(hanaDbPath => hanaDbPaths.length === 1 || modelPaths.some(modelPath => path.dirname(modelPath) === hanaDbPath))

        if (!tenantDbPath) {
            tenantDbPath = path.join(this._handler.buildOptions.root, cds.env.folders.db)
            if (hanaDbPaths.length === 0) {
                this._handler.pushMessage(`no 'hana' build task found, use default location '${tenantDbPath}'`, WARNING)
            } else {
                this._handler.pushMessage(`no 'hana' build task found matching model scope '${this._handler.task.options.model}', use default location '${tenantDbPath}'`, WARNING)
            }
        }
        return tenantDbPath
    }
}
module.exports = MtxModuleBuilder
