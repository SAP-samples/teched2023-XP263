const fs = require('fs')
const path = require('path')
const cds = require('./cds')
const { SEVERITY_ERROR, FILE_EXT_CDS } = require('./constants')

function getProperty(src, segments) {
    segments = Array.isArray(segments) ? segments : segments.split('.')
    return segments.reduce((p, n) => p && p[n], src)
}

function setProperty(src, segments, value) {
    segments = Array.isArray(segments) ? segments : segments.split('.')
    segments.reduce((p, n, idx) => {
        if (segments.length === idx + 1) {
            p[n] = value
        } else {
            if (p[n] === undefined) {
                p[n] = {}
            }
        }
        return p[n]
    }, src)
}

/**
 * Returns an array of pom.xml file paths found in the given directories.
 * @param {Array} dirs - the absolute path names to check.
 */
function readPomFilePaths(dirs) {
    return dirs.flat().reduce((acc, dir) => {
        if (dir) {
            const file = path.join(dir, 'pom.xml')
            if (fs.existsSync(file)) {
                acc.push(file)
            }
        }
        return acc
    }, [])
}

/**
 * Returns whether this project is a java project or not.
 * @param {Array} dirs - the absolute path names to check.
 */
function hasJavaNature(dirs) {
    return readPomFilePaths(dirs).length > 0
}

/**
 * Determines whether the both values are identical.
 * @param {*} actual
 * @param {*} expected
 */
function hasOptionValue(actual, expected) {
    if (typeof expected === 'undefined') {
        return actual !== undefined
    }
    if (typeof actual === 'undefined') {
        return false
    }
    if (typeof expected === 'boolean') {
        if (typeof actual === 'string') {
            return String(expected) === actual
        }
    }
    return actual === expected
}

// Returning the project relative path representation of the given path(s),
function relativePaths(root, qualifiedPaths) {
    qualifiedPaths = typeof qualifiedPaths === "string" ? [qualifiedPaths] : qualifiedPaths
    if (Array.isArray(qualifiedPaths)) {
        return qualifiedPaths.map(qualifiedPath => {
            const relPath = path.relative(root, qualifiedPath)
            return relPath || "."
        })
    }
    return qualifiedPaths
}

/**
 * Returns <code>true</code> if this project is an old java service-sdk project,
 * <code>false</code> if it is a java-NG project or if no pom.xml has been found.
 * @param {Array} dirs - the absolute path names to check.
 */
async function isOldJavaStack(dirs) {
    const files = readPomFilePaths(dirs)
    if (files.length > 0) {
        return (await Promise.all(files.map(async file => {
            const content = await fs.promises.readFile(file, 'utf-8')
            return content && /<groupId>\s*com\.sap\.cloud\.servicesdk\.prov\s*<\/groupId>/.test(content)
        }))).some(result => result)
    }
    return false
}

function redactCredentials(config, o) {
    return JSON.stringify(config, (k, v) => {
        if (!v) {
            return v
        }
        if (k === 'credentials') {
            try {
                return _redacted(v)
            } catch (e) {/* ignored */ }
        }
        return v
    }, o && o.indents || 2)
}

/** redacts password-like strings, also reducing clutter in output */
function _redacted(cred) {
    const secrets = /(password)|(certificate)|(ca)/i // 'certificate' and 'ca' on HANA
    const newCred = Object.assign({}, cred)
    Object.keys(newCred)
        .filter(k => typeof newCred[k] === 'string' && secrets.test(k))
        .forEach(k => newCred[k] = '...')
    return newCred
}

/**
 * Distinguishes whether the Nodejs project is a Streamlined MTX (cds >=6) or an old MTX project.
 */
function isStreamlinedMtx() {
    if (cds.utils._oldMtx()) {
        return false
    }
    return (cds.env.requires.toggles
        || cds.env.profiles.includes('with-mtx-sidecar') // new presets
        || cds.env.requires['cds.xt.ModelProviderService']
        || (typeof cds.env.requires.multitenancy === "object")
    ) && !(() => { try { return cds.mtx } catch (e) { /**/ } })()
}

/**
 * Returns a list of fully qualified model names belonging to the '@sap' namespace that cannot be resolved.
 * E.g. the module might NOT have been installed.
 * @param {Array} modelPaths
 * @returns {Array}
 */
function resolveRequiredSapModels(modelPaths) {
    return Array.isArray(modelPaths) && modelPaths.filter(p => {
        if (p.startsWith('@sap/')) {
            const files = cds.resolve(p)
            return !files || files.length === 0
        }
    })
}

function getDefaultModelOptions(projectPath) {
    const fts = cds.env.features.folders
    const modelPaths = cds.resolve(!fts ? '*' : ['*', fts], false)
    return _pushModelPaths(projectPath, modelPaths)
}

function _pushModelPaths(projectPath, ...modelPaths) {
    const model = new Set()
    // may contain nested arrays
    modelPaths = flatten(modelPaths)
    const { roots } = cds.env
    modelPaths.forEach(m => {
        if (m && !model.has(m) && !model.has(m + "/")) {
            // filter root model paths that do not exist
            // other entries are added as is, e.g. reuse model entries
            if (roots.includes(m)) {
                const dir = path.resolve(projectPath, m)
                if (fs.existsSync(dir)) {
                    model.add(m.replace(/\/$/, ''))
                } else if (fs.existsSync(dir + FILE_EXT_CDS)) { //might be cds file name, compatibility to old build configs
                    model.add(m)
                }
            } else {
                model.add(m)
            }
        }
    })
    return [...model]
}

function flatten(modelPaths) {
    return modelPaths.reduce((acc, m) => {
        if (Array.isArray(m)) {
            acc = acc.concat(flatten(m))
        } else if (m) {
            acc.push(m)
        }
        return acc
    }, [])
}

/**
 * Copy a file or directory. The directory can have contents.
 * REVISIT: 'fs.promises.cp' replacement for nodejs 14
 * @param src <String> Note that if src is a directory it will copy everything inside of this directory, not the entire directory itself.
 * @param dest <String> Note that if src is a file, dest cannot be a directory.
 */
async function copy(src, dest) {
    if ((await fs.promises.stat(src)).isDirectory()) {
        const entries = await fs.promises.readdir(src)
        return Promise.all(entries.map(async each => copy(path.join(src, each), path.join(dest, each))))
    } else {
        await fs.promises.mkdir(path.dirname(dest), { recursive: true })
        return fs.promises.copyFile(src, dest)
    }
}

/**
 * Return gnu-style error string for location `loc`:
 *  - 'File:Line:Col' without `loc.end`
 *  - 'File:Line:StartCol-EndCol' if Line = start.line = end.line
 *  - 'File:StartLine.StartCol-EndLine.EndCol' otherwise
 *
 * @param {CSN.Location|CSN.Location} location
 */
function _locationString(loc) {
    if (!loc)
        return '<???>';
    if (!(loc instanceof Object))
        return loc;
    if (!loc.line) {
        return loc.file;
    }
    else if (!loc.endLine) {
        return (loc.col)
            ? `${loc.file}:${loc.line}:${loc.col}`
            : `${loc.file}:${loc.line}`;
    }

    return (loc.line === loc.endLine)
        ? `${loc.file}:${loc.line}:${loc.col}-${loc.endCol}`
        : `${loc.file}:${loc.line}.${loc.col}-${loc.endLine}.${loc.endCol}`;
}

/**
 * Class for individual build message.
 *
 * @class BuildMessage
 */
class BuildMessage {
    /**
     * Creates an instance of BuildMessage.
     * @param {string} message The message text
     * @param {string} [severity='Error'] Severity: Debug, Info, Warning, Error
     * @param {any} location Location of the message
     * 
     * @memberOf BuildMessage
     */
    constructor(message, severity = SEVERITY_ERROR, location) {
        this.message = message
        this.name = "BuildMessage"
        this.severity = severity
        this.$location = location
    }
    toString() {
        return `${this.$location?.file ? _locationString(this.$location) + ':' : ''} ${this.severity}: ${this.message}`
    }
}

/**
 * Class for combined build and compiler errors. 
 * Additional members:
 *   messages: vector of detailed build messages
 * @class BuildError
 * @extends {Error}
 */
class BuildError extends Error {
    constructor(message, messages = []) {
        super(message)
        this.name = "BuildError"
        this.messages = Array.isArray(messages) ? messages : [messages]
        this.stack = ""
    }

    // for compatibility reasons
    get errors() {
        return this.messages
    }

    toString() {
        return this.message + (this.messages.length > 0 ? '\n' + this.messages.map(m => m.toString()).join('\n') : '')
    }
}

module.exports = {
    getProperty,
    setProperty,
    hasJavaNature,
    isOldJavaStack,
    redactCredentials,
    hasOptionValue,
    relativePaths,
    isStreamlinedMtx,
    resolveRequiredSapModels,
    getDefaultModelOptions,
    flatten,
    copy,
    BuildMessage,
    BuildError
}
