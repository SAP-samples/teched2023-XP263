const fs = require('fs')
const path = require('path')
const cds = require('./cds'), { log } = cds.exec
const BuildTaskProviderFactory = require('./buildTaskProviderFactory')
const { hasJavaNature, getProperty, redactCredentials, flatten, getDefaultModelOptions } = require('./util')
const { FILE_EXT_CDS, BUILD_TASK_JAVA_CF, LOG_MODULE_NAMES, BUILD_TASK_JAVA } = require("./constants")

class BuildTaskFactory {
    constructor(logger) {
        this._logger = logger || cds.log(LOG_MODULE_NAMES)
    }
    get logger() {
        return this._logger
    }

    // the following order for determining build tasks is used
    // 1. create from command line input, e.g. cds build/all --for hana --src db --model srv --dest db
    // 2. read using cds.env.build.tasks
    // 3. create from cds.env.folders config data
    async getTasks(buildOptions = { root: process.env._TEST_CWD || process.cwd() }) {
        try {
            const providerFactory = new BuildTaskProviderFactory(this._logger, buildOptions)
            const tasks = await this._createTasks(providerFactory)
            buildOptions.target = path.resolve(buildOptions.root, cds.env.build.target)

            // log build tasks
            this.logger.log(`the following build tasks will be executed`)
            let tasksOutput = "   {\n     \"build\": {\n       \"target\": \"" + cds.env.build.target + "\",\n       \"tasks\": ["
            for (let i = 0; i < tasks.length; i++) {
                tasksOutput += "\n         " + BuildTaskFactory._stringifyTask(tasks[i]) + (i + 1 < tasks.length ? "," : "")
            }
            tasksOutput += "\n       ]\n     }\n   }\n"
            this.logger.log(tasksOutput)

            // for testing purposes
            this.logger.debug("cds.env used for build:")
            this.logger._debug && this.logger.debug(redactCredentials(cds.env))

            // always resolve tasks for input validation
            if (buildOptions.resolve || buildOptions.cli) {
                const resolvedTasks = providerFactory.resolveTasks(tasks)
                if (buildOptions.resolve) {
                    return resolvedTasks
                }
            }
            return tasks
        } catch (e) {
            this.logger.log('')
            // cds CLI layer is doing the logging if invoked using CLI
            if (!buildOptions.cli) {
                log(e, { withStack: true, log: (message) => this.logger.log(message) })
            }
            throw e
        }
    }

    async _createTasks(providerFactory) {
        const buildOptions = providerFactory.buildOptions
        this.logger.debug(`determining build tasks for project [${buildOptions.root}].`)

        // clearing model cache (details https://github.tools.sap/cap/cds/pull/181) is no longer required 
        // because of changes https://github.tools.sap/cap/cds/pull/1121
        // cds.resolve.cache = {}

        let tasks = BuildTaskFactory._getExistingTasks()
        if (tasks.length === 0) {
            tasks = await providerFactory.lookupTasks()
            await providerFactory.applyTaskDefaults(tasks)
        } else {
            // 1. apply default values including task.for and task.use and ensure that for all tasks a provider exists - throwing error otherwise
            await providerFactory.applyTaskDefaults(tasks)
            await providerFactory.lookupTasks(tasks)
        }

        // 3. filters the list of build tasks and adapts according to given CLI options
        // Note: A new task will be created if invoked using CLI 'cds build --for <xxx>' 
        // where <xxx> matches a valid task type like 'hana', 'java' etc.
        const existingTasks = tasks
        tasks = await BuildTaskFactory._applyCliTaskOptions(providerFactory, tasks)

        if (tasks.length === 0) {
            return tasks
        }

        // 2. add dependencies
        await providerFactory.lookupTasks(tasks)

        if (tasks !== existingTasks && tasks.some(task => !existingTasks.find(existingTask => existingTask === task))) {
            // a different task shall be executed
            await providerFactory.applyTaskDefaults(tasks)
        }

        // obligatory task defaults shared by all tasks
        BuildTaskFactory._applyCommonTaskDefaults(tasks, buildOptions)

        // ensure correct values for optional build task properties, error for missing mandatory properties
        BuildTaskFactory._validateBuildTasks(tasks)

        this._setDefaultBuildTargetFolder(tasks, buildOptions)
        return tasks
    }

    static _getExistingTasks() {
        return Array.isArray(getProperty(cds.env, 'build.tasks')) ? JSON.parse(JSON.stringify(cds.env.build.tasks)) : []
    }

    static _applyCommonTaskDefaults(tasks, buildOptions) {
        const modelPaths = getDefaultModelOptions(buildOptions.root)

        tasks.forEach(task => {
            this._setTaskModelOptions(task, modelPaths)
            if (!task.src) {
                throw new Error(`Invalid build task definition - value of property 'src' is missing in [${task.for || task.use}].`)
            }
        })
    }

    static _validateBuildTasks(tasks) {
        tasks.forEach(task => {
            if (!task.src) {
                throw new Error(`Invalid build task definition - value of property 'src' is missing in [${task.for || task.use}].`)
            }
        })
    }

    _setDefaultBuildTargetFolder(tasks, buildOptions) {
        const task = tasks.find(task => task.for === BUILD_TASK_JAVA_CF || task.for === BUILD_TASK_JAVA)
        const srv = task ? task.src : BuildTaskFactory._getModuleFolder(buildOptions.root, flatten([cds.env.folders.srv])) || "srv"

        // Java projects use "." as the default build target folder
        if (BuildTaskFactory._hasJavaNature(buildOptions.root, srv) && BuildTaskFactory._adaptBuildTargetSettingForJava(buildOptions.root)) {
            this.logger.debug("using inplace build for java project instead of default staging build")
        }
        buildOptions.target = path.resolve(buildOptions.root, cds.env.build.target)
    }

    /**
     * Returns whether this project is a java project or not.
     * @param {string} projectPath - the absolute project path
     * @param {string} src - the folder name of the service module
     */
    static _hasJavaNature(projectPath, src) {
        return hasJavaNature([path.join(projectPath, src), projectPath])
    }

    /**
    * Use inplace build for java projects if build.target has not been configured.
    * @param {string} projectPath
    * @returns {boolean} true if changed, false otherwise
    */
    static _adaptBuildTargetSettingForJava(projectPath) {
        if (cds.env.build.target !== ".") {
            // filter user settings of cds.env
            const userEnv = cds.env.for("cds", projectPath, false)

            // use helper as env.build might be undefined
            if (!getProperty(userEnv, "build.target")) {
                cds.env.build.target = "."
                return true
            }
        }
        return false
    }

    static async _applyCliTaskOptions(providerFactory, tasks) {
        const { buildOptions } = providerFactory
        if (buildOptions.cmdOptions) {
            const options = buildOptions.cmdOptions

            // filter tasks using either option for, use, src
            tasks = tasks.filter(task => {
                return (!options.use || options.use === task.use)
                    && (!options.for || options.for === task.for)
                    && (!options.src || options.src === task.src)
            })
            if (tasks.length === 0 && (options.for || options.use)) {
                const task = {}
                if ((options.for)) {
                    task.for = options.for
                }
                if ((options.use)) {
                    task.use = options.use
                }
                if (options.src) {
                    task.src = options.src
                }
                tasks.push(task)
            }
            // apply remaining cli options to filtered tasks
            tasks.forEach(task => {
                if (options.dest) {
                    task.dest = options.dest
                }
                if (options.opts) {
                    const opts = this._scanTaskOptionParams(options.opts)
                    task.options = task.options ? Object.assign(task.options, opts) : opts
                }
            })
        }
        return tasks
    }

    static _setTaskModelOptions(task, defaultModelPaths) {
        task.options = task.options || {}
        if (!task.options.model || Array.isArray(task.options.model) && task.options.model.length === 0) {
            defaultModelPaths = new Set(defaultModelPaths)
            if (task.src) {
                defaultModelPaths.add(task.src)
            }
            task.options.model = [...defaultModelPaths]
        } else if (!Array.isArray(task.options.model)) {
            task.options.model = [task.options.model]
        }
    }

    static _stringifyTask(task) {
        // ensures identical order of properties
        const order = ["for", "use", "src", "dest", "options"]
        const keys = Object.keys(task).sort((a, b) => order.indexOf(a) - order.indexOf(b))

        return keys.reduce((acc, key, idx) => {
            // render either "for" OR "use" value
            return acc + (!key.match("^_") ? (key !== "use" || keys[idx - 1] !== "for" ? (acc !== "{" ? ", " : "") + JSON.stringify(key) + ":" + JSON.stringify(task[key]) : "") : "")
        }, "{") + "}"
    }

    static _scanTaskOptionParams(optsParams) {
        // need to create new regex every call since a constant would keep the match state
        const quoteRegex = /([\w-]+)=([\w/.]+|\[([\w/,.]+)\])/g

        // captures a=1             => a:1
        //          a=[x,y,z]       => a:[x,y,z]
        //          a=1,b=[x,y,z]   => a:1 b=[x,y,z]
        let match = quoteRegex.exec(optsParams)
        const taskOptions = {}

        while (match != null) {
            const key = match[1]
            const value = match[3] || match[2]
            const valueArray = value.split(",")
            taskOptions[key] = valueArray.length > 1 ? valueArray.map((entry) => entry.trim()) : value
            match = quoteRegex.exec(optsParams)
        }
        return taskOptions
    }

    /**
     * For valid paths remove trailing '/'. Otherwise return as is - important!!
     * @param {*} dir
     */
    static _normalizePath(dir) {
        return typeof dir === "string" ? dir.replace(/\/$/, '') : dir
    }

    /**
     * Determines the module folder from the past list that may represent files or folders w or w/o .cds file extension.
     * @param {string} projectPath
     * @param {Array} filesOrFolders
     */
    static _getModuleFolder(projectPath, filesOrFolders) {
        const resources = [...filesOrFolders]
        filesOrFolders.forEach(fileOrFolder => {
            if (path.extname(fileOrFolder) !== FILE_EXT_CDS) {
                resources.push(fileOrFolder + FILE_EXT_CDS)
            }
        })
        return resources.reduce((acc, resource) => {
            if (!acc) {
                let resourcePath = path.resolve(projectPath, resource)
                if (fs.existsSync(resourcePath)) {
                    if (fs.lstatSync(resourcePath).isDirectory()) {
                        acc = resource
                    } else {
                        // represents file
                        acc = path.dirname(resource)
                    }
                }
            }
            return acc
        }, null)
    }
}
module.exports = BuildTaskFactory
