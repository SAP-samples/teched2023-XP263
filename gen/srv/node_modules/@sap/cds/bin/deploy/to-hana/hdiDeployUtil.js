const cp = require('child_process');
const path = require('path');
const util = require('util');

const execAsync = util.promisify(cp.exec);

const cds = require('../../../lib');
const LOG = cds.log ? cds.log('deploy') : console;
const DEBUG = cds.debug('deploy');
const { SILENT } = cds.log.levels;

class HdiDeployUtil {

    constructor() {
        this.hdiDeployLibs = new Map();
        this.deployerName = '@sap/hdi-deploy'
        this.deployerVersionSpec = '^4'
    }

    async deployTenant(dbDir, env) {
        await this._executeDeploy(dbDir, env, true);
    }

    async deploy(dbDir, vcapEnv, options) {
        vcapEnv = vcapEnv || {}; // handles null and undefined
        options = options || {};

        console.log(`Deploying to HANA from ${dbDir}`);

        const hdiDeployLib = await this._getHdiDeployLib(dbDir);

        let deployerEnv = JSON.parse(JSON.stringify(process.env));
        const hdiDeployOptions = deployerEnv.HDI_DEPLOY_OPTIONS ? JSON.parse(deployerEnv.HDI_DEPLOY_OPTIONS) : {};
        delete hdiDeployOptions.root;

        if (typeof hdiDeployLib.clean_env === 'function') {
            deployerEnv = hdiDeployLib.clean_env(deployerEnv);
        }

        if (vcapEnv.VCAP_SERVICES) {
            deployerEnv.VCAP_SERVICES = JSON.stringify(vcapEnv.VCAP_SERVICES);
        }
        if (vcapEnv.SERVICE_REPLACEMENTS) {
            deployerEnv.SERVICE_REPLACEMENTS = JSON.stringify(vcapEnv.SERVICE_REPLACEMENTS);
        }
        if (vcapEnv.TARGET_CONTAINER) {
            deployerEnv.TARGET_CONTAINER = vcapEnv.TARGET_CONTAINER;
        }

        if (options.autoUndeploy) {
            console.log(`Hdi deployer automatically undeploys deleted resources using --auto-undeploy.`);
            hdiDeployOptions.auto_undeploy = true;
        }

        if (Object.entries(hdiDeployOptions).length > 0) {
            deployerEnv.HDI_DEPLOY_OPTIONS = JSON.stringify(hdiDeployOptions);
        }

        await this._executeDeploy(dbDir, deployerEnv);
    }


    async findHdiDeployLib(cwd) {
        const searchPaths = await this._npmSearchPaths(cwd)
        try {
            return require.resolve(path.join(this.deployerName, 'library'), { paths: searchPaths });
        } catch (err) {
            // no luck
        }
    }


    async _getHdiDeployLib(dbDir) {
        let hdiDeployLib = this.hdiDeployLibs.get(dbDir)
        if (!hdiDeployLib) {
            hdiDeployLib = await this._loadHdiDeployLib(dbDir);
            this.hdiDeployLibs.set(dbDir, hdiDeployLib);
        }

        return hdiDeployLib;
    }


    async _loadHdiDeployLib(cwd) {
        const libPath = await this.findHdiDeployLib(cwd)
        if (!libPath) {
            const searchPaths = await this._npmSearchPaths(cwd)
            throw new Error(`Required library '${this.deployerName}' not found in
    ${searchPaths.join('\n    ')}
Add it either as a devDependency using 'npm install -D ${this.deployerName}' or install it globally using 'npm install -g ${this.deployerName}'.`);
        }

        LOG.info(`Using HDI deployer from ${libPath}`)

        // let any error go through and abort deploy
        return require(libPath);
    }


    async _npmSearchPaths(cwd) {
        // REVISIT: we shouldn't have to rely on `npm` on the server
        try {
            const npmRootCall = await execAsync('npm root -g');
            const globalNodeModules = npmRootCall.stdout.toString().trim();
            return [cwd, globalNodeModules, '@sap/hdi-deploy']
        } catch (error) {
            if (/Command failed: npm.*not found/s.test(error.message)) return [cwd, '@sap/hdi-deploy']
            else throw error
        }
    }


    async _executeDeploy(dbDir, env, fromMtx) {
        const hdiDeployLib = await this._getHdiDeployLib(dbDir);
        let writeStream
        if (fromMtx) {
            await cds.utils.mkdirp('logs')
            writeStream = require('fs').createWriteStream(path.join(cds.root, 'logs', `${cds.context.tenant}.log`))
        }
        return new Promise((resolve, reject) => {
            const callbacks = {
                stderrCB: buffer => {
                    LOG.error(buffer.toString())
                    writeStream?.write(buffer)
                },
            }
            if (fromMtx) {
                callbacks.stdoutCB = buffer => {
                    DEBUG?.(buffer.toString())
                    writeStream.write(buffer)
                }
            } else if (LOG.level !== SILENT) {
                callbacks.stdoutCB = buffer => LOG.info(buffer.toString())
            }
            hdiDeployLib.deploy(dbDir, env, (error, response) => {
                if (error) {
                    return reject(error);
                }
                if (response?.exitCode) {
                    let message = `HDI deployment failed with exit code ${response.exitCode}`
                    if (response.signal) message += `. ${response.signal}`
                    return reject(new Error(message));
                }
                return resolve();
            }, callbacks);
        }).finally(() => writeStream?.end());
    }
}


module.exports = new HdiDeployUtil();

/* eslint no-console: off */
