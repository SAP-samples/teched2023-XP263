const cp = require('child_process');
const os = require('os');
const path = require('path');
const util = require('util');

const fs = require('fs').promises;

const { BuildTaskEngine, BuildTaskFactory } = require('../../build');
const buildConstants = require('../../build/constants');

const cfUtil = require('./cfUtil');
const hdiDeployUtil = require('./hdiDeployUtil');
const gitUtil = require('./gitUtil');
const mtaUtil = require('./mtaUtil');

const { bold, info } = require('../../utils/term');

const IS_WIN = (os.platform() === 'win32');
const UTF_8 = 'utf-8';


class HanaDeployer {

  constructor() {
    this.execAsync = util.promisify(cp.exec);
    this.spawnSync = cp.spawnSync;
  }

  getFromEnv(...varNames) {
    const result = {}
    for (const varName of varNames) {
      if (process.env[varName]) {
        try {
          result[varName] = JSON.parse(process.env[varName]);
        } catch (err) {
          throw new Error(`Error parsing environment variable ${varName}`);
        }
      }
    }
    return result;
  }

  async deploy(model, serviceName, noSave, tunnelAddress, buildTaskOptions, vcapFile, undeployWhitelist, hdiOptions, bindCallback) { // NOSONAR
    hdiOptions = hdiOptions || {}

    console.log(`${bold('Starting deploy to SAP HANA ...')}`);
    if (vcapFile) {
      console.log(`Using VCAP_SERVICES from file ${vcapFile} (beta feature).`);
      bindCallback = null // credentials are given - no cds bind then
    } else if (bindCallback) {
      console.log('Using cds bind');
    }

    const projectPath = path.resolve(process.env._TEST_CWD || process.cwd());

    const { buildResults } = await this._build(model, buildTaskOptions);

    let globalVcapEnv = vcapFile ? await this._loadEnvFile(vcapFile) : {};
    globalVcapEnv = { ...globalVcapEnv, ...this.getFromEnv('VCAP_SERVICES', 'SERVICE_REPLACEMENTS') };
    if (process.env.TARGET_CONTAINER) {
      globalVcapEnv.TARGET_CONTAINER = process.env.TARGET_CONTAINER;
    }

    for (const buildResult of buildResults) {
      let vcapEnv = globalVcapEnv;
      let serviceKeyName;
      const currentModelFolder = buildResult.result.dest;

      if (undeployWhitelist) {
        console.log('Writing undeploy.json');
        await fs.write(path.join(currentModelFolder, 'undeploy.json'), JSON.stringify(undeployWhitelist, null, 2));
      }

      const hasVCAPEnv = Object.keys(vcapEnv).length > 0;
      if (!serviceName && hasVCAPEnv) {
        await fs.mkdir(currentModelFolder, { recursive: true });
      } else {
        const { cfServiceInstanceName, cfServiceInstanceKeyName, serviceKey } =
          await this._getOrCreateCFService(projectPath, currentModelFolder, serviceName, tunnelAddress);
        serviceKeyName = cfServiceInstanceKeyName;
        serviceName = serviceName || cfServiceInstanceName;

        vcapEnv = this._getVCAPServicesEntry(cfServiceInstanceName, serviceKey);

        if (!noSave && !bindCallback) {
          await this._addInstanceToDefaultEnvJson([currentModelFolder, projectPath], cfServiceInstanceName, serviceKey);
        }
      }

      // Check if deployer is already installed, otherwise only install this one, not the rest of dependencies.
      if (!await hdiDeployUtil.findHdiDeployLib(currentModelFolder)) {
        const { deployerName, deployerVersionSpec } = hdiDeployUtil;
        console.log(`Installing ${deployerName}`);

        // spawn has not callback and cannot be promisified, using sync instead
        this.spawnSync(`npm`, [`install`, `${deployerName}@${deployerVersionSpec}`, (noSave ? '--no-save' : '--save-dev')], {
          cwd: currentModelFolder,
          shell: IS_WIN,
          stdio: 'inherit',
          env: {
            ...process.env,
            NODE_ENV: 'development' // for 'install --save-dev' to work, there must be no 'production' set
          }
        });
      }

      await hdiDeployUtil.deploy(currentModelFolder, vcapEnv, hdiOptions);

      // let isLoggedInToCF;
      // try {
      //   isLoggedInToCF = !!(await cfUtil.getCfTarget());
      // } catch (err) {
      //   // valid state: not logged in
      // }
      // if (bindCallback && isLoggedInToCF) {
      if (!hasVCAPEnv && bindCallback) {
        const args = [path.relative(projectPath, buildResult.task.src)];
        const options = { to: `${serviceName}:${serviceKeyName}`, kind: buildResult.task.for }
        await bindCallback(args, options);
      }
    }

    if (!bindCallback) {
      await gitUtil.ensureFileIsGitignored('default-env.json', projectPath);
    }

    console.log(`If not already done, use ${info('cds add hana')} to configure the project for SAP HANA.\n`);
    console.log(`Done.`);

    return { buildResults };
  }


  async _getOrCreateCFService(projectPath, currentModelFolder, serviceName, tunnelAddress) {
    const modelName = path.basename(currentModelFolder);

    // get from param
    let cfServiceInstanceMta;
    let cfServiceInstanceName;
    if (serviceName) {
      cfServiceInstanceName = serviceName;
    } else {
      const cfServiceDescriptor = await mtaUtil.getHanaDbModuleDescriptor(projectPath, modelName);
      cfServiceInstanceName = cfServiceDescriptor.hdiServiceName;
      cfServiceInstanceMta = cfServiceDescriptor.hdiService
    }

    console.log();
    this._validateServiceInstanceName(cfServiceInstanceName);
    console.log(`Using container ${bold(cfServiceInstanceName)}`);

    let cfConfig = cfServiceInstanceMta && cfServiceInstanceMta.parameters && cfServiceInstanceMta.parameters.config;
    const serviceInstance = await this.createHanaService(cfServiceInstanceName, cfConfig);

    const cfServiceInstanceKeyName = `${cfServiceInstanceName}-key`;
    let serviceKey = await cfUtil.getOrCreateServiceKey(serviceInstance, cfServiceInstanceKeyName);
    this._validateServiceKey(serviceKey, cfServiceInstanceKeyName);

    if (tunnelAddress) {
      console.log(`Using tunnel address ${bold(tunnelAddress)} (beta feature)`);
      serviceKey = this._injectTunnelAddress(serviceKey, tunnelAddress)
    }

    return { cfServiceInstanceName, cfServiceInstanceKeyName, serviceKey, serviceInstance }
  }


  async createHanaService(instanceName, cfConfig) {
    // hana or hanatrial, error if neither found
    try {
      return await cfUtil.getOrCreateService('hana', 'hdi-shared', instanceName, cfConfig);
    } catch (error) {
      if (error.command && /offering .* not found/i.test(error.command.stderr)) {
        console.log(`Falling back to 'hanatrial'`);
        return await cfUtil.getOrCreateService('hanatrial', 'hdi-shared', instanceName, cfConfig);
      }
      else if (error.command && /no database/i.test(error.command.stderr)) {
        console.log(`No database connected to 'hana' service. Falling back to 'hanatrial'`);
        return await cfUtil.getOrCreateService('hanatrial', 'hdi-shared', instanceName, cfConfig);
      }
      throw error;
    }
  }


  _validateServiceKey(serviceKey, cfServiceInstanceKey) {
    if (!serviceKey) {
      throw new Error(`Could not create service key ${bold(cfServiceInstanceKey)}.`);
    }

    const fields = ['schema', 'user', 'password', 'url'];
    for (const field of fields) {
      if (!serviceKey[field]) {
        throw new Error(`Service key is missing mandatory field '${field}'. Make sure you are ${bold('not')} using a managed service.`);
      }
    }
  }


  async _build(model, buildTaskOptions) {
    buildTaskOptions = buildTaskOptions || {
      root: process.env._TEST_CWD || process.cwd(),
      cli: true,
      cmdOptions: {
        for: buildConstants.BUILD_TASK_HANA
      }
    };

    if (typeof model === 'string') {
      model = [model];
    }
    console.log(`Creating build tasks`);
    const buildTaskFactory = new BuildTaskFactory();
    const hanaTasks = await buildTaskFactory.getTasks(buildTaskOptions);
    console.log(`Running build`);

    const buildResults = await new BuildTaskEngine().processTasks(hanaTasks, buildTaskOptions);
    return { buildResults, hanaTasks }
  }

  async _loadEnvFile(defaultEnvFile) {
    try {
      const content = await fs.readFile(defaultEnvFile);
      return JSON.parse(content);
    } catch (err) {
      throw new Error(`Error reading default env file: ${err.message}`);
    }
  }


  async _addInstanceToDefaultEnvJson(currentFolders, serviceInstanceName, serviceKey) {
    for (const currentFolder of currentFolders) {
      let defaultEnvJson = {};
      const defaultEnvJsonPath = path.join(currentFolder, 'default-env.json');

      try {
        defaultEnvJson = JSON.parse(await fs.readFile(defaultEnvJsonPath, UTF_8));
      } catch (err) {
        // ignore any errors
      }

      defaultEnvJson.VCAP_SERVICES = defaultEnvJson.VCAP_SERVICES || {};
      for (const serviceKey of Object.keys(defaultEnvJson.VCAP_SERVICES)) {
        defaultEnvJson.VCAP_SERVICES[serviceKey] = defaultEnvJson.VCAP_SERVICES[serviceKey].filter((service) => {
          return (service.name !== serviceInstanceName);
        });
      }

      const hanaEntry = this._getVCAPServicesEntry(serviceInstanceName, serviceKey)
      Object.assign(defaultEnvJson, hanaEntry);

      console.log(`Writing ${defaultEnvJsonPath}`);
      await fs.mkdir(path.dirname(defaultEnvJsonPath), { recursive: true })
      await fs.writeFile(defaultEnvJsonPath, JSON.stringify(defaultEnvJson, null, 2));
    }
  }


  _getVCAPServicesEntry(serviceInstanceName, serviceKey) {
    return {
      VCAP_SERVICES: {
        hana: [
          {
            name: serviceInstanceName,
            tags: ['hana'],
            credentials: serviceKey
          }
        ]
      }
    };
  }


  _validateServiceInstanceName(serviceInstanceName) {
    // valid service name chars: alpha-numeric, hyphens, and underscores
    if (/[^\w-_]+/g.exec(serviceInstanceName)) {
      throw new Error(`Service name ${serviceInstanceName} must only contain alpha-numeric, hyphens, and underscores.`);
    }
  }


  _injectTunnelAddress(serviceKey, tunnelAddress) {
    if (!/\w+:\d+/.test(tunnelAddress)) {
      throw new Error(`Invalid tunnel address '${tunnelAddress}' - must be in form 'host:port'`)
    }
    const [tunnelHost, tunnelPort] = tunnelAddress.split(':')
    const { host, port } = serviceKey
    serviceKey.host = tunnelHost
    serviceKey.port = tunnelPort
    serviceKey.url = serviceKey.url.replace(`${host}:${port}`, tunnelAddress)
    serviceKey.hostname_in_certificate = host  // make cert. verification happy, see xs2/hdideploy.js#527
    serviceKey.url = serviceKey.url + (serviceKey.url.includes('?') ? '&' : '?') + 'hostNameInCertificate=' + host
    return serviceKey
  }


  async readFileSafely(file) {
    try {
      return await fs.readFile(file, 'utf8');
    } catch (err) {
      return '';
    }
  }
}

module.exports = new HanaDeployer();
